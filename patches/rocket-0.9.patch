From 2d5c313107b584e17b22bfbcf189f398fb4a78a1 Mon Sep 17 00:00:00 2001
From: Peter Mitsis <peter.mitsis@windriver.com>
Date: Fri, 12 Jun 2015 14:51:10 -0400
Subject: [PATCH 01/82] VxWorks GCC: Add Makefile.toolchain.vxworks

Implements the necessary definitions to allow the VxWorks GCC toolchain
to build the Zephyr OS.

Signed-off-by: pmitsis <peter.mitsis@windriver.com>

diff --git a/scripts/Makefile.toolchain.vxworks b/scripts/Makefile.toolchain.vxworks
new file mode 100644
index 0000000..5fcd7b4
--- /dev/null
+++ b/scripts/Makefile.toolchain.vxworks
@@ -0,0 +1,31 @@
+ifndef WIND_GNU_PATH
+$(error WIND_GNU_PATH is not set)
+endif
+
+CROSS_COMPILE_TARGET_arm = arm-wrs-vxworks
+CROSS_COMPILE_SUFFIX_arm = arm
+
+
+CROSS_COMPILE_TARGET_x86 = i586-wrs-vxworks
+CROSS_COMPILE_SUFFIX_x86 = pentium
+
+CROSS_COMPILE = $(WIND_GNU_PATH)/x86-linux2/bin/
+CROSS_COMPILE_SUFFIX = $(CROSS_COMPILE_SUFFIX_$(ARCH))
+
+TOOLCHAIN_LIBS = gcc
+
+LIB_INCLUDE_DIR += -L $(WIND_GNU_PATH)/lib/gcc/$(CROSS_COMPILE_TARGET_$(ARCH))/4.8.1
+
+export CROSS_COMPILE TOOLCHAIN_LIBS LIB_INCLUDE_DIR
+
+AS      = $(CC)
+LD      = $(CROSS_COMPILE)ld$(CROSS_COMPILE_SUFFIX)
+CC      = $(CROSS_COMPILE)cc$(CROSS_COMPILE_SUFFIX)
+CPP     = $(CROSS_COMPILE)cpp$(CROSS_COMPILE_SUFFIX)
+AR      = $(CROSS_COMPILE)ar$(CROSS_COMPILE_SUFFIX)
+NM      = $(CROSS_COMPILE)nm$(CROSS_COMPILE_SUFFIX)
+STRIP       = $(CROSS_COMPILE)strip$(CROSS_COMPILE_SUFFIX)
+OBJCOPY     = $(CROSS_COMPILE)objcopy$(CROSS_COMPILE_SUFFIX)
+OBJDUMP     = $(CROSS_COMPILE)objdump$(CROSS_COMPILE_SUFFIX)
+
+export AS LD CC CPP AR NM STRIP OBJCOPY OBJDUMP
-- 
1.9.1


From a1151437a7bcd7ecc7b63bba829703ccf8643807 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Wed, 14 Oct 2015 15:47:55 -0400
Subject: [PATCH 02/82] vxworks/arm: link against Thumb2 intrinsics

The build was mistakenly linking against 32-bit ARM binaries.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/scripts/Makefile.toolchain.vxworks b/scripts/Makefile.toolchain.vxworks
index 5fcd7b4..b412964 100644
--- a/scripts/Makefile.toolchain.vxworks
+++ b/scripts/Makefile.toolchain.vxworks
@@ -14,7 +14,10 @@ CROSS_COMPILE_SUFFIX = $(CROSS_COMPILE_SUFFIX_$(ARCH))
 
 TOOLCHAIN_LIBS = gcc
 
-LIB_INCLUDE_DIR += -L $(WIND_GNU_PATH)/lib/gcc/$(CROSS_COMPILE_TARGET_$(ARCH))/4.8.1
+LIB_INCLUDE_DIR_ARCH = $(WIND_GNU_PATH)/lib/gcc/$(CROSS_COMPILE_TARGET_$(ARCH))/4.8.1
+LIB_INCLUDE_DIR_SUBARCH_arm = /t7mt
+LIB_INCLUDE_DIR_SUBARCH_x86 =
+LIB_INCLUDE_DIR += -L $(LIB_INCLUDE_DIR_ARCH)$(LIB_INCLUDE_DIR_SUBARCH_$(ARCH))
 
 export CROSS_COMPILE TOOLCHAIN_LIBS LIB_INCLUDE_DIR
 
-- 
1.9.1


From 92be8a9f33300f66be05be4026086a9dde49f985 Mon Sep 17 00:00:00 2001
From: Peter Mitsis <peter.mitsis@windriver.com>
Date: Wed, 6 May 2015 14:23:27 -0400
Subject: [PATCH 03/82] VxWorks GCC: Append "-vxworks" to output format
 specifiers

Changes the following output format specifiers to a value that is known to
the VxWorks GCC toolchain.

elf32-littlearm -> elf32-littlearm-vxworks
elf32-bigarm    -> elf32-bigarm-vxworks
elf32-i386      -> elf32-i386-vxworks

Signed-off-by: pmitsis <peter.mitsis@windriver.com>

diff --git a/include/linker-tool-gcc.h b/include/linker-tool-gcc.h
index 609cedc..f5f1dc2 100644
--- a/include/linker-tool-gcc.h
+++ b/include/linker-tool-gcc.h
@@ -26,7 +26,8 @@
 #define __LINKER_TOOL_GCC_H
 
 #if defined(CONFIG_CPU_CORTEX_M)
-OUTPUT_FORMAT("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
+OUTPUT_FORMAT("elf32-littlearm-vxworks","elf32-bigarm-vxworks",
+			"elf32-littlearm-vxworks")
 #elif defined(CONFIG_ARC)
 OUTPUT_FORMAT("elf32-littlearc", "elf32-bigarc", "elf32-littlearc")
 #else
@@ -34,7 +35,7 @@ OUTPUT_FORMAT("elf32-littlearc", "elf32-bigarc", "elf32-littlearc")
 OUTPUT_FORMAT("elf32-iamcu")
 OUTPUT_ARCH(iamcu:intel)
 #else
-OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_FORMAT("elf32-i386-vxworks", "elf32-i386-vxworks", "elf32-i386-vxworks")
 OUTPUT_ARCH(i386)
 #endif
 #endif
diff --git a/scripts/Makefile.toolchain.vxworks b/scripts/Makefile.toolchain.vxworks
index b412964..3aca715 100644
--- a/scripts/Makefile.toolchain.vxworks
+++ b/scripts/Makefile.toolchain.vxworks
@@ -12,6 +12,10 @@ CROSS_COMPILE_SUFFIX_x86 = pentium
 CROSS_COMPILE = $(WIND_GNU_PATH)/x86-linux2/bin/
 CROSS_COMPILE_SUFFIX = $(CROSS_COMPILE_SUFFIX_$(ARCH))
 
+# only needed for gen_idt, so other architectures than x86 are ignored
+OUTPUT_FORMAT_x86 = elf32-i386-vxworks
+OUTPUT_FORMAT = $(OUTPUT_FORMAT_$(ARCH))
+
 TOOLCHAIN_LIBS = gcc
 
 LIB_INCLUDE_DIR_ARCH = $(WIND_GNU_PATH)/lib/gcc/$(CROSS_COMPILE_TARGET_$(ARCH))/4.8.1
-- 
1.9.1


From 598432b8d18dc680847288ae69c279c862d52881 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Tue, 12 Jan 2016 15:39:25 -0500
Subject: [PATCH 04/82] gdb: add microkernel GDB server sample program

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/samples/microkernel/apps/gdb_server/Makefile b/samples/microkernel/apps/gdb_server/Makefile
new file mode 100644
index 0000000..824b540
--- /dev/null
+++ b/samples/microkernel/apps/gdb_server/Makefile
@@ -0,0 +1,6 @@
+MDEF_FILE = prj.mdef
+KERNEL_TYPE = micro
+PLATFORM_CONFIG ?= basic_atom
+CONF_FILE = prj_$(ARCH).conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/microkernel/apps/gdb_server/README.txt b/samples/microkernel/apps/gdb_server/README.txt
new file mode 100644
index 0000000..7cbd387
--- /dev/null
+++ b/samples/microkernel/apps/gdb_server/README.txt
@@ -0,0 +1,92 @@
+Title: GDB Server demo
+
+Description:
+
+A simple application that demonstates the GDB Server.
+A task is polling the serial line to wait for the GDB RSP stop character (i.e
+CTRL+C). Once the GDB RSP stop character is received, the VxMicro system is
+stopped and the GDB Server is waiting for more GDB RSP packets to read/write
+memory and/or control the VxMicro OS.
+This microkernel project is using the first serial line to communicate with the
+GDB client.
+
+How to connect a GDB client?
+Start the vx_stopmode_server in interactive mode with the following command:
+
+vx_stopmode_server -L <GDB log file> -l gdb -s TCP::<port number> -i
+
+From the vx_stopmode_server command line execute the following commands to
+connect to the GDB Server and resume the execution of VxMicro.
+
+> connect TCP::<port number>
+> tcf GdbRemote addConfig "gdb0" {"Device":"tcp:localhost:<serial port tcp redirection>"}
+> tcf GdbRemote connect "gdb0"
+> tcf RunControl resume "gdb0" 0 1
+> tcf GdbRemote disconnect "gdb0"
+
+--------------------------------------------------------------------------------
+
+Building and Running Project:
+
+The microkernel project can be built and executed on x86 platforms as follows:
+
+    make
+
+--------------------------------------------------------------------------------
+
+Troubleshooting:
+
+Problems caused by out-dated project information can be addressed by
+issuing one of the following commands then rebuilding the project:
+
+    make clean          # discard results of previous builds
+                        # but keep existing configuration info
+or
+    make pristine       # discard results of previous builds
+                        # and restore pre-defined configuration info
+
+--------------------------------------------------------------------------------
+
+The GDB log file should contain GDB RSP packets that look like:
+
+TCF 15:50:30.664: w: +
+TCF 15:50:30.664: w: <break> (03)
+TCF 15:50:30.764: r: T02thread:01;8:00000000
+TCF 15:50:30.764: w: +
+TCF 15:50:30.764: gdb_client_parse_event: set running flag to 0
+TCF 15:50:30.764: w: $?#3f
+TCF 15:50:30.764: r: +
+TCF 15:50:30.765: r: T02thread:01;
+TCF 15:50:30.765: w: +
+TCF 15:50:30.765: gdb_client_parse_event: set running flag to 0
+TCF 15:50:30.765: w: $vCont?#49
+TCF 15:50:30.765: r: +
+TCF 15:50:30.765: r: vCont;c;s;C;S
+TCF 15:50:30.765: w: +
+TCF 15:50:30.765: w: $qfThreadInfo#bb
+TCF 15:50:30.765: r: +
+TCF 15:50:30.765: r: 
+TCF 15:50:30.765: w: +
+TCF 15:50:30.765: w: $qSupported#37
+TCF 15:50:30.765: r: +
+TCF 15:50:30.766: r: PacketSize=258;qXfer:features:read+;QStartNoAckMode+
+TCF 15:50:30.766: w: +
+TCF 15:50:30.766: w: $qXfer:features:read:target.xml:0,244#e5
+TCF 15:50:30.766: r: +
+TCF 15:50:30.767: r: l<?xml version="1.0"?> <!DOCTYPE target SYSTEM "gdb-target.dtd"> <target version="1.0">
+  <architecture>i386</architecture>
+</target>
+TCF 15:50:30.767: w: +
+TCF 15:50:30.767: w: $p8#a8
+TCF 15:50:30.768: r: +
+TCF 15:50:30.768: r: 00000000
+TCF 15:50:30.768: w: +
+TCF 16:11:49.813: w: $c#63
+TCF 16:11:49.813: r: +
+TCF 16:11:49.813: gdb_client_cont: set running flag to 1
+TCF 16:11:52.712: w: <break> (03)
+TCF 16:11:52.717: r: T02thread:01;8:00000000
+TCF 16:11:52.717: w: +
+TCF 16:11:52.717: gdb_client_parse_event: set running flag to 0
+TCF 16:11:52.732: w: $D#44
+TCF 16:11:52.732: r: +
diff --git a/samples/microkernel/apps/gdb_server/prj.mdef b/samples/microkernel/apps/gdb_server/prj.mdef
new file mode 100644
index 0000000..bd2b725
--- /dev/null
+++ b/samples/microkernel/apps/gdb_server/prj.mdef
@@ -0,0 +1,5 @@
+% Application       : GDB Server demo
+
+% TASK NAME  PRIO ENTRY    STACK GROUPS
+% =====================================
+  TASK GDB      7 gdbStart  2048 [EXE]
diff --git a/samples/microkernel/apps/gdb_server/prj_x86.conf b/samples/microkernel/apps/gdb_server/prj_x86.conf
new file mode 100644
index 0000000..531a9b7
--- /dev/null
+++ b/samples/microkernel/apps/gdb_server/prj_x86.conf
@@ -0,0 +1,5 @@
+# Use standard security profile. (=> no need for a random number generator)
+CONFIG_ENHANCED_SECURITY=n
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_GDB_SERVER=y
+CONFIG_COMPILER_OPT="-O0 -g"
diff --git a/samples/microkernel/apps/gdb_server/src/Makefile b/samples/microkernel/apps/gdb_server/src/Makefile
new file mode 100644
index 0000000..f8aff66
--- /dev/null
+++ b/samples/microkernel/apps/gdb_server/src/Makefile
@@ -0,0 +1,3 @@
+ccflags-y += ${PROJECTINCLUDE}
+
+obj-y = gdb_start.o
diff --git a/samples/microkernel/apps/gdb_server/src/gdb_start.c b/samples/microkernel/apps/gdb_server/src/gdb_start.c
new file mode 100644
index 0000000..2a8f53a
--- /dev/null
+++ b/samples/microkernel/apps/gdb_server/src/gdb_start.c
@@ -0,0 +1,90 @@
+/* gdb_start.c - GDB Server demo */
+
+/*
+ * Copyright (c) 2015 Wind River Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1) Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2) Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3) Neither the name of Wind River Systems nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <debug/gdb_server.h>
+
+#ifdef CONFIG_MICROKERNEL
+
+/*
+ * Microkernel version of hello world demo has two tasks that utilize
+ * semaphores and sleeps to take turns printing a greeting message at
+ * a controlled rate.
+ */
+
+#include <zephyr.h>
+
+/* specify delay between greetings (in ms); compute equivalent in ticks */
+
+#define SLEEPTIME  50
+#define SLEEPTICKS (SLEEPTIME * sys_clock_ticks_per_sec / 1000)
+
+void gdbStart(void)
+{
+	while (1) {
+        gdb_protocol_hook ();
+		/* wait a while, then let other task have a turn */
+		task_sleep(SLEEPTICKS);
+	}
+}
+
+#else /*  CONFIG_NANOKERNEL */
+
+/*
+ * Nanokernel version of hello world demo has a task and a fiber that utilize
+ * semaphores and timers to take turns printing a greeting message at
+ * a controlled rate.
+ */
+
+#include <nanokernel.h>
+
+/* specify delay between greetings (in ms); compute equivalent in ticks */
+
+#define SLEEPTIME  50
+#define SLEEPTICKS (SLEEPTIME * sys_clock_ticks_per_sec / 1000)
+
+void main(void)
+{
+	struct nano_timer timer;
+    uint32_t data[2] = {0, 0};
+
+    nano_timer_init(&timer, data);
+
+	while (1) {
+		gdb_protocol_hook ();
+
+		nano_task_timer_start(&timer, SLEEPTICKS);
+		nano_task_timer_wait(&timer);
+	}
+}
+
+#endif /* CONFIG_MICROKERNEL ||  CONFIG_NANOKERNEL */
-- 
1.9.1


From 938b14168407f12421f2ac9c5e99a6ba613cc956 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Tue, 12 Jan 2016 15:40:25 -0500
Subject: [PATCH 05/82] gdb: add nanokernel GDB server sample program

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/samples/nanokernel/apps/gdb_server/Makefile b/samples/nanokernel/apps/gdb_server/Makefile
new file mode 100644
index 0000000..f1a5347
--- /dev/null
+++ b/samples/nanokernel/apps/gdb_server/Makefile
@@ -0,0 +1,7 @@
+KERNEL_TYPE = nano
+PLATFORM_CONFIG ?= basic_atom
+CONF_FILE = prj.conf
+SOURCE_DIR = $(ZEPHYR_BASE)/samples/microkernel/apps/gdb_server/src/
+
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/nanokernel/apps/gdb_server/README.txt b/samples/nanokernel/apps/gdb_server/README.txt
new file mode 100644
index 0000000..102400d
--- /dev/null
+++ b/samples/nanokernel/apps/gdb_server/README.txt
@@ -0,0 +1,92 @@
+Title: GDB Server demo
+
+Description:
+
+A simple application that demonstates the GDB Server.
+The background task is polling the serial line to wait for the GDB RSP stop
+character (i.e CTRL+C). Once the GDB RSP stop character is received, the
+VxMicro system is stopped and the GDB Server is waiting for more GDB RSP
+packets to read/write memory and/or control the VxMicro OS.
+This nanokernel project is using the first serial line to communicate with the
+GDB client.
+
+How to connect a GDB client?
+Start the vx_stopmode_server in interactive mode with the following command:
+
+vx_stopmode_server -L <GDB log file> -l gdb -s TCP::<port number> -i
+
+From the vx_stopmode_server command line execute the following commands to
+connect to the GDB Server and resume the execution of VxMicro.
+
+> connect TCP::<port number>
+> tcf GdbRemote addConfig "gdb0" {"Device":"tcp:localhost:<serial port tcp redirection>"}
+> tcf GdbRemote connect "gdb0"
+> tcf RunControl resume "gdb0" 0 1
+> tcf GdbRemote disconnect "gdb0"
+
+--------------------------------------------------------------------------------
+
+Building and Running Project:
+
+The nanokernel project can be built and executed on x86 platforms as follows:
+
+    make
+
+--------------------------------------------------------------------------------
+
+Troubleshooting:
+
+Problems caused by out-dated project information can be addressed by
+issuing one of the following commands then rebuilding the project:
+
+    make clean          # discard results of previous builds
+                        # but keep existing configuration info
+or
+    make pristine       # discard results of previous builds
+                        # and restore pre-defined configuration info
+
+--------------------------------------------------------------------------------
+
+The GDB log file should contain GDB RSP packets that look like:
+
+TCF 15:50:30.664: w: +
+TCF 15:50:30.664: w: <break> (03)
+TCF 15:50:30.764: r: T02thread:01;8:00000000
+TCF 15:50:30.764: w: +
+TCF 15:50:30.764: gdb_client_parse_event: set running flag to 0
+TCF 15:50:30.764: w: $?#3f
+TCF 15:50:30.764: r: +
+TCF 15:50:30.765: r: T02thread:01;
+TCF 15:50:30.765: w: +
+TCF 15:50:30.765: gdb_client_parse_event: set running flag to 0
+TCF 15:50:30.765: w: $vCont?#49
+TCF 15:50:30.765: r: +
+TCF 15:50:30.765: r: vCont;c;s;C;S
+TCF 15:50:30.765: w: +
+TCF 15:50:30.765: w: $qfThreadInfo#bb
+TCF 15:50:30.765: r: +
+TCF 15:50:30.765: r: 
+TCF 15:50:30.765: w: +
+TCF 15:50:30.765: w: $qSupported#37
+TCF 15:50:30.765: r: +
+TCF 15:50:30.766: r: PacketSize=258;qXfer:features:read+;QStartNoAckMode+
+TCF 15:50:30.766: w: +
+TCF 15:50:30.766: w: $qXfer:features:read:target.xml:0,244#e5
+TCF 15:50:30.766: r: +
+TCF 15:50:30.767: r: l<?xml version="1.0"?> <!DOCTYPE target SYSTEM "gdb-target.dtd"> <target version="1.0">
+  <architecture>i386</architecture>
+</target>
+TCF 15:50:30.767: w: +
+TCF 15:50:30.767: w: $p8#a8
+TCF 15:50:30.768: r: +
+TCF 15:50:30.768: r: 00000000
+TCF 15:50:30.768: w: +
+TCF 16:11:49.813: w: $c#63
+TCF 16:11:49.813: r: +
+TCF 16:11:49.813: gdb_client_cont: set running flag to 1
+TCF 16:11:52.712: w: <break> (03)
+TCF 16:11:52.717: r: T02thread:01;8:00000000
+TCF 16:11:52.717: w: +
+TCF 16:11:52.717: gdb_client_parse_event: set running flag to 0
+TCF 16:11:52.732: w: $D#44
+TCF 16:11:52.732: r: +
diff --git a/samples/nanokernel/apps/gdb_server/prj.conf b/samples/nanokernel/apps/gdb_server/prj.conf
new file mode 100644
index 0000000..4e7a4c9
--- /dev/null
+++ b/samples/nanokernel/apps/gdb_server/prj.conf
@@ -0,0 +1,4 @@
+# Use standard security profile. (=> no need for a random number generator)
+CONFIG_ENHANCED_SECURITY=n
+CONFIG_GDB_SERVER=y
+CONFIG_COMPILER_OPT="-O0 -g"
-- 
1.9.1


From e13cc9652add7e7e8152e930f9efcc8b2f4de5b2 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Tue, 12 Jan 2016 15:42:13 -0500
Subject: [PATCH 06/82] x86: add GDB server definitions

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
new file mode 100644
index 0000000..99b0dee
--- /dev/null
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -0,0 +1,66 @@
+/* gdb_arch.h - architecture dependent GDB Server header file */
+
+/*
+ * Copyright (c) 2015 Wind River Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1) Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2) Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3) Neither the name of Wind River Systems nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __INCgdb_archh
+#define __INCgdb_archh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* define */
+
+#define GDB_TGT_ARCH    "i386"
+
+#define GDBNUMREGBYTES  (16*4)
+
+#define GDB_PC_REG      8
+
+#define GDB_BREAK_INST	(0xcc)    /* int 3 */
+
+#ifndef _ASMLANGUAGE
+
+/* typedef */
+
+typedef unsigned char GDB_INSTR;
+
+/* function declaration */
+
+extern void gdb_system_stop (void);
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCgdb_archh */
-- 
1.9.1


From 646e523aebce048328c488953a0ecd8e92d96a64 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Tue, 12 Jan 2016 15:45:56 -0500
Subject: [PATCH 07/82] gdb: add initial generic GDB server support

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/include/misc/debug/gdb_server.h b/include/misc/debug/gdb_server.h
new file mode 100644
index 0000000..cd0aaf1
--- /dev/null
+++ b/include/misc/debug/gdb_server.h
@@ -0,0 +1,58 @@
+/* gdb_server.h - GDB Server header file */
+
+/*
+ * Copyright (c) 2015 Wind River Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1) Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2) Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3) Neither the name of Wind River Systems nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __INCgdb_serverh
+#define __INCgdb_serverh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* define */
+
+#define GDB_STOP_CHAR   0x3             /* GDB RSP default value */
+
+#ifndef _ASMLANGUAGE
+
+/* typedef */
+
+/* function declaration */
+
+extern void gdb_protocol_hook (void);
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCgdb_serverh */
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
new file mode 100644
index 0000000..ba31a56
--- /dev/null
+++ b/misc/debug/gdb_server.c
@@ -0,0 +1,2347 @@
+/* gdb_server.c - GDB server */
+
+/*
+ * Copyright (c) 2015 Wind River Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1) Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2) Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3) Neither the name of Wind River Systems nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+DESCRIPTION
+
+This module provides the embedded GDB Remote Serial Protocol for VxMicro
+
+The following is a list of all currently defined GDB RSP commands.
+
+`?'
+    Indicate the reason the target halted.
+
+`c [addr]'
+    Continue. addr is address to resume. If addr is omitted, resume at
+    current address.
+
+`C sig[;addr]'
+    Continue with signal sig (hex signal number). If `;addr' is omitted,
+    resume at same address.
+
+    _WRS_XXX - Current limitation: Even if this syntax is understood, the GDB
+    server does not resume the context with the specified signal but resumes it
+    with the exception vector that caused the context to stop.
+
+`D'
+    Detach GDB from the remote system.
+
+`g'
+    Read general registers.
+
+`G XX...'
+    Write general registers.
+
+`k'
+    Detach GDB from the remote system.
+
+`m addr,length'
+    Read length bytes of memory starting at address addr. Note that addr may
+    not be aligned to any particular boundary.  The stub need not use any
+    particular size or alignment when gathering data from memory for the
+    response; even if addr is word-aligned and length is a multiple of the word
+    size, the stub is free to use byte accesses, or not. For this reason, this
+    packet may not be suitable for accessing memory-mapped I/O devices.
+
+`M addr,length:XX...'
+    Write length bytes of memory starting at address addr. XX... is the data.
+    Each byte is transmitted as a two-digit hexadecimal number.
+
+`p n'
+    Read the value of register n; n is in hex.
+
+`P n...=r...'
+    Write register n... with value r.... The register number n is in
+    hexadecimal, and r... contains two hex digits for each byte in the
+    register (target byte order).
+
+`q name params...'
+    General query. See General Query Packets description
+
+`s [addr]'
+    Single step. addr is the address at which to resume. If addr is omitted,
+    resume at same address.
+
+`S sig[;addr]'
+    Step with signal. This is analogous to the `C' packet, but requests a
+    single-step, rather than a normal resumption of execution.
+
+    _WRS_XXX - Current limitation: Even if this syntax is understood, the GDB server
+    steps the context without the specified signal (i.e like the `s [addr]'
+    command). 
+
+`T thread-id'
+    Find out if the thread thread-id is alive.
+
+`vCont[;action[:thread-id]]...'
+    Resume the inferior, specifying different actions for each thread. If an
+    action is specified with no thread-id, then it is applied to any threads
+    that don't have a specific action specified; if no default action is
+    specified then other threads should remain stopped. Specifying multiple
+    default actions is an error; specifying no actions is also an error.
+
+    Currently supported actions are:
+
+    `c'
+        Continue.
+    `C sig'
+        Continue with signal sig. The signal sig should be two hex digits.
+    `s'
+        Step.
+    `S sig'
+        Step with signal sig. The signal sig should be two hex digits.
+
+    The optional argument addr normally associated with the `c', `C', `s',
+    and `S' packets is not supported in `vCont'.
+
+`z type,addr,length'
+`Z type,addr,length'
+    Insert (`Z') or remove (`z') a type breakpoint starting at addr address of
+    length length.
+
+General Query Packets:
+`qC'
+    Return the current thread ID.
+
+`qSupported'
+    Query the GDB server for features it supports. This packet allows client to
+    take advantage of GDB server's features.
+
+    These are the currently defined GDB server features, in more detail:
+
+    `PacketSize=bytes'
+        The GDB server can accept packets up to at least bytes in length. client
+        will send packets up to this size for bulk transfers, and will never
+        send larger packets. This is a limit on the data characters in the
+        packet, including the frame and checksum. There is no trailing NUL
+        byte in a remote protocol packet;
+
+    `qXfer:features:read'
+        Access the target description. Target description can identify the
+        architecture of the remote target and (for some architectures) provide
+        information about custom register sets. They can also identify the OS
+        ABI of the remote target. Client can use this information to
+        autoconfigure for your target, or to warn you if you connect to an
+        unsupported target.
+
+        By default, the following simple target description is supported:
+
+        <target version="1.0">
+            <architecture>i386</architecture>
+        </target>
+
+        But architectures may also reports information on specific features
+        such as extended registers definitions or hardware breakpoint
+        definitions.
+
+        Each `<feature>' describes some logical portion of the target system.
+        A `<feature>' element has this form:
+ 
+        <feature name="NAME">
+            [TYPE...]
+            REG...
+        </feature>
+ 
+        Each feature's name should be unique within the description.  The name
+        of a feature does not matter unless GDB has some special knowledge of
+        the contents of that feature; if it does, the feature should have its
+        standard name.
+
+        Extended registers definitions are reported following the standard
+        register format defined by GDB Remote protocol:
+
+        Each register is represented as an element with this form:
+ 
+        <reg name="NAME"
+           bitsize="SIZE"
+           [regnum="NUM"]
+           [save-restore="SAVE-RESTORE"]
+           [type="TYPE"]
+           [group="GROUP"]/>
+ 
+        The components are as follows:
+ 
+        NAME
+            The register's name; it must be unique within the target
+            description.
+ 
+        BITSIZE
+            The register's size, in bits.
+ 
+        REGNUM
+            The register's number.  If omitted, a register's number is one
+            greater than that of the previous register (either in the current
+            feature or in a preceding feature); the first register in the
+            target description defaults to zero.  This register number is used
+            to read or write the register; e.g. it is used in the remote `p'
+            and `P' packets, and registers appear in the `g' and `G' packets
+            in order of increasing register number.
+ 
+        SAVE-RESTORE
+            Whether the register should be preserved across inferior function
+            calls; this must be either `yes' or `no'.  The default is `yes',
+            which is appropriate for most registers except for some system
+            control registers; this is not related to the target's ABI.
+ 
+        TYPE
+            The type of the register.  TYPE may be a predefined type, a type
+            defined in the current feature, or one of the special types `int'
+            and `float'.  `int' is an integer type of the correct size for
+            BITSIZE, and `float' is a floating point type (in the
+            architecture's normal floating point format) of the correct size
+            for BITSIZE.  The default is `int'.
+ 
+        GROUP
+            The register group to which this register belongs.  GROUP must be
+            either `general', `float', or `vector'.  If no GROUP is specified,
+            GDB will not display the register in `info registers'.
+ 
+
+        Hardware breakpoint definitions are reported using the following format:
+
+        <feature name="HW_BP_FEATURE">
+            <defaults
+                    max_bp="MAX_BP"
+                    max_inst_bp="MAX_INST_BP"
+                max_watch_bp="MAX_WATCH_BP"
+                length="LENGTH"
+                >
+            HW_BP_DESC...
+        </feature>
+
+        The defaults section allows to define some default values and avoid to
+        list them in each HW_BP_DESC.
+
+        Each HW_BP_DESC entry has the form:
+
+        <hwbp type="ACCESS_TYPE"
+              [length="LENGTH"]
+              [max_bp="MAX_BP"]
+              />
+
+        If HW_BP_DESC defines an item which has a default value defined, then it
+        overwrite the default value for HW_BP_DESC entry.
+
+        Items in [brackets] are optional. The components are as follows:
+
+        MAX_BP
+            Maximum number of hardware breakpoints that can be set.
+
+        MAX_INST_BP
+            Maximum number of instruction hardware breakpoints that can be set.
+
+        MAX_WATCH_BP
+            Maximum number of data hardware breakpoints that can be set.
+
+        LENGTH
+            Supported access lengths (in hexadecimal without 0x prefix).
+            Access lengths are encoded as powers of 2 which can be OR'ed.
+            For example, if an hardware breakpoint type supports 1, 2, 4,
+            8 bytes access, length will be f (0x1|0x2|0x4|0x8).
+
+        ACCESS_TYPE
+            Hardware breakpoint type:
+                inst  : Instruction breakpoint
+                watch : Write access breakpoint
+                rwatch: Read access breakpoint
+                awatch: Read|Write access breakpoint
+
+        The GDB server can also reports additional information using the
+        "WR_AGENT_FEATURE" feature. The purpose of this feature is to report
+        information about the agent configuration.
+        The GDB server feature is using the following format:
+
+        <feature name="WR_AGENT_FEATURE">
+            <config max_sw_bp="MAX_SW_BP"
+                    step_only_on_bp="STEP_ONLY_ON_BP"
+                    />
+        </feature>
+
+        The components are as follows:
+
+        MAX_SW_BP
+            Maximum number of software breakpoint that can be set.
+
+        STEP_ONLY_ON_BP
+            This parameter is set to 1 if the GDB server is only able to
+            step the context which hit the breakpoint.
+            This parameter is set to 0 if the GDB server is able to step
+            any context.
+
+    `QStartNoAckMode'
+        By default, when either the client or the server sends a packet,
+        the first response expected is an acknowledgment: either `+' (to
+        indicate the package was received correctly) or `-' (to request
+        retransmission). This mechanism allows the GDB remote protocol to
+        operate over unreliable transport mechanisms, such as a serial line.
+
+        In cases where the transport mechanism is itself reliable (such as a
+        pipe or TCP connection), the `+'/`-' acknowledgments are redundant. It
+        may be desirable to disable them in that case to reduce communication
+        overhead, or for other reasons. This can be accomplished by means of
+        the `QStartNoAckMode' packet.
+
+    `WrCons`
+        This parameter indicates that the GDB server supports transfer of
+        VxMicro console I/O to the client using GDB notification packets.
+
+        XXX - Current limitation: For now, the GDB server only supports the
+        console output.
+
+    `qwr.vmcs:thread-id,vmcs-addr,regnum'
+            This is a WR extension of the GDB Remote Serial Protocol. This command
+        reads the VMCS register <regnum> of the cpu <thread-id> with a VMCS
+        area located at <vmcs-addr>.
+
+    `Qwr.vmcs:thread-id,vmcs-addr,regnum=val'
+            This is a WR extension of the GDB Remote Serial Protocol. This command
+        writes <val> to the VMCS register <regnum> of the cpu <thread-id> with
+        a VMCS area located at <vmcs-addr>.
+
+    `qwr.eregs:regnum'
+            This is a WR extension of the GDB Remote Serial Protocol. This command
+        reads the extended register <regnum> of the selected cpu (i.e cpu
+        selected by the `Hg thread-id' command).
+
+    `qwr.cpuid:<arg1>,<arg2>"
+        This is a WR extension of the GDB Remote Serial Protocol. This command
+        execute the cpuid instruction if supported by current cpu. The command
+        arguments are specified with <arg1> and <arg2>. The cpuid instruction
+        results consist in four 32-bit values returned in hexadecimal format:
+
+            "<res1><res2><res3><res4>"
+
+Notification Packets:
+    WR extension of the GDB Remote Serial Protocol uses notification packets
+    (See `WrCons` support).
+    Those packets are transfered using the following format:
+        %<notificationName:<notificationData>#<checksum>
+
+    For example:
+        %WrCons:<notificationData>#<checksum>
+*/
+
+#include <nanokernel.h>
+#include <stdio.h>
+#include <string.h>
+#include <board.h>
+#include <uart.h>
+#include <gdb_server.h>
+#include <debug/gdb_arch.h>
+
+extern int    (*_func_gdbPacketPut) (unsigned char * str, int len);
+
+/* defines */
+
+#define STUB_OK "OK"
+#define STUB_ERROR "ENN"
+
+#define NOT_DEBUGGING   0
+#define DEBUGGING       1
+#define STOP_RUNNING    2
+#define SINGLE_STEP     3
+
+#define GDB_BUF_SIZE    600      /* Default GDB buffer size */
+
+#define MAX_SW_BP       CONFIG_GDB_SERVER_MAX_SW_BP     /* Maximum number of software breakpoints */
+
+
+#define VARIABLE_WRITE_SYNC(var,value)  var=value
+#define MEM_WRITE_SYNC(ptr,size)
+#define OUTBUF_FILL(x) strncpy ((char *)outBuf, x, GDB_BUF_SIZE - 1)
+
+#define STR_COMMA_SEPARATOR     ","
+#ifdef        GDB_ARCH_HAS_VMCS
+#define STR_QWR_VMCS    ";qwr.vmcs+;Qwr.vmcs+"
+#endif
+#ifdef        GDB_ARCH_HAS_EXTENDED_REGISTERS
+#define STR_QWR_EREGS   ";qwr.eregs+"
+#endif
+#ifdef        GDB_ARCH_HAS_CPUID
+#define STR_QWR_CPUID   ";qwr.cpuid+"
+#endif
+
+/* typedef */
+ 
+enum gdb_signal
+    {
+    GDB_SIG_NULL = -1,
+    GDB_SIG_INT = 2,
+    GDB_SIG_TRAP = 5,
+    GDB_SIG_STOP = 17
+    };
+
+typedef enum gdb_bp_type
+    {
+    GDB_SOFT_BP,                /* software breakpoint */
+    GDB_HW_INST_BP,             /* hardware instruction breakpoint */
+    GDB_HW_DATA_WRITE_BP,       /* write watchpoint */
+    GDB_HW_DATA_READ_BP,        /* read watchpoint */
+    GDB_HW_DATA_ACCESS_BP,      /* access watchpoint */
+    GDB_UNKNOWN_BP_TYPE = -1    /* unknown breakpoint type */
+    } GDB_BP_TYPE;
+
+typedef enum gdb_error_code
+    {
+    GDB_ERROR_BP_LIST_FULL = 1,         /* Reach max number of Hard&Soft BPs */
+    GDB_ERROR_INVALID_BP,               /* No such BP in breakpoints list */
+    GDB_ERROR_HW_BP_INVALID_TYPE,       /* Unsupported type/len combination */
+    GDB_ERROR_HW_BP_DBG_REGS_FULL,      /* Debug register set full */
+    GDB_ERROR_HW_BP_NOT_SUP
+    } GDB_ERROR_CODE;
+
+typedef struct
+    {
+    GDB_INSTR * addr;	/* breakpoint address */
+    GDB_INSTR insn;		/* saved instruction */
+    char valid;			/* breakpoint is valid? */
+    char enabled;		/* breakpoint is enabled? */
+    } BP_ARRAY;
+
+#if 0
+typedef enum gdb_exception_mode
+    {
+    GDB_EXC_TRACE,		/* trace exception */
+    GDB_EXC_BP,			/* breakpoint exception */
+    GDB_EXC_OTHER,		/* other exceptions */
+    } EXC_MODE;
+#endif
+
+/* local definitions */
+
+static const unsigned char hexchars[] = {
+        '0', '1', '2', '3', '4', '5', '6', '7',
+        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
+};
+
+static int gdb_is_connected = 0;	/* A client is connected to GDB Server */
+static int gdb_no_ack = 0;
+static volatile int gdb_debug_status = NOT_DEBUGGING;
+static volatile int gdb_event_is_pending = 0;
+static volatile int gdb_cpu_stop_signal;
+static volatile int gdb_cpu_pending_sig;
+#if 0
+static int gdb_trace_lock_key = 0;
+static volatile int    gdbCpuStopBpType;  /* BP type */
+#endif
+
+static const char * xml_target_header = "<?xml version=\"1.0\"?> " \
+                            "<!DOCTYPE target SYSTEM " \
+                            "\"gdb-target.dtd\"> <target version=\"1.0\">\n";
+static const char * xml_target_footer = "</target>";
+static unsigned char outBuf [GDB_BUF_SIZE];
+static unsigned char inBuf [GDB_BUF_SIZE];
+static unsigned char tmp_buffer [GDB_BUF_SIZE];
+static unsigned char tmp_reg_buffer [GDBNUMREGBYTES];
+
+/*
+ * GDB breakpoint table. Note that all the valid entries in the
+ * breakpoint table are kept contiguous. When parsing the table, the first
+ * invalid entry in the table marks the end of the table.
+ */
+static BP_ARRAY bpArray[MAX_SW_BP];
+
+#if 0
+static int cpuStopByBp;
+
+LOCAL REG_SET           stopModeAgentRegs;
+LOCAL void *            pStopModeStackBase;
+LOCAL int               stopLockLevel = 0;
+
+#if	DBG_NO_SINGLE_STEP
+LOCAL GDB_INSTR *           gdbStepEmuNextPc;
+LOCAL GDB_INSTR             gdbStepEmuInsn;
+LOCAL VM_CONTEXT_ID     stoppedVmCtx[VX_MAX_SMP_CPUS];
+#endif /* DBG_NO_SINGLE_STEP */
+#endif
+
+/* global definitions */
+
+#if 0
+GDB_CPU_REG_SET stopModeRegs;
+#endif
+
+/* forward static declarations */
+static int putPacket(unsigned char * buffer);
+static int putDebugString (unsigned char *str, int len);
+static void putDebugChar(unsigned char ch);
+static int getDebugChar (void);
+
+static void gdb_post_event (void);
+static void gdb_ctrl_loop (void);
+static void gdb_cpu_resume (void);
+
+#if 0
+
+#if	DBG_NO_SINGLE_STEP || DBG_STEP_AND_BP_SHARED_VEC
+LOCAL BOOL gdbTrapHandler (int level, GDB_INSTR * pAddr, void * pInfo,
+			   REG_SET * pRegisters, void *	pDbgRegSet,
+			   BOOL hardware);
+#endif	/* DBG_NO_SINGLE_STEP */
+
+LOCAL BOOL gdbHandler   (EXC_MODE mode, int level, void * pInfo,
+                         REG_SET * pRegisters, void * pDbgRegSet,
+                         BOOL hardware, int signal);
+LOCAL BOOL gdbBpHandler (int level, void * pInfo,
+                          REG_SET * pRegisters, void * pDbgRegSet,
+                          BOOL hardware);
+LOCAL BOOL gdbTraceHandler (int level, void * pInfo, REG_SET * pRegisters);
+#endif
+
+int (*_func_gdbPacketPut) (unsigned char * pBuf, int len) = (void *)0;
+void (*_func_gdbDisconnect) (void) = (void *) 0;
+
+static int hex(unsigned char ch)
+{
+        if ((ch >= 'a') && (ch <= 'f')) {
+                return ch - 'a' + 10;
+        }
+        if ((ch >= '0') && (ch <= '9')) {
+                return ch - '0';
+        }
+        if ((ch >= 'A') && (ch <= 'F')) {
+                return ch - 'A' + 10;
+        }
+        return -1;
+}
+
+static int hex2llong (unsigned char ** ptr, long long * value)
+{
+        int numChars = 0;
+        int hexValue;
+
+        *value = 0;
+        while (**ptr) {
+                hexValue = hex(**ptr);
+                if (hexValue < 0) {
+                        break;
+                }
+                *value = (*value << 4) | hexValue;
+                numChars++;
+                (*ptr)++;
+        }
+        return numChars;
+}
+
+static int hex2int (unsigned char ** ptr, int * value)
+    {
+        int numChars = 0;
+        int hexValue;
+        int neg = 0;
+
+        *value = 0;
+
+        if (**ptr == '-') 
+            {
+            neg = 1;
+            (*ptr)++;
+            numChars ++;
+            }
+
+        while (**ptr) {
+                hexValue = hex(**ptr);
+                if (hexValue < 0) {
+                        break;
+                }
+                *value = (*value << 4) | hexValue;
+                numChars++;
+                (*ptr)++;
+        }
+
+        if (neg)
+            {
+            if (numChars == 1)
+                    {
+                    (*ptr)--;
+                numChars = 0;
+                }
+            else
+                *value = -(*value);
+            }
+        return numChars;
+    }
+
+/*
+ * Convert two ASCII hex characters to byte value
+ */
+
+static int get_hex_byte(unsigned char **ptrp)
+{
+        unsigned char *ptr = *ptrp;
+        int rval;
+
+        rval = hex(*ptr++);
+        rval = rval*16 + hex(*ptr++);
+        if(rval >= 0) {
+                *ptrp = ptr;
+        }
+        return rval;
+}
+
+/*
+ * Write two hex characters from int
+ */
+
+static unsigned char *put_hex_byte(unsigned char *ptr, int value)
+{
+        *ptr++ = hexchars[value >> 4];
+        *ptr++ = hexchars[value & 0xf];
+        return ptr;
+}
+
+/*
+ * Convert the memory pointed to by mem into ascii (hex), placing
+ * result in buf. Return a pointer to the last char put in buf (null)
+ */
+
+static unsigned char * compress(unsigned char * buf)
+        {
+        unsigned char * read_ptr = buf;
+        unsigned char * write_ptr = buf;
+        unsigned char        ch;
+        size_t     count = strlen ((char *)buf);
+        int        max_repeat = 126 - 29;
+        size_t     ix;
+
+        for (ix = 0; ix < count; ix++)
+            {
+            int        num = 0;
+            int        jx;
+
+            ch = *read_ptr++;
+            *write_ptr++ = ch;
+            for (jx = 1; ((jx + ix) < count) && (jx < max_repeat); jx++)
+                    {
+                if (read_ptr[jx - 1] == ch)
+                    num ++;
+                else
+                    break;
+                }
+            if (num >= 3)
+                {
+                /*
+                 * It is not possible to use the '$', '#' and '%' characters to 
+                 * encode the size per gdb remote protocol specification. 
+                 * skip them.
+                 */
+
+                while (((num + 29) == '$') || ((num + 29) == '#') ||
+                       ((num + 29) == '%'))
+                    num--;
+
+                *write_ptr++ = '*';
+                *write_ptr++ = (unsigned char)(num + 29);
+                read_ptr += num;
+                ix += num;
+                }
+            }
+        *write_ptr = 0;
+        return (write_ptr);
+        }
+
+/*******************************************************************************
+*
+* mem2hex - encode memory data using hexadecimal value of chars from '0' to 'f'
+*
+* For example, 0x3 (CTRL+C) will be encoded with hexadecimal values of
+* '0' (0x30) and '3' (0x33): "3033".
+* Using mem2hex() to encode a buffer avoid to send control chars that could
+* perturbate communication protocol.
+*
+* RETURNS: Pointer to the last char put in buf (null).
+*
+* ERRNO: N/A
+*
+*/
+
+static unsigned char * mem2hex
+    (
+    unsigned char *     mem,              /* data to encode */
+    unsigned char *     buf,              /* output buffer */
+    int                 count,            /* size of data to encode */
+    int                 doCompress        /* Compress output data ? */
+    )
+    {
+    int i;
+    unsigned char ch;
+    unsigned char * saved_buf = buf;
+
+    for (i = 0; i < count; i++)
+        {
+        ch = *mem++;
+        buf = put_hex_byte(buf, ch);
+        }
+    *buf = 0;
+
+    if (doCompress)
+        return compress (saved_buf);
+
+    return (buf);
+    }
+
+static int putPacket(unsigned char * buffer)
+    {
+    unsigned char checksum = 0;
+    int        writeIx = 0;
+    int        count = 0;
+    unsigned char ch;
+
+    /*  $<packet info>#<checksum>. */
+    do
+        {
+        writeIx = 0;
+        tmp_buffer[writeIx++] = '$';
+        checksum = 0;
+        count = 0;
+
+        /* Buffer terminated with null character */
+
+        while ((ch = buffer[count]))
+            {
+            tmp_buffer[writeIx++] = ch;
+            checksum = (unsigned char) (checksum + ch);
+            count += 1;
+            }
+        tmp_buffer[writeIx++] = '#';
+        tmp_buffer[writeIx++] = hexchars[(checksum >> 4)]; 
+        tmp_buffer[writeIx++] = hexchars[(checksum & 0xf)];
+
+        /* Send packet */
+
+        (void)putDebugString (tmp_buffer, writeIx);
+
+        if (gdb_no_ack == 0)
+            {
+            /* Wait for ack */
+
+            ch = (unsigned char)getDebugChar ();
+            if (ch == '+')
+                return 0;
+            if (ch == '$')
+                    {
+                putDebugChar ('-');
+                return 0;
+                    }
+            if (ch == GDB_STOP_CHAR)
+                {
+                gdb_cpu_stop_signal = GDB_SIG_INT;
+                VARIABLE_WRITE_SYNC (gdb_debug_status, DEBUGGING);
+                gdb_post_event ();
+                return 0;
+                }
+            }
+        else
+            return 0;
+        } while (1);
+    }
+
+void gdb_server_init (void) {
+	static int gdb_is_initialized = 0;
+
+    if (!gdb_is_initialized) {
+        gdb_is_initialized = 1;
+    }
+}
+
+
+void gdb_post_event (void)
+    {
+    int async_stop = 0;
+
+    VARIABLE_WRITE_SYNC (gdb_event_is_pending, 0);
+    if (gdb_cpu_stop_signal != GDB_SIG_NULL)
+        {
+        async_stop = 1;
+        }
+    if (async_stop)
+	{
+        unsigned char * ptr = outBuf;
+        size_t bufSize = GDB_BUF_SIZE;
+        if (gdb_cpu_stop_signal != GDB_SIG_NULL)
+            {
+            int offset;
+            int size;
+            int count;
+            unsigned char * savedPtr;
+            if (ptr != outBuf)
+                {
+                *ptr++ = '|';
+                bufSize--;
+                }
+            count = snprintf ((char *)ptr, bufSize,
+                        "T%02xthread:%02x", gdb_cpu_stop_signal, 1);
+            ptr += count;
+            bufSize -= count;
+            count = snprintf ((char *)ptr, bufSize, ";%x:", GDB_PC_REG);
+            ptr += count;
+            bufSize -= count;
+#if 0
+            (void)gdbArchRegsGet (&stopModeRegs,
+                                      (char *)tmp_reg_buffer);
+            (void)gdbArchRegInfoGet (GDB_PC_REG, &size, &offset);
+#else
+            size = 4;
+            offset = 0;
+#endif
+            savedPtr = ptr;
+            ptr = mem2hex (tmp_reg_buffer + offset, ptr, size, 1);
+            bufSize -= (ptr - savedPtr);
+
+            /* clear stop reason */
+            gdb_cpu_stop_signal = GDB_SIG_NULL;
+            }
+        *ptr = '\0';
+        }
+    else
+	{
+        (void)snprintf ((char *)outBuf, GDB_BUF_SIZE, "S%02x", GDB_SIG_INT);
+	}
+
+    (void)putPacket (outBuf);
+    }
+
+/*******************************************************************************
+*
+* getDebugChar - get a character from serial line
+*
+* This routine gets a character from the serial line. It loops until it has
+* received a character or until it has detected that a GDB event is pending
+* and should be handled.
+*
+* Note that this routine should only be called from the gdb control loop
+* when the system is stopped.
+*
+* RETURNS: -1 if no character has been received and there is a GDB event
+* pending or debug operation pending, received character otherwise.
+*/
+static int getDebugChar (void)
+    {
+    char ch;
+
+    while (uart_poll_in (UART_CONSOLE_DEV, &ch) != 0)
+        {
+        if (gdb_event_is_pending)
+            return -1;
+        }
+    return (ch);
+    }
+
+/*******************************************************************************
+*
+* gdb_protocol_get_packet - gets a GDB serial packet
+*
+* This routine polls the serial line to get a full GDB serial packet. Once
+* the packet is received, it computes its checksum and return acknowledgment.
+* It then returns the packet to the caller.
+*
+* This routine must only be called when all CPUs are stopped (from the GDB
+* CPU control loop).
+*
+* If a pending GDB event is detected or if a stop event is received from the
+* client, the corresponding GDB stop event is sent to the client. This 
+* loop does also handle the GDB cpu loop hooks by the intermediate of
+* getDebugChar() API.
+*
+* If a debug operation is pending, this routine returns immediately.
+*
+* RETURNS: received packet or NULL on pending debug operation
+*/
+
+unsigned char * gdb_protocol_get_packet(unsigned char * buffer, size_t size)
+    {
+    unsigned char ch;
+    unsigned char * pBuf = buffer;
+
+    unsigned char checksum;
+
+    while (1)
+        {
+        while ((ch = (unsigned char)getDebugChar()) != '$')
+            {
+            if (!gdb_event_is_pending)
+                return NULL;
+                
+            /* ignore other chars than GDB break character */
+            if ((ch == GDB_STOP_CHAR) || gdb_event_is_pending)
+                    gdb_post_event ();
+            }
+        
+        checksum = 0;
+
+        /*****************************************************
+        * Continue reading characters until a '#' is found
+        * or until the end of the buffer is reached.
+        *****************************************************/
+
+        while (pBuf < &buffer[size])
+            {
+            ch = (unsigned char)getDebugChar();
+
+            if (ch == '#')
+                {
+                break;
+                }
+            else if (ch == '$')
+                {
+                /* start over */
+                checksum = 0;
+                pBuf = buffer;
+                continue;
+                }
+            else
+                {
+                checksum = (unsigned char) (checksum + ch);
+                *pBuf++ = ch;
+                }
+            }
+        *pBuf = 0;
+
+        if (ch == '#')
+            {
+            if (gdb_no_ack)
+                {
+                (void) getDebugChar();
+                (void) getDebugChar();
+                return buffer;
+                }
+            else
+                {
+                if (checksum != (unsigned char)
+                        ((hex((unsigned char)getDebugChar()) << 4) |
+                         (hex((unsigned char)getDebugChar()))))
+                    {
+                    /* checksum failed */
+                    putDebugChar ('-');
+                    }
+                else
+                    {
+                    /* checksum passed */
+                    putDebugChar ('+');
+
+                    if (buffer[2] == ':')
+                        {
+                        putDebugChar (buffer[0]);
+                        putDebugChar (buffer[1]);
+                        return &buffer[3];
+                        }
+                    return buffer;
+                    }
+                }
+            }
+        }
+
+    return NULL;
+    }
+
+
+/*******************************************************************************
+*
+* write_xml_string - write a XML string into output buffer
+*
+* This routine is used to write a XML string to output buffer. It takes care
+* of offset, length and also deal with overflow (if the XML string is bigger
+* than the output buffer).
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*/
+
+static void write_xml_string (char * outBuf, const char * xml_string,
+                                int offset, int length) 
+    {
+    size_t max_length = strlen (xml_string);
+    if (offset == max_length) {
+        /* XXX rlp - No strncat support - quick workaround
+         * strncat ((char *)outBuf, "l", length - 1); */
+    	size_t len = strlen ((char *)outBuf);
+    	*(outBuf + len) = 'l';
+    	*(outBuf + len + 1) = '\0';
+    }
+    else if (offset > max_length)
+        OUTBUF_FILL ("E00");
+    else
+        {
+        if ((offset + max_length) <= length)
+            {
+            /* we can read the full data */
+            outBuf[0] = 'l';
+            strncpy (&outBuf[1], xml_string + offset,
+                     (length <= GDB_BUF_SIZE-2) ? length : GDB_BUF_SIZE-2);
+            }
+        else
+            {
+            outBuf[0] = 'm';
+            strncpy (&outBuf[1], xml_string + offset, GDB_BUF_SIZE-2);
+            outBuf[length+1] = '\0';
+            }
+        }
+    }
+
+/*******************************************************************************
+*
+* get_xml_target_description - get XML target description
+*
+* This routine is used to build the string that will hold the XML target
+* description provided to the GDB client.
+*
+* RETURNS: a pointer on XML target description
+*
+* ERRNO: N/A
+*/
+
+static char * get_xml_target_description (void)
+    {
+    static char target_description[GDB_BUF_SIZE] = {0};
+    char * ptr = target_description;
+    size_t bufSize = sizeof (target_description);
+    size_t size;
+    if (target_description[0] != 0) return target_description;
+    strncpy (ptr, xml_target_header, GDB_BUF_SIZE-1);
+    size = strlen (ptr);
+    ptr += size;
+    bufSize -= size;
+
+    /* Add architecture definition */
+
+    (void)snprintf (ptr, bufSize, "  <architecture>%s</architecture>\n",
+                    GDB_TGT_ARCH);
+    size = strlen (ptr);
+    ptr += size;
+    bufSize -= size;
+
+    strncpy (ptr, xml_target_footer,
+             GDB_BUF_SIZE - (ptr - target_description) - 1);
+    return target_description;
+    }
+
+
+/*******************************************************************************
+*
+* gdb_bp_add - add a new breakpoint or watchpoint to breakpoint list
+*
+* This routine adds a new breakpoint or watchpoint to breakpoint list.
+* For watchpoints, this routine checks that the given type/length combination
+* is supported on current architecture, and that debug registers are not full.
+*
+* <type> : GDB breakpoint type:
+*	0 : software breakpoint	(GDB_SOFT_BP)
+*	1 : hardware breakpoint	(GDB_HW_INST_BP)
+*	2 : write watchpoint	(GDB_HW_DATA_WRITE_BP)
+*	3 : read watchpoint	(GDB_HW_DATA_READ_BP)
+*	4 : access watchpoint	(GDB_HW_DATA_ACCESS_BP)
+*
+* <addr>     : breakpoint address.
+* <length>   : length is in bytes. For a software breakpoint, length specifies
+*              the size of the instruction to be patched. For hardware
+*	       breakpoints and watchpoints length specifies the memory
+*	       region to be monitored.
+* <pErrCode> : ptr to error code if failed to add breakpoint.
+*
+* RETURNS: 0, or -1 if failed to add breakpoint.
+*
+* ERRNO: N/A
+*
+*/
+
+int gdb_bp_add (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCode) {
+    int	ix;
+
+    if (type != GDB_SOFT_BP) {
+        *pErrCode = GDB_ERROR_HW_BP_NOT_SUP;
+        return -1;
+    }
+
+#if 0
+    if (gdb_mem_probe ((void *) addr, length, 0) != length)
+            return (-1);
+#endif
+
+    /* Add software breakpoint to BP list */
+
+    for (ix = 0; ix < MAX_SW_BP; ix++)
+    	{
+	    if (bpArray[ix].valid == 0)
+	        {
+	        bpArray[ix].valid = 1;
+	        bpArray[ix].enabled = 0;
+	        bpArray[ix].addr = (GDB_INSTR *) addr;
+	        }
+
+	    return (0);
+	    }
+
+    *pErrCode = GDB_ERROR_BP_LIST_FULL;
+    return -1;
+    }
+
+/*******************************************************************************
+*
+* gdb_bp_delete - delete a breakpoint or watchpoint from breakpoint list
+*
+* This routine removes a breakpoint or watchpoint from breakpoint list.
+*
+* RETURNS: 0, or -1 if failed to remove breakpoint.
+*/
+
+int gdb_bp_delete (GDB_BP_TYPE type, long addr, int	length, GDB_ERROR_CODE * pErrCode) {
+    int	ix, jx;
+
+    if (type != GDB_SOFT_BP)
+        {
+        *pErrCode = GDB_ERROR_HW_BP_NOT_SUP;
+        return -1;
+        }
+
+    for (ix = 0; ix < MAX_SW_BP; ix++) {
+	    if (bpArray[ix].valid == 1 &&
+	        bpArray[ix].addr == (GDB_INSTR *) addr) {
+	        bpArray[ix].valid = 0;	/* invalidate entry */
+
+	        /*
+	         * Make sure all valid entries are contiguous to speed up
+	         * breakpoint table parsing.
+	         */
+
+	        for (jx = ix + 1; jx < MAX_SW_BP; jx++) {
+		        if (bpArray[jx].valid == 1) {
+		            bpArray[jx - 1] = bpArray[jx];
+		            bpArray[jx].valid = 0;
+		        } else
+		            break;
+		    }
+	        return (0);
+	    } else if (bpArray[ix].valid == 0) {
+	        /* The first non valid entry in the table is the last entry */
+
+	        break;
+	    }
+	}
+
+    *pErrCode = GDB_ERROR_INVALID_BP;
+    return (-1);
+    }
+
+/*******************************************************************************
+*
+* gdb_bps_remove - remove all installed breakpoints
+*
+* This routine removes all installed breakpoints.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+void gdb_bps_remove (void) {
+    int	ix;
+
+    for (ix = 0; ix < MAX_SW_BP; ix++)
+	{
+	/* First non valid entry in the table is the last entry */
+
+	if (bpArray[ix].valid == 0)
+	    break;
+	bpArray[ix].valid = 0;
+	}
+}
+
+/*******************************************************************************
+*
+* gdb_protocol_parse - parse given GDB command string
+*
+* This routine parses and executes the given GDB command string, and send
+* acknowledgment if acknowledgment is enabled.
+*
+* RETURNS: 0, or -1 if failed to send acknowledgment.
+*
+* ERRNO: N/A
+*
+*/
+
+int gdb_protocol_parse (unsigned char * ptr)
+    {
+    unsigned char ch;
+#ifdef RESUME_AT_SUPPORT
+    long long     save_pc;
+#endif
+    int                no_ack = 0;
+   
+    ch = *ptr++;
+    outBuf[0] = '\0';
+
+    switch (ch)
+        {
+            case '?':
+                {
+                /*
+                 * This is a new connection. Clear gdb_no_ack field if it was
+                 * set and send acknowledgment for this command that has
+                 * not been sent as it should have.
+                 */
+                if (gdb_no_ack)
+                    {
+                    putDebugChar ('+');
+                    gdb_no_ack = 0;
+                    }
+
+                (void)snprintf ((char *)outBuf, GDB_BUF_SIZE,
+                                "T02thread:%02x;", 1);
+
+                /*
+                 * This is an initial connection, should remove all 
+                 * the breakpoints and cleanup.
+                 */
+                gdb_bps_remove ();
+                gdb_is_connected = 1;
+                break;
+                }
+            case 'k':   /* kill but do not kill here */
+            case 'D':   /* detach  */
+                {
+                OUTBUF_FILL (STUB_OK);
+                gdb_bps_remove ();
+                gdb_is_connected = 0;
+                if (_func_gdbDisconnect != NULL)
+                    (*_func_gdbDisconnect)();
+                VARIABLE_WRITE_SYNC (gdb_debug_status, NOT_DEBUGGING);
+                gdb_cpu_resume ();
+                no_ack = 1;
+                gdb_no_ack = 0;
+                break;
+                }
+            case 'T':
+                {
+                int        thread;
+
+                if (!hex2int (&ptr, &thread))
+                    break;
+                if (thread != 1)
+                    OUTBUF_FILL (STUB_ERROR);
+                else
+                    OUTBUF_FILL (STUB_OK);
+                break;
+                }
+            case 'Q':                                /* Set Packet */
+                {
+                if (strcmp((const char *)ptr, "StartNoAckMode") == 0)
+                    {
+                    gdb_no_ack = 1;
+                    OUTBUF_FILL (STUB_OK);
+                    }
+#ifdef        GDB_ARCH_HAS_VMCS
+                else if (strncmp((const char *)ptr, "wr.vmcs:", 8) == 0)
+                    {
+                    long long addr;
+                    int regNum = 0;
+                    int thread_id;
+                    ptr += 8;
+                    OUTBUF_FILL (STUB_ERROR);
+                    if (hex2int((unsigned char ** )&ptr, &thread_id) &&
+                        *ptr++ == ',' &&
+                        hex2llong ((unsigned char ** )&ptr, &addr) &&
+                        *ptr++ == ',' &&
+                        hex2int ((unsigned char ** )&ptr, &regNum) &&
+                        *ptr++ == '=')
+                        {
+                        long long value;
+                        if (hex2llong ((unsigned char ** )&ptr, &value))
+                            {
+                            if (gdb_arch_write_vmcs (thread_id - 1,
+                                                        (void *) ((long)addr),
+                                                        regNum, value) > 0)
+                                {
+                                OUTBUF_FILL (STUB_OK);
+                                }
+                            }
+                        }
+                    }
+#endif
+                break;
+                }
+            case 'q':                                /* Query Packet */
+                {
+                if (ptr[0] == 'C')
+                    {
+                    (void)snprintf ((char *)outBuf, GDB_BUF_SIZE, "QC%x", 1);
+                    }
+                else if (strncmp((const char *)ptr, "wr.", 3) == 0) 
+                    {
+                    ptr += 3;
+#ifdef        GDB_ARCH_HAS_VMCS
+                    if (strncmp ((const char *)ptr, "vmcs:", 5) == 0) 
+                            {
+                        long long addr;
+                        int regNum = 0;
+                        int thread_id;
+                        ptr += 5;
+                        if (hex2int((unsigned char ** )&ptr, &thread_id) &&
+                            *ptr++ == ',' &&
+                            hex2llong ((unsigned char ** )&ptr, &addr) &&
+                            *ptr++ == ',' &&
+                            hex2int ((unsigned char ** )&ptr, &regNum) &&
+                            *ptr == '\0') 
+                            {
+                            int size;
+                            size = gdb_arch_read_vmcs (thread_id - 1,
+                                                        (void *) ((long)addr),
+                                                        regNum, tmp_buffer);
+                            if (size > 0)
+                                mem2hex (tmp_buffer, outBuf, size, 1);
+                            else
+                                OUTBUF_FILL (STUB_ERROR);
+                            }
+                        else
+                            OUTBUF_FILL (STUB_ERROR);
+                        }
+#endif
+#ifdef        GDB_ARCH_HAS_EXTENDED_REGISTERS
+                    if (strncmp ((const char *)ptr, "eregs:", 6) == 0) 
+                            {
+                        int size = -1;
+                        int regNum = 0;
+
+                        ptr += 6;
+                        if (hex2int(&ptr, &regNum)) 
+                            {
+                            size = gdb_arch_read_extended_registers
+                                                    (global_cpu, regNum,
+                                                    (char *)tmp_buffer);
+                            }
+                        if (size > 0)
+                            mem2hex (tmp_buffer, outBuf, size, 1);
+                        else
+                            OUTBUF_FILL (STUB_ERROR);
+                        }
+#endif
+#ifdef        GDB_ARCH_HAS_CPUID
+                    if (strncmp ((const char *)ptr, "cpuid:", 6) == 0) 
+                            {
+                        uint32_t arg1 = 0;
+                        uint32_t arg2 = 0;
+                        uint32_t res1 = 0;
+                        uint32_t res2 = 0;
+                        uint32_t res3 = 0;
+                        uint32_t res4 = 0;
+
+                        ptr += 6;
+                        if (hex2int((unsigned char ** )&ptr, (int *)&arg1) &&
+                            *ptr++ == ',' &&
+                            hex2int ((unsigned char ** )&ptr, (int *)&arg2) &&
+                            *ptr == '\0') 
+                            {
+                            if (gdb_arch_cpuid_get (arg1, arg2,
+                                        &res1, &res2, &res3, &res4) == 0)
+                                (void)snprintf ((char *)outBuf, sizeof(outBuf),
+                                                "%08x%08x%08x%08x",
+                                                res1, res2, res3, res4);
+                            else
+                                OUTBUF_FILL (STUB_ERROR);
+                            }
+                        else
+                            OUTBUF_FILL (STUB_ERROR);
+                        }
+#endif        /* GDB_ARCH_HAS_CPUID */
+                    }
+                else if (strcmp ((const char *)ptr, "Supported") == 0)
+                    {
+                    size_t size = GDB_BUF_SIZE;
+
+#if GDB_ARCH_HAS_WRCONS
+                    (void)snprintf ((char *)outBuf, size,
+                                  "PacketSize=%x;qXfer:features:read+;QStartNoAckMode+;WrCons+", GDB_BUF_SIZE);
+#else
+                    (void)snprintf ((char *)outBuf, size,
+                                  "PacketSize=%x;qXfer:features:read+;QStartNoAckMode+", GDB_BUF_SIZE);
+#endif
+                    size -= (strlen ((char *)outBuf) + 1);
+#ifdef        GDB_ARCH_HAS_VMCS
+                    strncat ((char *)outBuf, STR_QWR_VMCS, size);
+                    size -= sizeof (STR_QWR_VMCS);
+#endif
+#ifdef        GDB_ARCH_HAS_EXTENDED_REGISTERS
+                    strncat ((char *)outBuf, STR_QWR_EREGS, size);
+                    size -= sizeof (STR_QWR_EREGS);
+#endif
+#ifdef        GDB_ARCH_HAS_CPUID
+                    strncat ((char *)outBuf, STR_QWR_CPUID, size);
+                    size -= sizeof (STR_QWR_CPUID);
+#endif
+                    }
+                else if (strncmp ((const char *)ptr, "Xfer:features:read:", 19) == 0)
+                    {
+                    ptr += 19;
+                    if (strncmp ((const char *)ptr, "target.xml:", 11) == 0)
+                        {
+                        int offset;
+                        int length;
+
+                        ptr += 11;
+                        if (hex2int ((unsigned char ** )&ptr, &offset) &&
+                            *ptr++ == ',' &&
+                            hex2int (&ptr, &length) &&
+                            *ptr == '\0') 
+                            {
+                            write_xml_string ((char *) outBuf,
+                                                    get_xml_target_description(),
+                                                offset, length); 
+                                }
+                        else
+                            OUTBUF_FILL (STUB_ERROR);
+                        }
+                    }
+                break;
+                }
+
+
+            case 'g':                /* g -- Get Registers */
+                {
+#if 0
+                (void)gdbArchRegsGet (&stopModeRegs,
+                                      (char *)tmp_reg_buffer);
+#endif
+                mem2hex (tmp_reg_buffer, outBuf, GDBNUMREGBYTES, 1);
+                break;
+                }
+#if 0
+            case 'G':                /* GXX... -- Write Registers */
+                {
+                int i;
+                int value;
+
+                (void)gdbArchRegsGet (&stopModeRegs,
+                                      (char *)tmp_reg_buffer);
+                for(i = 0; i < GDBNUMREGBYTES; i++) {
+                    if((value = get_hex_byte(&ptr)) < 0) {
+                        break;
+                    }
+                    tmp_reg_buffer[i] = (unsigned char) value;
+                }
+                (void)gdbArchRegsSet (&stopModeRegs,
+                                      (char *)tmp_reg_buffer);
+                OUTBUF_FILL (STUB_OK);
+                break;
+                }
+            case 'P':                /* Pn..=r.. -- Write register */
+                {
+                int regNum = 0;
+                int        offset, size, i, value;
+
+                OUTBUF_FILL ("E02");
+                if (!hex2int (&ptr, &regNum) || *(ptr++) != '=')
+                    break;
+
+                (void)gdbArchRegsGet (&stopModeRegs,
+                                      (char *)tmp_reg_buffer);
+                if (gdbArchRegInfoGet (regNum, &size, &offset) == -1)
+                    {
+                    OUTBUF_FILL ("");
+                    break;
+                    }
+
+                for(i = 0; i < size; i++)
+                    {
+                    if((value = get_hex_byte(&ptr)) < 0)
+                        break;
+                    tmp_reg_buffer[offset+i] = (unsigned char)value;
+                    }
+                if (i != size)
+                    break;
+                (void)gdbArchRegsSet (&stopModeRegs,
+                                      (char *)tmp_reg_buffer);
+                OUTBUF_FILL (STUB_OK);
+                break;
+                }
+#endif
+
+            case 'p':
+                {
+                int regNum = 0;
+                int        offset, size;
+
+                /* p<regno> */
+                
+                if (!hex2int(&ptr, &regNum)) 
+                    {
+                    OUTBUF_FILL ("E02");
+                    break;
+                    }
+
+#if 1
+                size = 4;
+                offset = 0;
+#else
+                (void)gdbArchRegsGet (&stopModeRegs,
+                                            (char *)tmp_reg_buffer);
+                if (gdbArchRegInfoGet (regNum, &size, &offset) == -1)
+                    {
+                    OUTBUF_FILL ("");
+                    break;
+                    }
+#endif
+                mem2hex (tmp_reg_buffer + offset, outBuf, size, 1);
+                break;
+                }
+
+            case 'm':                                /* Read Memory */
+                {                               /* m<addr>,<length> */
+                long long addr;
+                int length;
+
+                OUTBUF_FILL ("E01");
+                if (hex2llong ((unsigned char ** )&ptr, &addr) == 0)
+                    break;                
+
+                if (! (*ptr++ == ',' && hex2int (&ptr, &length)))
+                    break;
+
+#if 0
+                if (gdb_mem_probe ((void *)((long)addr), length, 0) != length)
+                    break;  /* No read access */
+#endif
+
+                /* Now read memory */
+                mem2hex((unsigned char *)((long)addr), outBuf, length, 1);
+                break;
+                }
+            case 'M':                                /* Write Memory */
+                {
+                long long addr;
+                int length;
+                int value, i;
+                OUTBUF_FILL ("E02");
+
+                /* M<addr>,<length>:<val><val>...<val> */
+
+                if (hex2llong ((unsigned char ** )&ptr, &addr) == 0)
+                    break;
+
+                if (! (*ptr++ == ',' &&
+                       hex2int (&ptr, &length) &&
+                       *ptr++ == ':'))
+                    break;
+
+#if 0
+                if (gdb_mem_probe ((void *)((long)addr), length, 1) != length)
+                    break;  /* No write access */
+#endif
+                
+                /* Now write memory */
+                for(i = 0; i < length; i++)
+                    {
+                    if((value = get_hex_byte(&ptr)) < 0)
+                        break;
+                    ((unsigned char *)((long)addr))[i] = (unsigned char) value;
+                    }
+
+                OUTBUF_FILL (STUB_OK);
+                break;
+                }
+
+            case 'C':                                /* Pass the signal to context */
+                                                    /* and continue execution */
+                {
+                int signal;
+
+                /* read signal number */
+                if (!hex2int (&ptr, &signal))
+                    break;
+
+                gdb_cpu_pending_sig = signal;
+
+                if (*ptr == ';')
+                    ptr++;
+
+                /* fall through */
+                }
+
+            case 'c':                                /* Continue Execution */
+                {
+                long long addr;
+                /*
+                 * Try to read optional parameter, pc unchanged if
+                 * no param
+                 */
+
+                if (hex2llong ((unsigned char **)&ptr, &addr))
+                    {
+#ifdef RESUME_AT_SUPPORT
+                    save_pc = addr;
+
+                    /*Need to flush cache ?*/
+#endif
+                    }
+
+                VARIABLE_WRITE_SYNC (gdb_debug_status, NOT_DEBUGGING);
+                no_ack = 1;
+                break;
+                }
+            case 'S':                                /* Pass the signal to context */
+                                                    /* and step execution */
+                {
+                int signal;
+
+                /* read signal number */
+                if (!hex2int (&ptr, &signal))
+                    break;
+
+                gdb_cpu_pending_sig = signal;
+
+                if (*ptr == ';')
+                    ptr++;
+
+                /* fall through */
+                }
+            case 's':                                /* step Execution */
+                {
+                long long addr;
+                /*
+                 * Try to read optional parameter, pc unchanged if
+                 * no param
+                 */
+
+                if (hex2llong ((unsigned char **)&ptr, &addr))
+                    {
+#ifdef RESUME_AT_SUPPORT
+                    save_pc = addr;
+
+                    /*Need to flush cache ?*/
+#endif
+                    }
+
+		VARIABLE_WRITE_SYNC (gdb_debug_status, SINGLE_STEP);
+		no_ack = 1;
+		break;
+		}
+	    case 'v':
+		{
+		char action;
+		int signal = 0;
+
+		if (strcmp((const char *)ptr, "Cont?") == 0)
+		    {
+            OUTBUF_FILL ("vCont;c;s;C;S");
+		    break;
+		    }
+		else  if (strncmp((const char *)ptr, "Cont;", 5) != 0)
+		    break;
+		
+		ptr += 5;
+		action = *ptr++;
+		if ((action != 'c') && (action != 'C') &&
+		    (action != 's') && (action != 'S'))
+		    break;
+
+		if ((action == 'C') || (action == 'S'))
+		    {
+		    /* read signal number */
+		    if (!hex2int (&ptr, &signal))
+			break;
+		    }
+
+		if (*ptr == ':')
+		    {
+		    int thread;
+
+		    ptr++;
+		    hex2int (&ptr, &thread);
+		    }
+
+		if (signal != 0)
+		    gdb_cpu_pending_sig = signal;
+
+		if ((action == 'c') || (action == 'C'))
+		    VARIABLE_WRITE_SYNC (gdb_debug_status, NOT_DEBUGGING);
+		else
+		    VARIABLE_WRITE_SYNC (gdb_debug_status, SINGLE_STEP);
+		no_ack = 1;
+		break;
+		}
+
+	    case 'z':	/* ztype,addr,length */
+		{
+		int	type, length;
+		long long addr;
+		GDB_ERROR_CODE gdbErrCode;
+                OUTBUF_FILL ("E07");
+
+		/* get address which is required parameter */
+
+		if (hex2int (&ptr, &type) &&
+		    *ptr++ == ',' &&
+		    hex2llong ((unsigned char **)&ptr, &addr) &&
+		    *ptr++ == ',' &&
+		    hex2int (&ptr, &length))
+		    {
+                    if (gdb_bp_delete (type, (long) addr, length,
+                                     &gdbErrCode) == 0)
+                        OUTBUF_FILL ("OK");
+                    else
+                        {
+                        (void) snprintf ((char *)outBuf, GDB_BUF_SIZE, "E%02d",
+                                  gdbErrCode);
+                        }
+                    }
+		break;
+		}
+	    case 'Z':	/* Ztype,addr[:<vaddr1>[:...:<vaddrN>]],length */
+		{
+		    int	type, length;
+		    long long addr;
+		    GDB_ERROR_CODE gdbErrCode;
+
+            OUTBUF_FILL ("E07");
+
+            /* read <type> & <addr> */
+            if (! (hex2int (&ptr, &type) && *ptr++ == ',' &&
+                   hex2llong ((unsigned char **)&ptr, &addr)))
+                break;
+
+            if (! (*ptr++ == ',' && hex2int (&ptr, &length)))
+                break;
+
+            if (gdb_bp_add (type, (long) addr, length, &gdbErrCode) == 0)
+                {
+                OUTBUF_FILL (STUB_OK);
+                }
+            else
+                {
+                (void) snprintf ((char *)outBuf, GDB_BUF_SIZE, "E%02d",
+                              gdbErrCode);
+                }
+
+		    break;
+		}
+	    default:
+		/*
+		 * In case of an unsupported command, send an empty 
+		 * response.
+		 */
+
+		outBuf[0] = '\0';
+		break;
+	}
+
+	/* Send the acknowledgment command when necessary */
+
+	if (!no_ack)
+	    {
+	    if (putPacket (outBuf) < 0)
+		return -1;
+	    }
+
+    return 0;
+    }
+
+/*
+ * function: putDebugChar
+ * description:
+ *      - "What you must do for the stub"
+ *      - Write a single character from a port.
+ */
+static void putDebugChar(unsigned char ch) {
+    (void) uart_poll_out (UART_CONSOLE_DEV, ch);
+    return;
+}
+
+static int putDebugString (unsigned char *str, int len)
+{
+    int num = 0;
+
+    if (_func_gdbPacketPut != NULL)
+        {
+        return _func_gdbPacketPut (str, len);
+        }
+    else
+        {
+        if (len > 0 && (str != NULL))
+            {
+            for (num = 0; num < len; num ++)
+                putDebugChar (str[num]);
+            }
+        return num;
+        }
+}
+
+#if 0
+/*****************************************************************************
+*
+* gdbProtocolHook - Hook function to be called for each input character
+*
+* This routine is the protocol hook function to be called for each input
+* character on the serial line. The first argument passed is set by the
+* user via the FIOPROTOARG function.  The second argument is the input
+* character. If the input character is the GDB break character (CTRL+C by
+* default) then the system is stopped and the stop mode GDB server takes the
+* execution control.
+*
+* RETURNS: 1 if no further processing of the character is required (GDB
+* break
+* character detected) otherwise 0.
+*
+* ERRNO: N/A
+*
+*/
+
+BOOL gdbProtocolHook
+    (
+    char ch
+    )
+    {
+    if (ch == GDB_STOP_CHAR)
+        {
+        int lvl;
+
+        if (!gdb_is_connected)
+            vxdbgEnable (0, "Stop Mode Agent connected.");
+
+        lvl = intCpuLock();
+
+        (void)_func_gdbPollModeSet ();
+
+        /* A stop character has been received: Stop the system. */
+
+        gdb_system_stop ();
+
+        (void)_func_gdbIntModeSet ();
+
+        intCpuUnlock (lvl);
+
+        return 1;
+        }
+    return 0;
+    }
+#endif
+
+/*******************************************************************************
+*
+* gdb_bps_install - install breakpoints
+*
+* This routine physically install breakpoints, and make sure that modified
+* memory is flushed on all CPUs.
+* This routine must only be called on CPU0, and when all CPUs are ready to be
+* resumed (ready to exit the CPU control loop).
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+static void gdb_bps_install (void)
+    {
+    uint32_t ix;
+    GDB_INSTR bpInst = GDB_BREAK_INST;
+
+    /* Software breakpoints installation */
+
+    for (ix = 0; ix < MAX_SW_BP; ix++) {
+	    if (bpArray[ix].valid == 1 && !bpArray[ix].enabled) {
+	        GDB_INSTR * addr = bpArray[ix].addr;
+
+            bpArray[ix].insn = *addr;
+#if 0
+            VM_CONTEXT_BUFFER_WRITE (NULL, &bpInst, addr, sizeof(GDB_INSTR));
+            (void)CACHE_TEXT_LOCAL_UPDATE (addr, sizeof (GDB_INSTR));
+#else
+            *addr = bpInst;
+#endif
+            bpArray[ix].enabled = 1;
+	    } else if (bpArray[ix].valid == 0) {
+	        /* First non valid entry in the table is the last entry */
+
+	        break;
+	    }
+	}
+}
+
+
+/*******************************************************************************
+*
+* gdb_bps_uninstall - uninstall breakpoints
+*
+* This routine physically uninstall breakpoints, and make sure that modified
+* memory is flushed on all CPUs.
+* This routine must only be called on CPU0, and when all CPUs have been stopped
+* (entered the CPU control loop).
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+static void gdb_bps_uninstall (void) {
+    uint32_t ix;
+
+    for (ix = 0; ix < MAX_SW_BP; ix++) {
+	    if (bpArray[ix].valid == 1 && bpArray[ix].enabled) {
+	        GDB_INSTR * addr = bpArray[ix].addr;
+
+#if 0
+            VM_CONTEXT_BUFFER_WRITE (NULL, &bpArray[ix].insn, addr,
+                                     sizeof(GDB_INSTR));
+            (void)CACHE_TEXT_LOCAL_UPDATE (addr, sizeof (GDB_INSTR));
+#else
+            *addr = bpArray[ix].insn;
+            bpArray[ix].enabled = 0;
+#endif
+	    } else if (bpArray[ix].valid == 0) {
+	        /* First non valid entry in the table is the last entry */
+
+	        break;
+	    }
+	}
+}
+
+/*******************************************************************************
+*
+* gdb_cpu_resume - resume all CPUs
+*
+* This routine re-installs breakpoint and resumes all CPUs.
+*
+* RETURNS: always 1.
+*
+* ERRNO: N/A
+*
+*/
+
+static void gdb_cpu_resume (void)
+    {
+    /* CPUs must not be resumed if we're going to execute a single step */
+
+    if (gdb_debug_status == SINGLE_STEP)
+        return;
+
+    /* Re-install breakpoints */
+    gdb_bps_install ();
+    }
+
+#if 0
+#if DBG_NO_SINGLE_STEP || DBG_STEP_AND_BP_SHARED_VEC
+/*******************************************************************************
+*
+* gdbTrapHandler - trap handler for emulated single step
+*
+* This trap handler is used to catch and handle the exceptions generated by
+* emulated single step.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+LOCAL BOOL gdbTrapHandler
+    (
+    int         level,
+    GDB_INSTR *	pAddr,
+    void *      pInfo,
+    REG_SET *   pRegisters,
+    void *	pDbgRegSet,
+    BOOL	hardware
+    )
+    {
+    if (gdb_debug_status == SINGLE_STEP)
+	return (gdbTraceHandler (level, pInfo, pRegisters));
+    
+    return (gdbBpHandler (level, pInfo, pRegisters, pDbgRegSet, hardware));
+    }
+#endif	/* DBG_NO_SINGLE_STEP */
+
+/*******************************************************************************
+*
+* gdbTraceHandler - stop mode agent trace handler
+*
+* The Stop Mode Agent Breakpoint trace handler is used to catch and handle the
+* trace mode exceptions (single step).
+* This routine is invoked from VxDBG breakpoint exception handler with
+* interrupts locked.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+LOCAL BOOL gdbTraceHandler
+    (
+    int         level,          /* int lock level at trace exception time */
+    void *      pInfo,          /* pointer to arch specific exception info */
+    REG_SET *   pRegisters      /* ptr to register set of interrupted context */
+    )
+    {
+    return (gdbHandler (GDB_EXC_TRACE, level, pInfo, pRegisters, NULL, 0,
+                        GDB_SIG_TRAP));
+    }
+
+/*******************************************************************************
+*
+* gdbBpHandler - Stop Mode Agent Breakpoint handler
+*
+* The Stop Mode Agent Breakpoint handler is used to catch and handle the BP
+* exceptions.
+* This routine is invoked from VxDBG breakpoint exception handler with
+* interrupts locked.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+LOCAL BOOL gdbBpHandler
+    (
+    int         level,          /* interrupt lock level at BP exception time */
+    void *      pInfo,          /* pointer to arch specific exception info */
+    REG_SET *   pRegisters,     /* ptr to register set of interrupted context */
+    void *      pDbgRegSet,     /* ptr to debug register set */
+    BOOL        hardware        /* hardware breakpoint? */
+    )
+    {
+    int cpuId = _WRS_CPU_INDEX_GET();
+
+    VARIABLE_WRITE_SYNC (gdb_debug_status, DEBUGGING);
+    gdbCpuStopBpType = GDB_SOFT_BP;
+
+    return (gdbHandler (GDB_EXC_BP, level, pInfo, pRegisters, pDbgRegSet,
+                        hardware, GDB_SIG_TRAP));
+    }
+
+
+/******************************************************************************
+*
+* gdbExcHandle - exception hook handler
+*
+* This hook is called at exception time.
+*
+* RETURNS: 1 or 0
+*/
+
+BOOL gdbExcHandle
+    (
+    int				excType,	/* exception type */
+    void *			pInfo,		/* information on exception */
+    BOOL			systemSuspend	/* suspend system ? */
+    )
+    {
+    BOOL			ret;		/* return value */
+    EDR_INTERRUPT_INFO *	pIntInfo;	/* information on interrupt */
+    EDR_INIT_INFO *		pInitInfo;	/* information on init */
+    EDR_TASK_INFO *		pTaskInfo;	/* information on task */
+    EDR_RTP_INFO *		pRtpInfo;	/* information on RTP */
+    REG_SET *			pRegs;		/* register set */
+    EXC_INFO *			pExcInfo;	/* exception information */
+    int				sigNum = 0;	/* signal number */
+
+    /* Always return 0: stopped the context in Lab mode */
+    ret = 0;
+
+    /* No information means we are not in an exception
+     * or if we are not in debug mode (no client connected), do not the stop
+     * the context
+     */
+    if ((pInfo == NULL) || !gdb_is_connected)
+	return ret;
+
+    switch (excType)
+	{
+	case EDR_FACILITY_KERNEL:
+	    pTaskInfo = (EDR_TASK_INFO *) pInfo;
+
+	    /* check it is an exception */
+
+	    if (!pTaskInfo->isException)
+		return ret;
+
+	    pRegs	= pTaskInfo->pRegs;
+	    pExcInfo	= pTaskInfo->pExcInfo;
+	    sigNum	= pTaskInfo->signalNum;
+	    break;
+
+#ifdef _WRS_CONFIG_RTP
+	case EDR_FACILITY_RTP:
+	    pRtpInfo = (EDR_RTP_INFO *) pInfo;
+
+	    /* check it is an exception */
+
+	    if (!pRtpInfo->isException)
+		return ret;
+
+	    pRegs	= pRtpInfo->pRegs;
+	    pExcInfo	= pRtpInfo->pExcInfo;
+	    sigNum	= pRtpInfo->signalNum;
+	    break;
+#endif /* _WRS_CONFIG_RTP */
+
+	case EDR_FACILITY_INIT:
+	    pInitInfo = (EDR_INIT_INFO *) pInfo;
+
+	    /* check it is an exception */
+
+	    if (!pInitInfo->isException)
+		return ret;
+
+	    /* WRS_XXX - Pre-kernel Init not supported for now */
+
+	    return 0;
+	    break;
+
+	case EDR_FACILITY_INTERRUPT:
+	    pIntInfo = (EDR_INTERRUPT_INFO *) pInfo;
+
+	    /* check it is an exception */
+
+	    if (!pIntInfo->isException)
+		return ret;
+
+	    pRegs	= pIntInfo->pRegs;
+	    pExcInfo	= pIntInfo->pExcInfo;
+	    sigNum	= pIntInfo->signalNum;
+	    break;
+
+	default:
+	    return ret;
+	}
+
+    VARIABLE_WRITE_SYNC (gdb_debug_status, DEBUGGING);
+    (void) gdbHandler (GDB_EXC_OTHER, 0, pExcInfo, pRegs, NULL, 0, sigNum);
+
+    return ret;
+    }
+
+/*******************************************************************************
+*
+* gdbHandler - stop mode agent BP/trace handler
+* 
+* This handler is a common handler of breakpoint and trace mode exceptions.
+* This handler is invoked with interrupts locked.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+LOCAL BOOL gdbHandler
+    (
+    EXC_MODE    mode,   	/* exception mode */
+    int         level,          /* int lock level at trace exception time */
+    void *      pInfo,          /* pointer to arch specific exception info */
+    REG_SET *   pRegisters,     /* ptr to register set of interrupted context */
+    void *      pDbgRegSet,     /* ptr to debug register set */
+    BOOL        hardware,       /* hardware breakpoint? */
+    int		signal		/* signal number */
+    )
+    {
+    int cpuId = _WRS_CPU_INDEX_GET();
+
+#if DBG_NO_SINGLE_STEP
+    VM_CONTEXT_ID curVmCtx;
+#endif
+
+    /* Save BP/Trace handler registers */
+
+    stopModeRegs.vxRegs = *pRegisters;
+
+#ifdef GDB_HAS_CPU_EXTRA_REGS_SUPPORT
+    /* Save extra registers required by stop mode server */
+    (void) gdbArchCpuExtraRegsGet (cpuId, &stopModeRegs.extraRegs,
+                                   pInfo);
+#endif
+
+    if (mode == GDB_EXC_TRACE)
+        {
+        /* Check if GDB did request a step */
+        if (gdb_debug_status != SINGLE_STEP)
+            return (0);
+
+        /* No longer pending trace mode exception */
+        VARIABLE_WRITE_SYNC (gdb_debug_status, DEBUGGING);
+
+#if DBG_NO_SINGLE_STEP
+        /* remove temporary breakpoint */
+        
+        curVmCtx = vmCurrentGet ();
+        (void)vmCurrentSet (stoppedVmCtx[cpuId]);
+
+        VM_CONTEXT_BUFFER_WRITE (stoppedVmCtx[cpuId], &gdbStepEmuInsn,
+                                 gdbStepEmuNextPc, sizeof (GDB_INSTR));
+        (void)CACHE_TEXT_LOCAL_UPDATE (gdbStepEmuNextPc, sizeof (GDB_INSTR));
+        (void)vmCurrentSet (curVmCtx);
+
+        /* Disable trace mode */
+        intRegsUnlock (&stopModeRegs.vxRegs, gdb_trace_lock_key);
+#else
+        /* Disable trace mode */
+        wdbDbgTraceModeClear (&stopModeRegs.vxRegs, gdb_trace_lock_key);
+#endif /* DBG_NO_SINGLE_STEP */
+        }
+
+    if ((mode == GDB_EXC_TRACE) || (mode == GDB_EXC_BP))
+	cpuStopByBp = 1;
+
+#if DBG_NO_SINGLE_STEP
+    stoppedVmCtx[cpuId] = vmCurrentGet();
+#endif /* DBG_NO_SINGLE_STEP */
+
+    VARIABLE_WRITE_SYNC (gdb_event_is_pending, 1);
+
+    gdb_cpu_stop_signal = signal;
+
+    /* Enter stop mode agent control loop */
+    _func_gdbPollModeSet ();
+    gdb_ctrl_loop ();
+    _func_gdbIntModeSet ();
+
+    /* Restore BP handler registers */
+    *pRegisters = stopModeRegs.vxRegs;
+
+    if ((mode == GDB_EXC_TRACE) || (mode == GDB_EXC_BP))
+	cpuStopByBp = 0;
+
+    /* Resume CPUs if not handing a single step */
+    gdb_cpu_resume ();
+
+    return (1);
+    }
+#endif
+
+/*******************************************************************************
+*
+* gdb_ctrl_loop - GDB control loop
+*
+* The CPU control loop is an active wait loop used to stop CPU activity on
+* all CPUs. This routine must be called with interrupts locked.
+* This routine loops while waiting for debug events which can be:
+*
+* - System resumed: gdb_debug_status != NOT_DEBUGGING
+*	The control loop must be exited.
+*
+* - Single step request for current CPU: gdb_debug_status == SINGLE_STEP
+*	Notify client that CPU is already stopped.
+*	This is done by setting gdb_event_is_pending = 1.
+*	gdb_event_is_pending will be handled by next gdb_protocol_get_packet() on CPU 0.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+static void gdb_ctrl_loop (void)
+    {
+    char ch;
+
+    /* uninstall breakpoints. */
+    gdb_bps_uninstall ();
+
+    /* Flush input buffer */
+    while (uart_poll_in (UART_CONSOLE_DEV, &ch) == 0);
+    while (gdb_debug_status != NOT_DEBUGGING) {
+        unsigned char * ptr;
+
+        ptr = gdb_protocol_get_packet (inBuf, GDB_BUF_SIZE);
+        if (ptr != NULL)
+            gdb_protocol_parse (ptr);
+
+	    if (gdb_debug_status == SINGLE_STEP) {
+#if DBG_NO_SINGLE_STEP
+            GDB_INSTR dbgBreakInsn = DBG_BREAK_INST;
+
+            gdbStepEmuNextPc = wdbDbgGetNpc(&stopModeRegs.vxRegs);
+            gdbStepEmuInsn = *gdbStepEmuNextPc;
+            VM_CONTEXT_BUFFER_WRITE (stoppedVmCtx[cpuId], &dbgBreakInsn,
+                                     gdbStepEmuNextPc, sizeof (GDB_INSTR));
+            (void)CACHE_TEXT_LOCAL_UPDATE (gdbStepEmuNextPc, sizeof (GDB_INSTR));
+            gdb_trace_lock_key = intRegsLock (&stopModeRegs.vxRegs);
+#else 
+		    /* Handle single step request for for runcontrol CPU */
+
+#if 0
+		    gdb_trace_lock_key = wdbDbgTraceModeSet (
+                                        &stopModeRegs.vxRegs);
+#endif
+#endif /* DBG_NO_SINGLE_STEP */
+		return;
+		}
+	}
+}
+
+/*******************************************************************************
+*
+* gdb_system_stop - handle a system stop request
+*
+* The purpose of this routine is to handle a stop request issued by remote
+* debug client. It is called when receiving a break char.
+*
+* This routine stops all enabled CPUs. It indicates that a GDB event is pending
+* (the answer to stop request) and transfer control from the runtime system to
+* the stop mode agent. The event will be posted by this control loop.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+void gdb_system_stop (void)
+    {
+    int oldlevel = irq_lock();
+
+    VARIABLE_WRITE_SYNC (gdb_debug_status, DEBUGGING);
+    gdb_cpu_stop_signal = GDB_SIG_INT; /* Stopped by a command */
+
+    /* A GDB event is pending */
+    VARIABLE_WRITE_SYNC (gdb_event_is_pending, 1);
+
+    /* Transfer control to the control loop */
+    gdb_ctrl_loop ();
+
+    /* Resume CPU if not a single step request */
+    gdb_cpu_resume ();
+
+    irq_unlock(oldlevel);
+    }
+
+
+void gdb_protocol_hook (void) {
+    unsigned char ch = 0;
+
+    if (uart_poll_in (UART_CONSOLE_DEV, &ch) == 0) {
+        if (ch == GDB_STOP_CHAR) {
+	    gdb_server_init ();
+	    gdb_system_stop ();
+        }
+    }
+}
-- 
1.9.1


From e309d539973f448a20c7e9e56eb486206acccd3f Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Tue, 12 Jan 2016 16:08:59 -0500
Subject: [PATCH 08/82] gdb: hook GDB server into build system

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/Kconfig b/misc/debug/Kconfig
index 51a3d3f..f70ec32 100644
--- a/misc/debug/Kconfig
+++ b/misc/debug/Kconfig
@@ -62,3 +62,22 @@ config MEM_SAFE_NUM_EXTRA_REGIONS
 	image's boundaries.
 
 endmenu
+
+#
+# GDB Server options
+#
+
+config	GDB_SERVER
+	bool
+	prompt "GDB Server [EXPERIMENTAL]"
+	default n
+	help
+	This option enables the GDB Server support.
+
+config GDB_SERVER_MAX_SW_BP
+	int
+	prompt "Maximum number of GDB server software breakpoints"
+	default 100
+	depends on GDB_SERVER
+	help
+	This option specifies the maximum number of software breakpoints
diff --git a/misc/debug/Makefile b/misc/debug/Makefile
index 5bfc4a9..f6b8c73 100644
--- a/misc/debug/Makefile
+++ b/misc/debug/Makefile
@@ -1,2 +1,5 @@
+ccflags-y +=-I$(srctree)/include/misc/debug
+
 obj-y =
 obj-$(CONFIG_MEM_SAFE_CHECK_BOUNDARIES) += mem_safe_check_boundaries.o
+obj-$(CONFIG_GDB_SERVER) += gdb_server.o
-- 
1.9.1


From 17fde294e93ab0c3596262aa010a7954b164b2ae Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 21 Sep 2015 17:59:09 -0400
Subject: [PATCH 09/82] gdb: add gdb_instruction_set()

For inserting breakpoints.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index ba31a56..5f3a440 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -357,6 +357,8 @@ Notification Packets:
 #include <uart.h>
 #include <gdb_server.h>
 #include <debug/gdb_arch.h>
+#include <misc/debug/mem_safe.h>
+#include <cache.h>
 
 extern int    (*_func_gdbPacketPut) (unsigned char * str, int len);
 
@@ -2345,3 +2347,12 @@ void gdb_protocol_hook (void) {
         }
     }
 }
+
+int gdb_instruction_set(void *addr, char *instruction, size_t size)
+{
+	if (sys_mem_safe_write_to_text_section(addr, instruction, size) < 0) {
+		return -EFAULT;
+	}
+	sys_cache_flush((vaddr_t)addr, size);
+	return 0;
+}
-- 
1.9.1


From 7f1a3adeefa83c3d90de888eae7fe46d66eba938 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Wed, 13 Jan 2016 14:26:02 -0500
Subject: [PATCH 10/82] gdb: add CONSOLE_HANDLER to nano sample

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/samples/nanokernel/apps/gdb_server/prj.conf b/samples/nanokernel/apps/gdb_server/prj.conf
index 4e7a4c9..06a58bb 100644
--- a/samples/nanokernel/apps/gdb_server/prj.conf
+++ b/samples/nanokernel/apps/gdb_server/prj.conf
@@ -2,3 +2,4 @@
 CONFIG_ENHANCED_SECURITY=n
 CONFIG_GDB_SERVER=y
 CONFIG_COMPILER_OPT="-O0 -g"
+CONFIG_CONSOLE_HANDLER=y
-- 
1.9.1


From 9ccfaffee6dcf71d3413f61225eec8e09452b4b8 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Wed, 13 Jan 2016 14:26:55 -0500
Subject: [PATCH 11/82] gdb: replace STDOUT_CONSOLE by CONSOLE_HANDLER in micro
 sample

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/samples/microkernel/apps/gdb_server/prj_x86.conf b/samples/microkernel/apps/gdb_server/prj_x86.conf
index 531a9b7..06a58bb 100644
--- a/samples/microkernel/apps/gdb_server/prj_x86.conf
+++ b/samples/microkernel/apps/gdb_server/prj_x86.conf
@@ -1,5 +1,5 @@
 # Use standard security profile. (=> no need for a random number generator)
 CONFIG_ENHANCED_SECURITY=n
-CONFIG_STDOUT_CONSOLE=y
 CONFIG_GDB_SERVER=y
 CONFIG_COMPILER_OPT="-O0 -g"
+CONFIG_CONSOLE_HANDLER=y
-- 
1.9.1


From 8d84e4bdfa454c19df089dad2b90988c11c4d6dc Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Wed, 13 Jan 2016 14:30:51 -0500
Subject: [PATCH 12/82] gdb: use server_init instead of protocol_hook in micro
 sample

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/samples/microkernel/apps/gdb_server/src/gdb_start.c b/samples/microkernel/apps/gdb_server/src/gdb_start.c
index 2a8f53a..7e14866 100644
--- a/samples/microkernel/apps/gdb_server/src/gdb_start.c
+++ b/samples/microkernel/apps/gdb_server/src/gdb_start.c
@@ -50,8 +50,9 @@
 
 void gdbStart(void)
 {
+	gdb_server_init ();
+
 	while (1) {
-        gdb_protocol_hook ();
 		/* wait a while, then let other task have a turn */
 		task_sleep(SLEEPTICKS);
 	}
@@ -77,11 +78,10 @@ void main(void)
 	struct nano_timer timer;
     uint32_t data[2] = {0, 0};
 
+	gdb_server_init ();
     nano_timer_init(&timer, data);
 
 	while (1) {
-		gdb_protocol_hook ();
-
 		nano_task_timer_start(&timer, SLEEPTICKS);
 		nano_task_timer_wait(&timer);
 	}
-- 
1.9.1


From 342eb5c79b14babad177e6ea6158b8ee0813b197 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Wed, 13 Jan 2016 14:46:42 -0500
Subject: [PATCH 13/82] gdb/x86: call system_stop() in _NanoFatalErrorHandler()

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/core/fatal.c b/arch/x86/core/fatal.c
index 0fad05f..e16df02 100644
--- a/arch/x86/core/fatal.c
+++ b/arch/x86/core/fatal.c
@@ -30,6 +30,10 @@
 #include <asmPrv.h>
 #include <drivers/loapic.h>
 
+#ifdef CONFIG_GDB_SERVER
+#include <debug/gdb_server.h>
+#endif
+
 /*
  * Define a default ESF for use with _NanoFatalErrorHandler() in the event
  * the caller does not have a NANO_ESF to pass
@@ -69,6 +73,10 @@ FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
 					  const NANO_ESF *pEsf)
 {
 
+#ifdef CONFIG_GDB_SERVER
+	gdb_system_stop_here((void *) pEsf);
+#endif
+
 #ifdef CONFIG_PRINTK
 
 	/* Display diagnostic information about the error */
-- 
1.9.1


From 292d4be460c23a06e82005c911394950d0c9420f Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Wed, 13 Jan 2016 14:56:56 -0500
Subject: [PATCH 14/82] gdb/x86: add interrupt on first packet support

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/Kbuild b/arch/x86/Kbuild
index f838d67..d1e0d38 100644
--- a/arch/x86/Kbuild
+++ b/arch/x86/Kbuild
@@ -1,2 +1,4 @@
 obj-y += core/
 obj-y += soc/$(SOC_NAME)/
+
+obj-$(CONFIG_GDB_SERVER) += debug/
diff --git a/arch/x86/debug/Makefile b/arch/x86/debug/Makefile
new file mode 100644
index 0000000..ce30c44
--- /dev/null
+++ b/arch/x86/debug/Makefile
@@ -0,0 +1,3 @@
+ccflags-y += -I$(srctree)/kernel/nanokernel/include
+
+obj-$(CONFIG_GDB_SERVER) = gdb_arch.o
diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
new file mode 100644
index 0000000..0679ad7
--- /dev/null
+++ b/arch/x86/debug/gdb_arch.c
@@ -0,0 +1,283 @@
+/* gdb_arch.c - architecture dependent routine for the GDB server */
+
+/*
+ * Copyright (c) 2015 Wind River Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1) Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2) Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3) Neither the name of Wind River Systems nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* includes */
+
+#include <nanokernel.h>
+#include <nano_private.h>
+#include <debug/gdb_arch.h>
+#include <debug/gdb_server.h>
+
+/* defines */
+
+#define TRACE_FLAG          (0x0100)  /* TF in EFLAGS */
+#define INT_FLAG            (0x0200)  /* IF in EFLAGS */
+
+/* statics */
+
+static NANO_CPU_EXC_STUB_DECL(nano_bp_exc_stub);
+static NANO_CPU_EXC_STUB_DECL(nano_trace_exc_stub);
+static NANO_CPU_EXC_STUB_DECL(nano_fpe_stub);
+
+/* forward declarations */
+
+static void gdb_bp_handler (NANO_ESF * pEsf);
+static void gdb_trace_handler (NANO_ESF * esf);
+static void gdb_fpe_handle (NANO_ESF * esf);
+
+/**
+ *
+ * @brief Initialize GDB server architecture part
+ *
+ * This routine initializes the architecture part of the GDB server. It mostly
+ * register exception handler.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+void gdb_arch_init (void) {
+    nanoCpuExcConnect (IV_DIVIDE_ERROR, gdb_fpe_handle, nano_fpe_stub);
+    nanoCpuExcConnect (IV_DEBUG, gdb_trace_handler, nano_trace_exc_stub);
+    nanoCpuExcConnect (IV_BREAKPOINT, gdb_bp_handler, nano_bp_exc_stub);
+}
+
+/**
+ *
+ * @brief Fill given buffer from given register set
+ *
+ * This routine fills the provided buffer with values from given register set.
+ * The provided buffer must be large enough to store all register values.
+ * It is up to the caller to do this check.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+void gdb_arch_regs_get (GDB_REG_SET * regs, char * buffer) {
+    *((uint32_t *)buffer) = regs->regs.eax;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->regs.ecx;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->regs.edx;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->regs.ebx;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->regs.esp;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->regs.ebp;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->regs.esi;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->regs.edi;
+    buffer += 4;
+    *((uint32_t *)buffer) = (uint32_t) regs->regs.eip;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->regs.eflags;
+#ifdef GDB_HAS_CPU_EXTRA_REGS_SUPPORT
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->extra_regs.cs;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->extra_regs.ss;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->extra_regs.ds;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->extra_regs.es;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->extra_regs.fs;
+    buffer += 4;
+    *((uint32_t *)buffer) = regs->extra_regs.gs;
+#endif
+}
+
+/**
+ *
+ * @brief Write given registers buffer to GDB register set
+ *
+ * This routine fills given register set with value from provided buffer.
+ * The provided buffer must be large enough to contain all register values.
+ * It is up to the caller to do this check.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+void gdb_arch_regs_set (GDB_REG_SET * regs,  char * buffer) {
+    regs->regs.eax = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->regs.ecx = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->regs.edx = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->regs.ebx = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->regs.esp = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->regs.ebp = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->regs.esi = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->regs.edi = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->regs.eip = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->regs.eflags = *((uint32_t *)buffer);
+#ifdef GDB_HAS_CPU_EXTRA_REGS_SUPPORT
+    buffer += 4;
+    regs->extra_regs.cs = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->extra_regs.ss = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->extra_regs.ds = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->extra_regs.es = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->extra_regs.fs = *((uint32_t *)buffer);
+    buffer += 4;
+    regs->extra_regs.gs = *((uint32_t *)buffer);
+#endif
+}
+
+/**
+ *
+ * @brief Get size and offset of given register
+ *
+ * This routine returns size and offset of given register.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+void gdb_arch_reg_info_get (int reg_id, int * size, int * offset) {
+    /* Determine register size */
+    if (reg_id >= 0 && reg_id < 16)
+        *size = 4;
+
+    /* Determine register offset */
+    if (reg_id >= 0 && reg_id < 16)
+        *offset = 4 * reg_id;
+}
+
+/**
+ *
+ * @brief Clear trace mode
+ *
+ * This routine makes CPU trace-disable.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+void gdb_trace_mode_clear (NANO_ESF * regs, int arg) {
+    regs->eflags &= ~INT_FLAG;
+    regs->eflags |= (arg & INT_FLAG);
+    regs->eflags &= ~TRACE_FLAG;
+}
+
+/**
+ *
+ * @brief Set trace mode
+ *
+ * This routine makes CPU trace-enable.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+int gdb_trace_mode_set (NANO_ESF * regs) {
+    int tmp;
+
+    tmp = regs->eflags;
+    regs->eflags &= ~INT_FLAG;
+    regs->eflags |= TRACE_FLAG;
+
+    return (tmp);
+}
+
+/**
+ *
+ * @brief GDB trace handler
+ *
+ * The GDB trace handler is used to catch and handle the trace mode exceptions
+ * (single step).
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+static void gdb_trace_handler (NANO_ESF * esf) {
+    (void)irq_lock();
+    gdb_handler (GDB_EXC_TRACE, esf, GDB_SIG_TRAP);
+    }
+
+/**
+ *
+ * @brief GDB breakpoint handler
+ *
+ * The GDB breakpoint handler is used to catch and handle the breakpoint
+ * exceptions.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+static void gdb_bp_handler (NANO_ESF * esf) {
+    (void)irq_lock();
+    gdb_debug_status = DEBUGGING;
+    esf->eip -= sizeof(GDB_INSTR);
+    gdb_handler (GDB_EXC_BP, esf, GDB_SIG_TRAP);
+}
+
+/**
+ *
+ * @brief GDB Floating point handler
+ *
+ * This GDB handler is used to catch and handle the floating point exceptions.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+static void gdb_fpe_handle (NANO_ESF * esf) {
+    (void)irq_lock();
+    gdb_debug_status = DEBUGGING;
+    gdb_handler (GDB_EXC_OTHER, esf, 8);
+    }
diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
index 99b0dee..caf935d 100644
--- a/arch/x86/include/debug/gdb_arch.h
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -37,6 +37,8 @@
 extern "C" {
 #endif /* __cplusplus */
 
+#include <nano_private.h>
+
 /* define */
 
 #define GDB_TGT_ARCH    "i386"
@@ -53,9 +55,23 @@ extern "C" {
 
 typedef unsigned char GDB_INSTR;
 
+
+typedef struct
+    {
+    NANO_ESF regs;
+#ifdef GDB_HAS_CPU_EXTRA_REGS_SUPPORT
+    GDB_EXTRA_REG_SET extra_regs;
+#endif
+    } GDB_REG_SET;
+
 /* function declaration */
 
-extern void gdb_system_stop (void);
+extern void gdb_arch_init (void);
+extern void gdb_arch_regs_get (GDB_REG_SET * regs, char * buffer) ;
+extern void gdb_arch_regs_set (GDB_REG_SET * regs,  char * buffer);
+extern void gdb_arch_reg_info_get (int reg_id, int * size, int * offset);
+extern void gdb_trace_mode_clear (NANO_ESF * regs, int arg);
+extern int gdb_trace_mode_set (NANO_ESF * regs);
 
 #endif /* _ASMLANGUAGE */
 
-- 
1.9.1


From 26d9fd99cfbd3e63999e594df187899444563dbc Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Wed, 13 Jan 2016 16:55:25 -0500
Subject: [PATCH 15/82] gdb: add more features

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/include/misc/debug/gdb_server.h b/include/misc/debug/gdb_server.h
index cd0aaf1..614ab98 100644
--- a/include/misc/debug/gdb_server.h
+++ b/include/misc/debug/gdb_server.h
@@ -41,13 +41,39 @@ extern "C" {
 
 #define GDB_STOP_CHAR   0x3             /* GDB RSP default value */
 
+#define NOT_DEBUGGING   0
+#define DEBUGGING       1
+#define STOP_RUNNING    2
+#define SINGLE_STEP     3
+
 #ifndef _ASMLANGUAGE
 
 /* typedef */
 
+typedef enum gdb_exception_mode
+     {
+     GDB_EXC_TRACE,              /* trace exception */
+     GDB_EXC_BP,                 /* breakpoint exception */
+     GDB_EXC_OTHER,              /* other exceptions */
+     } EXC_MODE;
+
+enum gdb_signal
+    {
+    GDB_SIG_NULL = -1,
+    GDB_SIG_INT = 2,
+    GDB_SIG_TRAP = 5,
+    GDB_SIG_STOP = 17
+    };
+
+/* externs */
+
+extern volatile int gdb_debug_status;
+
 /* function declaration */
 
 extern void gdb_protocol_hook (void);
+extern void gdb_handler (int mode, void * pEsf, int signal);
+
 
 #endif /* _ASMLANGUAGE */
 
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 5f3a440..415e54c 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -123,6 +123,12 @@ The following is a list of all currently defined GDB RSP commands.
     The optional argument addr normally associated with the `c', `C', `s',
     and `S' packets is not supported in `vCont'.
 
+`X addr,length:XX...'
+    Write length bytes of memory starting at address addr, where the data is transmitted
+    in binary. The binary data representation uses 7d (ascii ‘}’) as an escape character.
+    Any escaped byte is transmitted as the escape character followed by the original
+    character XORed with 0x20.
+
 `z type,addr,length'
 `Z type,addr,length'
     Insert (`Z') or remove (`z') a type breakpoint starting at addr address of
@@ -357,51 +363,34 @@ Notification Packets:
 #include <uart.h>
 #include <gdb_server.h>
 #include <debug/gdb_arch.h>
+#include <nano_private.h>
 #include <misc/debug/mem_safe.h>
 #include <cache.h>
 
-extern int    (*_func_gdbPacketPut) (unsigned char * str, int len);
-
 /* defines */
 
 #define STUB_OK "OK"
 #define STUB_ERROR "ENN"
 
-#define NOT_DEBUGGING   0
-#define DEBUGGING       1
-#define STOP_RUNNING    2
-#define SINGLE_STEP     3
-
 #define GDB_BUF_SIZE    600      /* Default GDB buffer size */
 
 #define MAX_SW_BP       CONFIG_GDB_SERVER_MAX_SW_BP     /* Maximum number of software breakpoints */
 
-
-#define VARIABLE_WRITE_SYNC(var,value)  var=value
-#define MEM_WRITE_SYNC(ptr,size)
 #define OUTBUF_FILL(x) strncpy ((char *)outBuf, x, GDB_BUF_SIZE - 1)
 
 #define STR_COMMA_SEPARATOR     ","
-#ifdef        GDB_ARCH_HAS_VMCS
+#ifdef GDB_ARCH_HAS_VMCS
 #define STR_QWR_VMCS    ";qwr.vmcs+;Qwr.vmcs+"
 #endif
-#ifdef        GDB_ARCH_HAS_EXTENDED_REGISTERS
+#ifdef GDB_ARCH_HAS_EXTENDED_REGISTERS
 #define STR_QWR_EREGS   ";qwr.eregs+"
 #endif
-#ifdef        GDB_ARCH_HAS_CPUID
+#ifdef GDB_ARCH_HAS_CPUID
 #define STR_QWR_CPUID   ";qwr.cpuid+"
 #endif
 
 /* typedef */
  
-enum gdb_signal
-    {
-    GDB_SIG_NULL = -1,
-    GDB_SIG_INT = 2,
-    GDB_SIG_TRAP = 5,
-    GDB_SIG_STOP = 17
-    };
-
 typedef enum gdb_bp_type
     {
     GDB_SOFT_BP,                /* software breakpoint */
@@ -429,15 +418,6 @@ typedef struct
     char enabled;		/* breakpoint is enabled? */
     } BP_ARRAY;
 
-#if 0
-typedef enum gdb_exception_mode
-    {
-    GDB_EXC_TRACE,		/* trace exception */
-    GDB_EXC_BP,			/* breakpoint exception */
-    GDB_EXC_OTHER,		/* other exceptions */
-    } EXC_MODE;
-#endif
-
 /* local definitions */
 
 static const unsigned char hexchars[] = {
@@ -447,14 +427,12 @@ static const unsigned char hexchars[] = {
 
 static int gdb_is_connected = 0;	/* A client is connected to GDB Server */
 static int gdb_no_ack = 0;
-static volatile int gdb_debug_status = NOT_DEBUGGING;
+static int gdb_stop_by_bp = 0;
+static int gdb_trace_lock_key = 0;
 static volatile int gdb_event_is_pending = 0;
 static volatile int gdb_cpu_stop_signal;
 static volatile int gdb_cpu_pending_sig;
-#if 0
-static int gdb_trace_lock_key = 0;
-static volatile int    gdbCpuStopBpType;  /* BP type */
-#endif
+static GDB_REG_SET gdb_regs;
 
 static const char * xml_target_header = "<?xml version=\"1.0\"?> " \
                             "<!DOCTYPE target SYSTEM " \
@@ -472,25 +450,14 @@ static unsigned char tmp_reg_buffer [GDBNUMREGBYTES];
  */
 static BP_ARRAY bpArray[MAX_SW_BP];
 
-#if 0
-static int cpuStopByBp;
-
-LOCAL REG_SET           stopModeAgentRegs;
-LOCAL void *            pStopModeStackBase;
-LOCAL int               stopLockLevel = 0;
-
 #if	DBG_NO_SINGLE_STEP
-LOCAL GDB_INSTR *           gdbStepEmuNextPc;
-LOCAL GDB_INSTR             gdbStepEmuInsn;
-LOCAL VM_CONTEXT_ID     stoppedVmCtx[VX_MAX_SMP_CPUS];
+LOCAL GDB_INSTR * gdbStepEmuNextPc;
+LOCAL GDB_INSTR gdbStepEmuInsn;
 #endif /* DBG_NO_SINGLE_STEP */
-#endif
 
 /* global definitions */
 
-#if 0
-GDB_CPU_REG_SET stopModeRegs;
-#endif
+volatile int gdb_debug_status = NOT_DEBUGGING;
 
 /* forward static declarations */
 static int putPacket(unsigned char * buffer);
@@ -498,30 +465,18 @@ static int putDebugString (unsigned char *str, int len);
 static void putDebugChar(unsigned char ch);
 static int getDebugChar (void);
 
+static int gdb_instruction_set(void *addr, char *instruction, size_t size);
+
 static void gdb_post_event (void);
 static void gdb_ctrl_loop (void);
 static void gdb_cpu_resume (void);
 
-#if 0
-
 #if	DBG_NO_SINGLE_STEP || DBG_STEP_AND_BP_SHARED_VEC
-LOCAL BOOL gdbTrapHandler (int level, GDB_INSTR * pAddr, void * pInfo,
+static void gdb_trap_handler (int level, GDB_INSTR * pAddr, void * pInfo,
 			   REG_SET * pRegisters, void *	pDbgRegSet,
 			   BOOL hardware);
 #endif	/* DBG_NO_SINGLE_STEP */
 
-LOCAL BOOL gdbHandler   (EXC_MODE mode, int level, void * pInfo,
-                         REG_SET * pRegisters, void * pDbgRegSet,
-                         BOOL hardware, int signal);
-LOCAL BOOL gdbBpHandler (int level, void * pInfo,
-                          REG_SET * pRegisters, void * pDbgRegSet,
-                          BOOL hardware);
-LOCAL BOOL gdbTraceHandler (int level, void * pInfo, REG_SET * pRegisters);
-#endif
-
-int (*_func_gdbPacketPut) (unsigned char * pBuf, int len) = (void *)0;
-void (*_func_gdbDisconnect) (void) = (void *) 0;
-
 static int hex(unsigned char ch)
 {
         if ((ch >= 'a') && (ch <= 'f')) {
@@ -710,6 +665,74 @@ static unsigned char * mem2hex
     return (buf);
     }
 
+/*******************************************************************************
+*
+* gdb_mem_probe -
+*
+* This routine probe
+*
+* RETURNS: 0 if memory is accessible, -1 otherwise.
+*
+* ERRNO: N/A
+*
+*/
+
+static int gdb_mem_probe
+    (
+    char *	addr,		/* address to test */
+    int		mode,		/* VX_READ or VX_WRITE */
+    int		size,		/* number of bytes to test */
+    int		width,
+    int	    preserve	/* preserve memory on write test? */
+    )
+    {
+    long	dummy;		/* dummy variable */
+
+    if (size == 0)		/* memory length is null, test is done */
+	return (0);
+
+    /* Validate parameters */
+
+    if (mode == SYS_MEM_SAFE_READ)
+	preserve = 0;
+
+    if (width == 0)
+	width = 1;
+
+    /* Check width parameter */
+
+    if ((width != 1) && (width != 2) && (width != 4))
+	return (-1);
+
+    /* Check addr, size & width parameters coherency */
+
+    if (((unsigned long) addr % width) || (size % width))
+	return (-1);
+
+    /* Check first address */
+
+    if ((preserve && (sys_mem_probe (addr, SYS_MEM_SAFE_READ, width,
+    		      (char *)&dummy) != 0)) ||
+	(sys_mem_probe (addr, mode, width, (char *)&dummy) != 0))
+	return (-1);
+
+    /* Check if we have tested the whole memory */
+
+    if (width == size)
+	return (0);
+
+    /* Check last address */
+
+    addr = addr + size - width;
+    if ((preserve &&
+	(sys_mem_probe (addr, SYS_MEM_SAFE_READ, width, (char *)&dummy) != 0)) ||
+	(sys_mem_probe (addr, mode, width, (char *)&dummy) != 0)) {
+        return (-1);
+    }
+
+    return (0);
+}
+
 static int putPacket(unsigned char * buffer)
     {
     unsigned char checksum = 0;
@@ -756,7 +779,7 @@ static int putPacket(unsigned char * buffer)
             if (ch == GDB_STOP_CHAR)
                 {
                 gdb_cpu_stop_signal = GDB_SIG_INT;
-                VARIABLE_WRITE_SYNC (gdb_debug_status, DEBUGGING);
+                gdb_debug_status = DEBUGGING;
                 gdb_post_event ();
                 return 0;
                 }
@@ -770,6 +793,7 @@ void gdb_server_init (void) {
 	static int gdb_is_initialized = 0;
 
     if (!gdb_is_initialized) {
+	gdb_arch_init();
         gdb_is_initialized = 1;
     }
 }
@@ -779,7 +803,7 @@ void gdb_post_event (void)
     {
     int async_stop = 0;
 
-    VARIABLE_WRITE_SYNC (gdb_event_is_pending, 0);
+    gdb_event_is_pending = 0;
     if (gdb_cpu_stop_signal != GDB_SIG_NULL)
         {
         async_stop = 1;
@@ -790,8 +814,8 @@ void gdb_post_event (void)
         size_t bufSize = GDB_BUF_SIZE;
         if (gdb_cpu_stop_signal != GDB_SIG_NULL)
             {
-            int offset;
-            int size;
+            int offset = 0;
+            int size = 4;
             int count;
             unsigned char * savedPtr;
             if (ptr != outBuf)
@@ -806,14 +830,8 @@ void gdb_post_event (void)
             count = snprintf ((char *)ptr, bufSize, ";%x:", GDB_PC_REG);
             ptr += count;
             bufSize -= count;
-#if 0
-            (void)gdbArchRegsGet (&stopModeRegs,
-                                      (char *)tmp_reg_buffer);
-            (void)gdbArchRegInfoGet (GDB_PC_REG, &size, &offset);
-#else
-            size = 4;
-            offset = 0;
-#endif
+            gdb_arch_regs_get (&gdb_regs, (char *)tmp_reg_buffer);
+            gdb_arch_reg_info_get (GDB_PC_REG, &size, &offset);
             savedPtr = ptr;
             ptr = mem2hex (tmp_reg_buffer + offset, ptr, size, 1);
             bufSize -= (ptr - savedPtr);
@@ -1083,10 +1101,8 @@ int gdb_bp_add (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCo
         return -1;
     }
 
-#if 0
-    if (gdb_mem_probe ((void *) addr, length, 0) != length)
+    if (gdb_mem_probe ((void *)addr, SYS_MEM_SAFE_READ, length, 0, 1) == -1)
             return (-1);
-#endif
 
     /* Add software breakpoint to BP list */
 
@@ -1097,9 +1113,8 @@ int gdb_bp_add (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCo
 	        bpArray[ix].valid = 1;
 	        bpArray[ix].enabled = 0;
 	        bpArray[ix].addr = (GDB_INSTR *) addr;
+		return (0);
 	        }
-
-	    return (0);
 	    }
 
     *pErrCode = GDB_ERROR_BP_LIST_FULL;
@@ -1234,9 +1249,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                 OUTBUF_FILL (STUB_OK);
                 gdb_bps_remove ();
                 gdb_is_connected = 0;
-                if (_func_gdbDisconnect != NULL)
-                    (*_func_gdbDisconnect)();
-                VARIABLE_WRITE_SYNC (gdb_debug_status, NOT_DEBUGGING);
+                gdb_debug_status = NOT_DEBUGGING;
                 gdb_cpu_resume ();
                 no_ack = 1;
                 gdb_no_ack = 0;
@@ -1261,7 +1274,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                     gdb_no_ack = 1;
                     OUTBUF_FILL (STUB_OK);
                     }
-#ifdef        GDB_ARCH_HAS_VMCS
+#ifdef GDB_ARCH_HAS_VMCS
                 else if (strncmp((const char *)ptr, "wr.vmcs:", 8) == 0)
                     {
                     long long addr;
@@ -1300,7 +1313,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                 else if (strncmp((const char *)ptr, "wr.", 3) == 0) 
                     {
                     ptr += 3;
-#ifdef        GDB_ARCH_HAS_VMCS
+#ifdef GDB_ARCH_HAS_VMCS
                     if (strncmp ((const char *)ptr, "vmcs:", 5) == 0) 
                             {
                         long long addr;
@@ -1327,7 +1340,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                             OUTBUF_FILL (STUB_ERROR);
                         }
 #endif
-#ifdef        GDB_ARCH_HAS_EXTENDED_REGISTERS
+#ifdef GDB_ARCH_HAS_EXTENDED_REGISTERS
                     if (strncmp ((const char *)ptr, "eregs:", 6) == 0) 
                             {
                         int size = -1;
@@ -1346,7 +1359,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                             OUTBUF_FILL (STUB_ERROR);
                         }
 #endif
-#ifdef        GDB_ARCH_HAS_CPUID
+#ifdef GDB_ARCH_HAS_CPUID
                     if (strncmp ((const char *)ptr, "cpuid:", 6) == 0) 
                             {
                         uint32_t arg1 = 0;
@@ -1373,13 +1386,13 @@ int gdb_protocol_parse (unsigned char * ptr)
                         else
                             OUTBUF_FILL (STUB_ERROR);
                         }
-#endif        /* GDB_ARCH_HAS_CPUID */
+#endif /* GDB_ARCH_HAS_CPUID */
                     }
                 else if (strcmp ((const char *)ptr, "Supported") == 0)
                     {
                     size_t size = GDB_BUF_SIZE;
 
-#if GDB_ARCH_HAS_WRCONS
+#ifdef GDB_ARCH_HAS_WRCONS
                     (void)snprintf ((char *)outBuf, size,
                                   "PacketSize=%x;qXfer:features:read+;QStartNoAckMode+;WrCons+", GDB_BUF_SIZE);
 #else
@@ -1387,15 +1400,15 @@ int gdb_protocol_parse (unsigned char * ptr)
                                   "PacketSize=%x;qXfer:features:read+;QStartNoAckMode+", GDB_BUF_SIZE);
 #endif
                     size -= (strlen ((char *)outBuf) + 1);
-#ifdef        GDB_ARCH_HAS_VMCS
+#ifdef GDB_ARCH_HAS_VMCS
                     strncat ((char *)outBuf, STR_QWR_VMCS, size);
                     size -= sizeof (STR_QWR_VMCS);
 #endif
-#ifdef        GDB_ARCH_HAS_EXTENDED_REGISTERS
+#ifdef GDB_ARCH_HAS_EXTENDED_REGISTERS
                     strncat ((char *)outBuf, STR_QWR_EREGS, size);
                     size -= sizeof (STR_QWR_EREGS);
 #endif
-#ifdef        GDB_ARCH_HAS_CPUID
+#ifdef GDB_ARCH_HAS_CPUID
                     strncat ((char *)outBuf, STR_QWR_CPUID, size);
                     size -= sizeof (STR_QWR_CPUID);
 #endif
@@ -1428,20 +1441,16 @@ int gdb_protocol_parse (unsigned char * ptr)
 
             case 'g':                /* g -- Get Registers */
                 {
-#if 0
-                (void)gdbArchRegsGet (&stopModeRegs,
-                                      (char *)tmp_reg_buffer);
-#endif
+                (void)gdb_arch_regs_get (&gdb_regs,(char *)tmp_reg_buffer);
                 mem2hex (tmp_reg_buffer, outBuf, GDBNUMREGBYTES, 1);
                 break;
                 }
-#if 0
             case 'G':                /* GXX... -- Write Registers */
                 {
                 int i;
                 int value;
 
-                (void)gdbArchRegsGet (&stopModeRegs,
+                (void)gdb_arch_regs_get (&gdb_regs,
                                       (char *)tmp_reg_buffer);
                 for(i = 0; i < GDBNUMREGBYTES; i++) {
                     if((value = get_hex_byte(&ptr)) < 0) {
@@ -1449,27 +1458,23 @@ int gdb_protocol_parse (unsigned char * ptr)
                     }
                     tmp_reg_buffer[i] = (unsigned char) value;
                 }
-                (void)gdbArchRegsSet (&stopModeRegs,
-                                      (char *)tmp_reg_buffer);
+                gdb_arch_regs_set (&gdb_regs, (char *)tmp_reg_buffer);
                 OUTBUF_FILL (STUB_OK);
                 break;
                 }
             case 'P':                /* Pn..=r.. -- Write register */
                 {
                 int regNum = 0;
-                int        offset, size, i, value;
+                int offset = 0;
+                int size = 4;
+                int i, value;
 
                 OUTBUF_FILL ("E02");
                 if (!hex2int (&ptr, &regNum) || *(ptr++) != '=')
                     break;
 
-                (void)gdbArchRegsGet (&stopModeRegs,
-                                      (char *)tmp_reg_buffer);
-                if (gdbArchRegInfoGet (regNum, &size, &offset) == -1)
-                    {
-                    OUTBUF_FILL ("");
-                    break;
-                    }
+                gdb_arch_regs_get (&gdb_regs,(char *)tmp_reg_buffer);
+                gdb_arch_reg_info_get (regNum, &size, &offset);
 
                 for(i = 0; i < size; i++)
                     {
@@ -1479,17 +1484,15 @@ int gdb_protocol_parse (unsigned char * ptr)
                     }
                 if (i != size)
                     break;
-                (void)gdbArchRegsSet (&stopModeRegs,
-                                      (char *)tmp_reg_buffer);
+                gdb_arch_regs_set (&gdb_regs,(char *)tmp_reg_buffer);
                 OUTBUF_FILL (STUB_OK);
                 break;
                 }
-#endif
-
             case 'p':
                 {
                 int regNum = 0;
-                int        offset, size;
+                int offset = 0;
+                int size = 4;
 
                 /* p<regno> */
                 
@@ -1499,18 +1502,8 @@ int gdb_protocol_parse (unsigned char * ptr)
                     break;
                     }
 
-#if 1
-                size = 4;
-                offset = 0;
-#else
-                (void)gdbArchRegsGet (&stopModeRegs,
-                                            (char *)tmp_reg_buffer);
-                if (gdbArchRegInfoGet (regNum, &size, &offset) == -1)
-                    {
-                    OUTBUF_FILL ("");
-                    break;
-                    }
-#endif
+                gdb_arch_regs_get (&gdb_regs, (char *)tmp_reg_buffer);
+                gdb_arch_reg_info_get (regNum, &size, &offset);
                 mem2hex (tmp_reg_buffer + offset, outBuf, size, 1);
                 break;
                 }
@@ -1527,10 +1520,8 @@ int gdb_protocol_parse (unsigned char * ptr)
                 if (! (*ptr++ == ',' && hex2int (&ptr, &length)))
                     break;
 
-#if 0
-                if (gdb_mem_probe ((void *)((long)addr), length, 0) != length)
+                if (gdb_mem_probe ((void *)((long)addr), SYS_MEM_SAFE_READ, length, 0, 1) == -1)
                     break;  /* No read access */
-#endif
 
                 /* Now read memory */
                 mem2hex((unsigned char *)((long)addr), outBuf, length, 1);
@@ -1553,10 +1544,8 @@ int gdb_protocol_parse (unsigned char * ptr)
                        *ptr++ == ':'))
                     break;
 
-#if 0
-                if (gdb_mem_probe ((void *)((long)addr), length, 1) != length)
+                    if (gdb_mem_probe ((void *)((long)addr), SYS_MEM_SAFE_WRITE, length, 0, 1) == -1)
                     break;  /* No write access */
-#endif
                 
                 /* Now write memory */
                 for(i = 0; i < length; i++)
@@ -1569,7 +1558,44 @@ int gdb_protocol_parse (unsigned char * ptr)
                 OUTBUF_FILL (STUB_OK);
                 break;
                 }
+            case 'X':                                /* Write Memory in binary format  */
+                {
+                long long addr;
+                int length;
+                int i;
+                unsigned char value;
+		unsigned char * buffer;
+                OUTBUF_FILL ("E02");
+
+                /* M<addr>,<length>:<val><val>...<val> */
+
+                if (hex2llong ((unsigned char ** )&ptr, &addr) == 0)
+                    break;
 
+                if (! (*ptr++ == ',' &&
+                       hex2int (&ptr, &length) &&
+                       *ptr++ == ':'))
+                    break;
+
+                if (gdb_mem_probe ((void *)((long)addr), SYS_MEM_SAFE_WRITE, length, 0, 1) == -1)
+                    break;  /* No write access */
+
+                /* Now write memory */
+		buffer = ptr;
+                for(i = 0; i < length; i++)
+                    {
+                    value = buffer[0];
+		    buffer++;
+                    if (value == '}') {
+			value = buffer[0] ^ 0x20;
+			buffer++;
+		    }
+                    ((unsigned char *)((long)addr))[i] = (unsigned char) value;
+                    }
+
+                OUTBUF_FILL (STUB_OK);
+                break;
+                }
             case 'C':                                /* Pass the signal to context */
                                                     /* and continue execution */
                 {
@@ -1604,7 +1630,7 @@ int gdb_protocol_parse (unsigned char * ptr)
 #endif
                     }
 
-                VARIABLE_WRITE_SYNC (gdb_debug_status, NOT_DEBUGGING);
+                gdb_debug_status = NOT_DEBUGGING;
                 no_ack = 1;
                 break;
                 }
@@ -1641,7 +1667,7 @@ int gdb_protocol_parse (unsigned char * ptr)
 #endif
                     }
 
-		VARIABLE_WRITE_SYNC (gdb_debug_status, SINGLE_STEP);
+		gdb_debug_status = SINGLE_STEP;
 		no_ack = 1;
 		break;
 		}
@@ -1683,9 +1709,9 @@ int gdb_protocol_parse (unsigned char * ptr)
 		    gdb_cpu_pending_sig = signal;
 
 		if ((action == 'c') || (action == 'C'))
-		    VARIABLE_WRITE_SYNC (gdb_debug_status, NOT_DEBUGGING);
+		    gdb_debug_status = NOT_DEBUGGING;
 		else
-		    VARIABLE_WRITE_SYNC (gdb_debug_status, SINGLE_STEP);
+		    gdb_debug_status = SINGLE_STEP;
 		no_ack = 1;
 		break;
 		}
@@ -1780,19 +1806,12 @@ static int putDebugString (unsigned char *str, int len)
 {
     int num = 0;
 
-    if (_func_gdbPacketPut != NULL)
-        {
-        return _func_gdbPacketPut (str, len);
-        }
-    else
+    if (len > 0 && (str != NULL))
         {
-        if (len > 0 && (str != NULL))
-            {
-            for (num = 0; num < len; num ++)
-                putDebugChar (str[num]);
-            }
-        return num;
+        for (num = 0; num < len; num ++)
+            putDebugChar (str[num]);
         }
+    return num;
 }
 
 #if 0
@@ -1870,18 +1889,11 @@ static void gdb_bps_install (void)
     for (ix = 0; ix < MAX_SW_BP; ix++) {
 	    if (bpArray[ix].valid == 1 && !bpArray[ix].enabled) {
 	        GDB_INSTR * addr = bpArray[ix].addr;
-
-            bpArray[ix].insn = *addr;
-#if 0
-            VM_CONTEXT_BUFFER_WRITE (NULL, &bpInst, addr, sizeof(GDB_INSTR));
-            (void)CACHE_TEXT_LOCAL_UPDATE (addr, sizeof (GDB_INSTR));
-#else
-            *addr = bpInst;
-#endif
-            bpArray[ix].enabled = 1;
+		bpArray[ix].insn = *addr;
+		(void)gdb_instruction_set (addr, &bpInst, sizeof(GDB_INSTR));
+		bpArray[ix].enabled = 1;
 	    } else if (bpArray[ix].valid == 0) {
 	        /* First non valid entry in the table is the last entry */
-
 	        break;
 	    }
 	}
@@ -1909,18 +1921,10 @@ static void gdb_bps_uninstall (void) {
     for (ix = 0; ix < MAX_SW_BP; ix++) {
 	    if (bpArray[ix].valid == 1 && bpArray[ix].enabled) {
 	        GDB_INSTR * addr = bpArray[ix].addr;
-
-#if 0
-            VM_CONTEXT_BUFFER_WRITE (NULL, &bpArray[ix].insn, addr,
-                                     sizeof(GDB_INSTR));
-            (void)CACHE_TEXT_LOCAL_UPDATE (addr, sizeof (GDB_INSTR));
-#else
-            *addr = bpArray[ix].insn;
-            bpArray[ix].enabled = 0;
-#endif
+		(void)gdb_instruction_set(addr, &bpArray[ix].insn, sizeof(GDB_INSTR));
+		bpArray[ix].enabled = 0;
 	    } else if (bpArray[ix].valid == 0) {
 	        /* First non valid entry in the table is the last entry */
-
 	        break;
 	    }
 	}
@@ -1949,11 +1953,10 @@ static void gdb_cpu_resume (void)
     gdb_bps_install ();
     }
 
-#if 0
 #if DBG_NO_SINGLE_STEP || DBG_STEP_AND_BP_SHARED_VEC
 /*******************************************************************************
 *
-* gdbTrapHandler - trap handler for emulated single step
+* gdb_trap_handler - trap handler for emulated single step
 *
 * This trap handler is used to catch and handle the exceptions generated by
 * emulated single step.
@@ -1964,7 +1967,7 @@ static void gdb_cpu_resume (void)
 *
 */
 
-LOCAL BOOL gdbTrapHandler
+static void gdb_trap_handler
     (
     int         level,
     GDB_INSTR *	pAddr,
@@ -1974,177 +1977,18 @@ LOCAL BOOL gdbTrapHandler
     BOOL	hardware
     )
     {
-    if (gdb_debug_status == SINGLE_STEP)
-	return (gdbTraceHandler (level, pInfo, pRegisters));
+    if (gdb_debug_status == SINGLE_STEP) {
+    	gdb_trace_handler (level, pInfo, pRegisters);
+    	return;
+    }
     
-    return (gdbBpHandler (level, pInfo, pRegisters, pDbgRegSet, hardware));
+    gdb_bp_handler (level, pInfo, pRegisters, pDbgRegSet, hardware);
     }
 #endif	/* DBG_NO_SINGLE_STEP */
 
 /*******************************************************************************
 *
-* gdbTraceHandler - stop mode agent trace handler
-*
-* The Stop Mode Agent Breakpoint trace handler is used to catch and handle the
-* trace mode exceptions (single step).
-* This routine is invoked from VxDBG breakpoint exception handler with
-* interrupts locked.
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-*/
-
-LOCAL BOOL gdbTraceHandler
-    (
-    int         level,          /* int lock level at trace exception time */
-    void *      pInfo,          /* pointer to arch specific exception info */
-    REG_SET *   pRegisters      /* ptr to register set of interrupted context */
-    )
-    {
-    return (gdbHandler (GDB_EXC_TRACE, level, pInfo, pRegisters, NULL, 0,
-                        GDB_SIG_TRAP));
-    }
-
-/*******************************************************************************
-*
-* gdbBpHandler - Stop Mode Agent Breakpoint handler
-*
-* The Stop Mode Agent Breakpoint handler is used to catch and handle the BP
-* exceptions.
-* This routine is invoked from VxDBG breakpoint exception handler with
-* interrupts locked.
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-*/
-
-LOCAL BOOL gdbBpHandler
-    (
-    int         level,          /* interrupt lock level at BP exception time */
-    void *      pInfo,          /* pointer to arch specific exception info */
-    REG_SET *   pRegisters,     /* ptr to register set of interrupted context */
-    void *      pDbgRegSet,     /* ptr to debug register set */
-    BOOL        hardware        /* hardware breakpoint? */
-    )
-    {
-    int cpuId = _WRS_CPU_INDEX_GET();
-
-    VARIABLE_WRITE_SYNC (gdb_debug_status, DEBUGGING);
-    gdbCpuStopBpType = GDB_SOFT_BP;
-
-    return (gdbHandler (GDB_EXC_BP, level, pInfo, pRegisters, pDbgRegSet,
-                        hardware, GDB_SIG_TRAP));
-    }
-
-
-/******************************************************************************
-*
-* gdbExcHandle - exception hook handler
-*
-* This hook is called at exception time.
-*
-* RETURNS: 1 or 0
-*/
-
-BOOL gdbExcHandle
-    (
-    int				excType,	/* exception type */
-    void *			pInfo,		/* information on exception */
-    BOOL			systemSuspend	/* suspend system ? */
-    )
-    {
-    BOOL			ret;		/* return value */
-    EDR_INTERRUPT_INFO *	pIntInfo;	/* information on interrupt */
-    EDR_INIT_INFO *		pInitInfo;	/* information on init */
-    EDR_TASK_INFO *		pTaskInfo;	/* information on task */
-    EDR_RTP_INFO *		pRtpInfo;	/* information on RTP */
-    REG_SET *			pRegs;		/* register set */
-    EXC_INFO *			pExcInfo;	/* exception information */
-    int				sigNum = 0;	/* signal number */
-
-    /* Always return 0: stopped the context in Lab mode */
-    ret = 0;
-
-    /* No information means we are not in an exception
-     * or if we are not in debug mode (no client connected), do not the stop
-     * the context
-     */
-    if ((pInfo == NULL) || !gdb_is_connected)
-	return ret;
-
-    switch (excType)
-	{
-	case EDR_FACILITY_KERNEL:
-	    pTaskInfo = (EDR_TASK_INFO *) pInfo;
-
-	    /* check it is an exception */
-
-	    if (!pTaskInfo->isException)
-		return ret;
-
-	    pRegs	= pTaskInfo->pRegs;
-	    pExcInfo	= pTaskInfo->pExcInfo;
-	    sigNum	= pTaskInfo->signalNum;
-	    break;
-
-#ifdef _WRS_CONFIG_RTP
-	case EDR_FACILITY_RTP:
-	    pRtpInfo = (EDR_RTP_INFO *) pInfo;
-
-	    /* check it is an exception */
-
-	    if (!pRtpInfo->isException)
-		return ret;
-
-	    pRegs	= pRtpInfo->pRegs;
-	    pExcInfo	= pRtpInfo->pExcInfo;
-	    sigNum	= pRtpInfo->signalNum;
-	    break;
-#endif /* _WRS_CONFIG_RTP */
-
-	case EDR_FACILITY_INIT:
-	    pInitInfo = (EDR_INIT_INFO *) pInfo;
-
-	    /* check it is an exception */
-
-	    if (!pInitInfo->isException)
-		return ret;
-
-	    /* WRS_XXX - Pre-kernel Init not supported for now */
-
-	    return 0;
-	    break;
-
-	case EDR_FACILITY_INTERRUPT:
-	    pIntInfo = (EDR_INTERRUPT_INFO *) pInfo;
-
-	    /* check it is an exception */
-
-	    if (!pIntInfo->isException)
-		return ret;
-
-	    pRegs	= pIntInfo->pRegs;
-	    pExcInfo	= pIntInfo->pExcInfo;
-	    sigNum	= pIntInfo->signalNum;
-	    break;
-
-	default:
-	    return ret;
-	}
-
-    VARIABLE_WRITE_SYNC (gdb_debug_status, DEBUGGING);
-    (void) gdbHandler (GDB_EXC_OTHER, 0, pExcInfo, pRegs, NULL, 0, sigNum);
-
-    return ret;
-    }
-
-/*******************************************************************************
-*
-* gdbHandler - stop mode agent BP/trace handler
+* gdb_handler - stop mode agent BP/trace handler
 * 
 * This handler is a common handler of breakpoint and trace mode exceptions.
 * This handler is invoked with interrupts locked.
@@ -2155,30 +1999,15 @@ BOOL gdbExcHandle
 *
 */
 
-LOCAL BOOL gdbHandler
-    (
-    EXC_MODE    mode,   	/* exception mode */
-    int         level,          /* int lock level at trace exception time */
-    void *      pInfo,          /* pointer to arch specific exception info */
-    REG_SET *   pRegisters,     /* ptr to register set of interrupted context */
-    void *      pDbgRegSet,     /* ptr to debug register set */
-    BOOL        hardware,       /* hardware breakpoint? */
-    int		signal		/* signal number */
-    )
-    {
-    int cpuId = _WRS_CPU_INDEX_GET();
-
-#if DBG_NO_SINGLE_STEP
-    VM_CONTEXT_ID curVmCtx;
-#endif
+void gdb_handler (int mode, void * exc_regs, int signal) {
+    NANO_ESF * pEsf = (NANO_ESF *) exc_regs;
 
     /* Save BP/Trace handler registers */
-
-    stopModeRegs.vxRegs = *pRegisters;
+    gdb_regs.regs = *pEsf;
 
 #ifdef GDB_HAS_CPU_EXTRA_REGS_SUPPORT
     /* Save extra registers required by stop mode server */
-    (void) gdbArchCpuExtraRegsGet (cpuId, &stopModeRegs.extraRegs,
+    (void) gdbArchCpuExtraRegsGet (cpuId, &gdb_regs.extra_regs,
                                    pInfo);
 #endif
 
@@ -2186,58 +2015,46 @@ LOCAL BOOL gdbHandler
         {
         /* Check if GDB did request a step */
         if (gdb_debug_status != SINGLE_STEP)
-            return (0);
+            return;
 
         /* No longer pending trace mode exception */
-        VARIABLE_WRITE_SYNC (gdb_debug_status, DEBUGGING);
+        gdb_debug_status = DEBUGGING;
 
 #if DBG_NO_SINGLE_STEP
         /* remove temporary breakpoint */
-        
-        curVmCtx = vmCurrentGet ();
-        (void)vmCurrentSet (stoppedVmCtx[cpuId]);
 
-        VM_CONTEXT_BUFFER_WRITE (stoppedVmCtx[cpuId], &gdbStepEmuInsn,
+        VM_CONTEXT_BUFFER_WRITE (NULL, &gdbStepEmuInsn,
                                  gdbStepEmuNextPc, sizeof (GDB_INSTR));
         (void)CACHE_TEXT_LOCAL_UPDATE (gdbStepEmuNextPc, sizeof (GDB_INSTR));
-        (void)vmCurrentSet (curVmCtx);
 
         /* Disable trace mode */
-        intRegsUnlock (&stopModeRegs.vxRegs, gdb_trace_lock_key);
+        intRegsUnlock (&gdb_regs.regs, gdb_trace_lock_key);
 #else
         /* Disable trace mode */
-        wdbDbgTraceModeClear (&stopModeRegs.vxRegs, gdb_trace_lock_key);
+        gdb_trace_mode_clear (&gdb_regs.regs, gdb_trace_lock_key);
 #endif /* DBG_NO_SINGLE_STEP */
         }
 
     if ((mode == GDB_EXC_TRACE) || (mode == GDB_EXC_BP))
-	cpuStopByBp = 1;
-
-#if DBG_NO_SINGLE_STEP
-    stoppedVmCtx[cpuId] = vmCurrentGet();
-#endif /* DBG_NO_SINGLE_STEP */
-
-    VARIABLE_WRITE_SYNC (gdb_event_is_pending, 1);
+	gdb_stop_by_bp = 1;
 
+    gdb_event_is_pending = 1;
     gdb_cpu_stop_signal = signal;
 
     /* Enter stop mode agent control loop */
-    _func_gdbPollModeSet ();
+    /*_func_gdbPollModeSet ();*/
     gdb_ctrl_loop ();
-    _func_gdbIntModeSet ();
+   /* _func_gdbIntModeSet ();*/
 
     /* Restore BP handler registers */
-    *pRegisters = stopModeRegs.vxRegs;
+    *pEsf = gdb_regs.regs;
 
     if ((mode == GDB_EXC_TRACE) || (mode == GDB_EXC_BP))
-	cpuStopByBp = 0;
+	gdb_stop_by_bp = 0;
 
     /* Resume CPUs if not handing a single step */
     gdb_cpu_resume ();
-
-    return (1);
     }
-#endif
 
 /*******************************************************************************
 *
@@ -2281,19 +2098,16 @@ static void gdb_ctrl_loop (void)
 #if DBG_NO_SINGLE_STEP
             GDB_INSTR dbgBreakInsn = DBG_BREAK_INST;
 
-            gdbStepEmuNextPc = wdbDbgGetNpc(&stopModeRegs.vxRegs);
+            gdbStepEmuNextPc = wdbDbgGetNpc(&gdb_regs.regs);
             gdbStepEmuInsn = *gdbStepEmuNextPc;
-            VM_CONTEXT_BUFFER_WRITE (stoppedVmCtx[cpuId], &dbgBreakInsn,
+            VM_CONTEXT_BUFFER_WRITE (NULL, &dbgBreakInsn,
                                      gdbStepEmuNextPc, sizeof (GDB_INSTR));
             (void)CACHE_TEXT_LOCAL_UPDATE (gdbStepEmuNextPc, sizeof (GDB_INSTR));
-            gdb_trace_lock_key = intRegsLock (&stopModeRegs.vxRegs);
+            gdb_trace_lock_key = intRegsLock (&gdb_regs.regs);
 #else 
 		    /* Handle single step request for for runcontrol CPU */
 
-#if 0
-		    gdb_trace_lock_key = wdbDbgTraceModeSet (
-                                        &stopModeRegs.vxRegs);
-#endif
+		    gdb_trace_lock_key = gdb_trace_mode_set (&gdb_regs.regs);
 #endif /* DBG_NO_SINGLE_STEP */
 		return;
 		}
@@ -2321,11 +2135,11 @@ void gdb_system_stop (void)
     {
     int oldlevel = irq_lock();
 
-    VARIABLE_WRITE_SYNC (gdb_debug_status, DEBUGGING);
+    gdb_debug_status = DEBUGGING;
     gdb_cpu_stop_signal = GDB_SIG_INT; /* Stopped by a command */
 
     /* A GDB event is pending */
-    VARIABLE_WRITE_SYNC (gdb_event_is_pending, 1);
+    gdb_event_is_pending = 1;
 
     /* Transfer control to the control loop */
     gdb_ctrl_loop ();
-- 
1.9.1


From a660fc610d8145e709160d6953f99d3c782c2542 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Wed, 13 Jan 2016 17:02:03 -0500
Subject: [PATCH 16/82] gdb: add interrupt on first packet support

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index 0679ad7..d8df34a 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -47,12 +47,14 @@
 static NANO_CPU_EXC_STUB_DECL(nano_bp_exc_stub);
 static NANO_CPU_EXC_STUB_DECL(nano_trace_exc_stub);
 static NANO_CPU_EXC_STUB_DECL(nano_fpe_stub);
+static NANO_CPU_EXC_STUB_DECL(nano_pfault_stub);
 
 /* forward declarations */
 
 static void gdb_bp_handler (NANO_ESF * pEsf);
 static void gdb_trace_handler (NANO_ESF * esf);
 static void gdb_fpe_handle (NANO_ESF * esf);
+static void gdb_pfault_handle (NANO_ESF * esf);
 
 /**
  *
@@ -70,6 +72,7 @@ void gdb_arch_init (void) {
     nanoCpuExcConnect (IV_DIVIDE_ERROR, gdb_fpe_handle, nano_fpe_stub);
     nanoCpuExcConnect (IV_DEBUG, gdb_trace_handler, nano_trace_exc_stub);
     nanoCpuExcConnect (IV_BREAKPOINT, gdb_bp_handler, nano_bp_exc_stub);
+    nanoCpuExcConnect (IV_PAGE_FAULT, gdb_pfault_handle, nano_pfault_stub);
 }
 
 /**
@@ -279,5 +282,22 @@ static void gdb_bp_handler (NANO_ESF * esf) {
 static void gdb_fpe_handle (NANO_ESF * esf) {
     (void)irq_lock();
     gdb_debug_status = DEBUGGING;
-    gdb_handler (GDB_EXC_OTHER, esf, 8);
+    gdb_handler (GDB_EXC_OTHER, esf, GDB_SIG_FPE);
+    }
+
+/**
+ *
+ * @brief GDB page fault handler
+ *
+ * This GDB handler is used to catch and handle the page fault exceptions.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+static void gdb_pfault_handle (NANO_ESF * esf) {
+    (void)irq_lock();
+    gdb_debug_status = DEBUGGING;
+    gdb_handler (GDB_EXC_OTHER, esf, GDB_SIG_SIGSEGV);
     }
diff --git a/include/misc/debug/gdb_server.h b/include/misc/debug/gdb_server.h
index 614ab98..31f1fae 100644
--- a/include/misc/debug/gdb_server.h
+++ b/include/misc/debug/gdb_server.h
@@ -62,6 +62,8 @@ enum gdb_signal
     GDB_SIG_NULL = -1,
     GDB_SIG_INT = 2,
     GDB_SIG_TRAP = 5,
+    GDB_SIG_FPE = 8,
+    GDB_SIG_SIGSEGV = 11,
     GDB_SIG_STOP = 17
     };
 
@@ -71,7 +73,8 @@ extern volatile int gdb_debug_status;
 
 /* function declaration */
 
-extern void gdb_protocol_hook (void);
+extern void gdb_server_init (void);
+extern void gdb_system_stop_here (void * pEsf);
 extern void gdb_handler (int mode, void * pEsf, int signal);
 
 
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 415e54c..d7ca0d9 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -357,15 +357,20 @@ Notification Packets:
 */
 
 #include <nanokernel.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <string.h>
+#include <nano_private.h>
 #include <board.h>
+#include <device.h>
 #include <uart.h>
-#include <gdb_server.h>
-#include <debug/gdb_arch.h>
-#include <nano_private.h>
-#include <misc/debug/mem_safe.h>
 #include <cache.h>
+#include <misc/debug/mem_safe.h>
+#include <debug/gdb_arch.h>
+#include <gdb_server.h>
+#ifdef CONFIG_CONSOLE_HANDLER
+#include <console/uart_console.h>
+#endif
 
 /* defines */
 
@@ -443,6 +448,11 @@ static unsigned char inBuf [GDB_BUF_SIZE];
 static unsigned char tmp_buffer [GDB_BUF_SIZE];
 static unsigned char tmp_reg_buffer [GDBNUMREGBYTES];
 
+#ifdef CONFIG_CONSOLE_HANDLER
+static struct nano_fifo avail_queue;
+static struct nano_fifo cmds_queue;
+#endif
+
 /*
  * GDB breakpoint table. Note that all the valid entries in the
  * breakpoint table are kept contiguous. When parsing the table, the first
@@ -469,7 +479,12 @@ static int gdb_instruction_set(void *addr, char *instruction, size_t size);
 
 static void gdb_post_event (void);
 static void gdb_ctrl_loop (void);
-static void gdb_cpu_resume (void);
+static void gdb_system_stop (NANO_ESF * esf, int sig);
+static void gdb_system_resume (void);
+
+#ifdef CONFIG_CONSOLE_HANDLER
+static int gdb_irq_input_hook (struct device * dev, uint8_t ch);
+#endif
 
 #if	DBG_NO_SINGLE_STEP || DBG_STEP_AND_BP_SHARED_VEC
 static void gdb_trap_handler (int level, GDB_INSTR * pAddr, void * pInfo,
@@ -789,16 +804,6 @@ static int putPacket(unsigned char * buffer)
         } while (1);
     }
 
-void gdb_server_init (void) {
-	static int gdb_is_initialized = 0;
-
-    if (!gdb_is_initialized) {
-	gdb_arch_init();
-        gdb_is_initialized = 1;
-    }
-}
-
-
 void gdb_post_event (void)
     {
     int async_stop = 0;
@@ -1250,7 +1255,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                 gdb_bps_remove ();
                 gdb_is_connected = 0;
                 gdb_debug_status = NOT_DEBUGGING;
-                gdb_cpu_resume ();
+                gdb_system_resume ();
                 no_ack = 1;
                 gdb_no_ack = 0;
                 break;
@@ -1814,56 +1819,6 @@ static int putDebugString (unsigned char *str, int len)
     return num;
 }
 
-#if 0
-/*****************************************************************************
-*
-* gdbProtocolHook - Hook function to be called for each input character
-*
-* This routine is the protocol hook function to be called for each input
-* character on the serial line. The first argument passed is set by the
-* user via the FIOPROTOARG function.  The second argument is the input
-* character. If the input character is the GDB break character (CTRL+C by
-* default) then the system is stopped and the stop mode GDB server takes the
-* execution control.
-*
-* RETURNS: 1 if no further processing of the character is required (GDB
-* break
-* character detected) otherwise 0.
-*
-* ERRNO: N/A
-*
-*/
-
-BOOL gdbProtocolHook
-    (
-    char ch
-    )
-    {
-    if (ch == GDB_STOP_CHAR)
-        {
-        int lvl;
-
-        if (!gdb_is_connected)
-            vxdbgEnable (0, "Stop Mode Agent connected.");
-
-        lvl = intCpuLock();
-
-        (void)_func_gdbPollModeSet ();
-
-        /* A stop character has been received: Stop the system. */
-
-        gdb_system_stop ();
-
-        (void)_func_gdbIntModeSet ();
-
-        intCpuUnlock (lvl);
-
-        return 1;
-        }
-    return 0;
-    }
-#endif
-
 /*******************************************************************************
 *
 * gdb_bps_install - install breakpoints
@@ -1932,9 +1887,9 @@ static void gdb_bps_uninstall (void) {
 
 /*******************************************************************************
 *
-* gdb_cpu_resume - resume all CPUs
+* gdb_system_resume - resume the system
 *
-* This routine re-installs breakpoint and resumes all CPUs.
+* This routine re-installs breakpoint and resumes the system.
 *
 * RETURNS: always 1.
 *
@@ -1942,9 +1897,9 @@ static void gdb_bps_uninstall (void) {
 *
 */
 
-static void gdb_cpu_resume (void)
+static void gdb_system_resume (void)
     {
-    /* CPUs must not be resumed if we're going to execute a single step */
+    /* system must not be resumed if we're going to execute a single step */
 
     if (gdb_debug_status == SINGLE_STEP)
         return;
@@ -2052,8 +2007,8 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
     if ((mode == GDB_EXC_TRACE) || (mode == GDB_EXC_BP))
 	gdb_stop_by_bp = 0;
 
-    /* Resume CPUs if not handing a single step */
-    gdb_cpu_resume ();
+    /* Resume system if not handing a single step */
+    gdb_system_resume ();
     }
 
 /*******************************************************************************
@@ -2131,12 +2086,17 @@ static void gdb_ctrl_loop (void)
 *
 */
 
-void gdb_system_stop (void)
+static void gdb_system_stop (NANO_ESF * esf, int sig)
     {
     int oldlevel = irq_lock();
 
     gdb_debug_status = DEBUGGING;
-    gdb_cpu_stop_signal = GDB_SIG_INT; /* Stopped by a command */
+    if (sig != 0) gdb_cpu_stop_signal = sig;
+    else gdb_cpu_stop_signal = GDB_SIG_INT; /* Stopped by a command */
+
+    /* Save registers */
+    if (esf != NULL)
+	gdb_regs.regs = *esf;
 
     /* A GDB event is pending */
     gdb_event_is_pending = 1;
@@ -2144,24 +2104,13 @@ void gdb_system_stop (void)
     /* Transfer control to the control loop */
     gdb_ctrl_loop ();
 
-    /* Resume CPU if not a single step request */
-    gdb_cpu_resume ();
+    /* Resume system if not a single step request */
+    gdb_system_resume ();
 
     irq_unlock(oldlevel);
     }
 
 
-void gdb_protocol_hook (void) {
-    unsigned char ch = 0;
-
-    if (uart_poll_in (UART_CONSOLE_DEV, &ch) == 0) {
-        if (ch == GDB_STOP_CHAR) {
-	    gdb_server_init ();
-	    gdb_system_stop ();
-        }
-    }
-}
-
 int gdb_instruction_set(void *addr, char *instruction, size_t size)
 {
 	if (sys_mem_safe_write_to_text_section(addr, instruction, size) < 0) {
@@ -2170,3 +2119,58 @@ int gdb_instruction_set(void *addr, char *instruction, size_t size)
 	sys_cache_flush((vaddr_t)addr, size);
 	return 0;
 }
+
+#ifdef CONFIG_CONSOLE_HANDLER
+static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
+    if (ch == GDB_STOP_CHAR) {
+	int oldlevel = irq_lock();
+
+	uart_irq_rx_disable(dev);
+	uart_irq_tx_disable(dev);
+	uart_irq_err_disable(dev);
+	gdb_system_stop (NULL, 0);
+	uart_irq_rx_enable(dev);
+	uart_irq_tx_enable(dev);
+	uart_irq_err_enable(dev);
+	irq_unlock(oldlevel);
+	return 1;
+    }
+    return 0;
+}
+#endif
+
+void gdb_server_init (void) {
+    static int gdb_is_initialized = 0;
+
+    if (!gdb_is_initialized) {
+	gdb_arch_init();
+#ifdef CONFIG_CONSOLE_HANDLER
+	nano_fifo_init(&cmds_queue);
+	nano_fifo_init(&avail_queue);
+	uart_irq_input_hook_set(UART_CONSOLE_DEV, gdb_irq_input_hook);
+	uart_register_input(&avail_queue, &cmds_queue);
+#endif
+        gdb_is_initialized = 1;
+    }
+}
+
+void gdb_system_stop_here (void * esf) {
+    int oldlevel = irq_lock();
+
+#ifdef CONFIG_CONSOLE_HANDLER
+    uart_irq_rx_disable(UART_CONSOLE_DEV);
+    uart_irq_tx_disable(UART_CONSOLE_DEV);
+    uart_irq_err_disable(UART_CONSOLE_DEV);
+#endif
+
+    gdb_system_stop ((NANO_ESF *) esf, GDB_SIG_STOP);
+
+#ifdef CONFIG_CONSOLE_HANDLER
+    uart_irq_rx_enable(UART_CONSOLE_DEV);
+    uart_irq_tx_enable(UART_CONSOLE_DEV);
+    uart_irq_err_enable(UART_CONSOLE_DEV);
+#endif
+
+    irq_unlock(oldlevel);
+}
+
-- 
1.9.1


From 85b42527520ee973fc201d47dd62acc2d2b197c2 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Wed, 13 Jan 2016 17:17:14 -0500
Subject: [PATCH 17/82] gdb: squash with micro sample


diff --git a/samples/microkernel/apps/gdb_server/src/gdb_start.c b/samples/microkernel/apps/gdb_server/src/gdb_start.c
index 7e14866..342a0ab 100644
--- a/samples/microkernel/apps/gdb_server/src/gdb_start.c
+++ b/samples/microkernel/apps/gdb_server/src/gdb_start.c
@@ -31,7 +31,6 @@
  */
 
 #include <stdint.h>
-#include <debug/gdb_server.h>
 
 #ifdef CONFIG_MICROKERNEL
 
@@ -50,8 +49,6 @@
 
 void gdbStart(void)
 {
-	gdb_server_init ();
-
 	while (1) {
 		/* wait a while, then let other task have a turn */
 		task_sleep(SLEEPTICKS);
@@ -78,7 +75,6 @@ void main(void)
 	struct nano_timer timer;
     uint32_t data[2] = {0, 0};
 
-	gdb_server_init ();
     nano_timer_init(&timer, data);
 
 	while (1) {
-- 
1.9.1


From 08e12fc451f6a27079b45e68fa131cb7e64aaed6 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Wed, 13 Jan 2016 17:18:40 -0500
Subject: [PATCH 18/82] gdb: initialize server via kernel's init system

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/include/misc/debug/gdb_server.h b/include/misc/debug/gdb_server.h
index 31f1fae..361d355 100644
--- a/include/misc/debug/gdb_server.h
+++ b/include/misc/debug/gdb_server.h
@@ -73,7 +73,6 @@ extern volatile int gdb_debug_status;
 
 /* function declaration */
 
-extern void gdb_server_init (void);
 extern void gdb_system_stop_here (void * pEsf);
 extern void gdb_handler (int mode, void * pEsf, int signal);
 
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index d7ca0d9..fbf5859 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -365,6 +365,7 @@ Notification Packets:
 #include <device.h>
 #include <uart.h>
 #include <cache.h>
+#include <init.h>
 #include <misc/debug/mem_safe.h>
 #include <debug/gdb_arch.h>
 #include <gdb_server.h>
@@ -2139,21 +2140,6 @@ static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
 }
 #endif
 
-void gdb_server_init (void) {
-    static int gdb_is_initialized = 0;
-
-    if (!gdb_is_initialized) {
-	gdb_arch_init();
-#ifdef CONFIG_CONSOLE_HANDLER
-	nano_fifo_init(&cmds_queue);
-	nano_fifo_init(&avail_queue);
-	uart_irq_input_hook_set(UART_CONSOLE_DEV, gdb_irq_input_hook);
-	uart_register_input(&avail_queue, &cmds_queue);
-#endif
-        gdb_is_initialized = 1;
-    }
-}
-
 void gdb_system_stop_here (void * esf) {
     int oldlevel = irq_lock();
 
@@ -2174,3 +2160,21 @@ void gdb_system_stop_here (void * esf) {
     irq_unlock(oldlevel);
 }
 
+static int init_gdb_server(struct device *unused) {
+    static int gdb_is_initialized = 0;
+
+    if (!gdb_is_initialized) {
+	gdb_arch_init();
+#ifdef CONFIG_CONSOLE_HANDLER
+	nano_fifo_init(&cmds_queue);
+	nano_fifo_init(&avail_queue);
+	uart_irq_input_hook_set(UART_CONSOLE_DEV, gdb_irq_input_hook);
+	uart_register_input(&avail_queue, &cmds_queue);
+#endif
+        gdb_is_initialized = 1;
+    }
+    return 0;
+}
+
+DECLARE_DEVICE_INIT_CONFIG(gdb_server, "", init_gdb_server, NULL);
+SYS_DEFINE_DEVICE(gdb_server, NULL, NANOKERNEL, 1);
-- 
1.9.1


From 3695161d250a9bd81f12a5fe6513ef78c5faa663 Mon Sep 17 00:00:00 2001
From: Peter Mitsis <peter.mitsis@windriver.com>
Date: Thu, 14 Jan 2016 12:10:48 -0500
Subject: [PATCH 19/82] debug: add extra support for interrupt stack frame

Adds infrastructure to allow a debugger to obtain the current interrupt
stack frame.  (An exception handler already knows where its ESF is
located).  The interrupt stack frame has been updated so that the
registers at the point of interrupt can be obtained by the debugger.

This feature is enabled through the use of the DEBUG_INFO Kconfig
option.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/core/Makefile b/arch/x86/core/Makefile
index 72601c6..13aa5b7 100644
--- a/arch/x86/core/Makefile
+++ b/arch/x86/core/Makefile
@@ -27,3 +27,5 @@ obj-$(CONFIG_FP_SHARING) += float.o
 obj-$(CONFIG_MICROKERNEL) += strtask.o
 obj-$(CONFIG_ERRNO) += errno.o
 obj-$(CONFIG_GDT_DYNAMIC) += gdt.o
+
+obj-$(CONFIG_DEBUG_INFO) += debug/
diff --git a/arch/x86/core/debug/Makefile b/arch/x86/core/debug/Makefile
new file mode 100644
index 0000000..c3f4f13
--- /dev/null
+++ b/arch/x86/core/debug/Makefile
@@ -0,0 +1,4 @@
+ccflags-y += -I$(srctree)/kernel/nanokernel/include
+ccflags-y += -I$(srctree)/kernel/microkernel/include
+
+obj-y = debug_frames.o
diff --git a/arch/x86/core/debug/debug_frames.c b/arch/x86/core/debug/debug_frames.c
new file mode 100644
index 0000000..1c6b822
--- /dev/null
+++ b/arch/x86/core/debug/debug_frames.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2015, Wind River Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1) Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2) Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3) Neither the name of Wind River Systems nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * @brief Stack frames for debugging purposes
+ *
+ * This file contains a routine useful for debugging that gets a pointer to
+ * the current interrupt stack frame.
+ */
+
+#include <nanokernel.h>
+#include <nano_private.h>
+
+NANO_ISF *sys_debug_current_isf_get(void)
+{
+	return _nanokernel.isf;
+}
diff --git a/arch/x86/core/i386_sysV_abi/intstub.S b/arch/x86/core/i386_sysV_abi/intstub.S
index cd40cda..fb4255b 100644
--- a/arch/x86/core/i386_sysV_abi/intstub.S
+++ b/arch/x86/core/i386_sysV_abi/intstub.S
@@ -128,6 +128,18 @@ SECTION_FUNC(TEXT, _IntEnt)
 	pushl	%ecx
 	pushl	%edx
 
+#ifdef CONFIG_DEBUG_INFO
+	/*
+	 * Push the cooperative registers on the existing stack as they are
+	 * required by debug tools.
+	 */
+
+	push	%edi
+	push	%esi
+	push	%ebx
+	push	%ebp
+#endif
+
 #ifdef CONFIG_INT_LATENCY_BENCHMARK
 	/*
 	 * Volatile registers are now saved it is safe to start measuring
@@ -169,7 +181,11 @@ SECTION_FUNC(TEXT, _IntEnt)
 
 	incl	__tNANO_nested_OFFSET(%ecx)	/* inc interrupt nest count */
 	cmpl	$1, __tNANO_nested_OFFSET(%ecx)	/* use int stack if !nested */
+#ifdef CONFIG_DEBUG_INFO
+	jne	nested_save_isf
+#else
 	jne	alreadyOnIntStack
+#endif
 
 	/* switch to base of the interrupt stack */
 
@@ -179,7 +195,17 @@ SECTION_FUNC(TEXT, _IntEnt)
 
 	/* save thread's stack pointer onto base of interrupt stack */
 
-	pushl	%edx			/* Save stack pointer */
+	pushl	%edx                /* Save stack pointer */
+
+#ifdef CONFIG_DEBUG_INFO
+	/*
+	 * The saved stack pointer happens to match the address of the interrupt
+	 * stack frame.  To simplify the exit case, push a dummy ISF for the "old"
+	 * ISF and save it to the _nanokernel.isf.
+	 */
+	pushl	%edx
+	movl	%edx, __tNANO_isf_OFFSET(%ecx)
+#endif
 
 #ifdef CONFIG_ADVANCED_POWER_MANAGEMENT
 	cmpl	$0, __tNANO_idle_OFFSET(%ecx)
@@ -187,6 +213,14 @@ SECTION_FUNC(TEXT, _IntEnt)
 	/* fast path is !idle, in the pipeline */
 #endif /* CONFIG_ADVANCED_POWER_MANAGEMENT */
 
+#ifdef CONFIG_DEBUG_INFO
+	jmp alreadyOnIntStack
+
+BRANCH_LABEL(nested_save_isf)
+	movl	__tNANO_isf_OFFSET(%ecx), %edx	/* Get old ISF */
+	movl	%esp, __tNANO_isf_OFFSET(%ecx)	/* Save new ISF */
+	pushl	%edx                            /* Save old ISF */
+#endif
 
 	/* fall through to nested case */
 
@@ -281,6 +315,9 @@ BRANCH_LABEL(_IntExit)
 	/* determine whether exiting from a nested interrupt */
 
 	movl	$_nanokernel, %ecx
+#ifdef CONFIG_DEBUG_INFO
+	popl	__tNANO_isf_OFFSET(%ecx)    /* Restore old ISF */
+#endif
 	decl	__tNANO_nested_OFFSET(%ecx)	/* dec interrupt nest count */
 	jne	nestedInterrupt                 /* 'iret' if nested case */
 
@@ -322,6 +359,13 @@ BRANCH_LABEL(_IntExit)
 
 	popl	%esp		/* switch back to kernel stack */
 
+#ifdef CONFIG_DEBUG_INFO
+	popl	%ebp
+	popl	%ebx
+	popl	%esi
+	popl	%edi
+#endif
+
 	pushfl			/* push KERNEL_LOCK_KEY argument */
 	call	_Swap
 
@@ -388,6 +432,14 @@ BRANCH_LABEL(nestedInterrupt)
 #ifdef CONFIG_INT_LATENCY_BENCHMARK
 	call	_int_latency_stop
 #endif
+
+#ifdef CONFIG_DEBUG_INFO
+	popl	%ebp
+	popl	%ebx
+	popl	%esi
+	popl	%edi
+#endif
+
 	popl	%edx		/* pop volatile registers in reverse order */
 	popl	%ecx
 	popl	%eax
diff --git a/arch/x86/core/offsets/offsets.c b/arch/x86/core/offsets/offsets.c
index 65d8af1..1e5e479 100644
--- a/arch/x86/core/offsets/offsets.c
+++ b/arch/x86/core/offsets/offsets.c
@@ -46,6 +46,9 @@
 
 GEN_OFFSET_SYM(tNANO, nested);
 GEN_OFFSET_SYM(tNANO, common_isp);
+#ifdef CONFIG_DEBUG_INFO
+GEN_OFFSET_SYM(tNANO, isf);
+#endif
 #ifdef CONFIG_ADVANCED_POWER_MANAGEMENT
 GEN_OFFSET_SYM(tNANO, idle);
 #endif /* CONFIG_ADVANCED_POWER_MANAGEMENT */
diff --git a/arch/x86/include/nano_private.h b/arch/x86/include/nano_private.h
index 6a725dc..81ee584 100644
--- a/arch/x86/include/nano_private.h
+++ b/arch/x86/include/nano_private.h
@@ -699,6 +699,9 @@ typedef struct s_NANO {
 #endif
 	unsigned nested;  /* nested interrupt count */
 	char *common_isp; /* interrupt stack pointer base */
+#if defined(CONFIG_DEBUG_INFO)
+	NANO_ISF *isf;    /* ptr to interrupt stack frame */
+#endif
 
 #ifdef CONFIG_ADVANCED_POWER_MANAGEMENT
 	int32_t idle; /* Number of ticks for kernel idling */
diff --git a/include/arch/x86/arch.h b/include/arch/x86/arch.h
index c8ba55f..1a5057b 100644
--- a/include/arch/x86/arch.h
+++ b/include/arch/x86/arch.h
@@ -332,6 +332,12 @@ typedef struct nanoEsf {
  */
 
 typedef struct nanoIsf {
+#ifdef CONFIG_DEBUG_INFO
+	unsigned int ebp;
+	unsigned int ebx;
+	unsigned int esi;
+	unsigned int edi;
+#endif /* CONFIG_DEBUG_INFO */
 	unsigned int edx;
 	unsigned int ecx;
 	unsigned int eax;
diff --git a/include/misc/debug/debug_info.h b/include/misc/debug/debug_info.h
new file mode 100644
index 0000000..49852ad
--- /dev/null
+++ b/include/misc/debug/debug_info.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2015, Wind River Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1) Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2) Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3) Neither the name of Wind River Systems nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * @brief Information necessary for debugging
+ *
+ * @internal No routine is provided for getting the current exception stack
+ * frame the exception handler already has knowledge of the ESF.
+ */
+
+#ifndef __DEBUG_INFO_H
+#define __DEBUG_INFO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <nanokernel.h>
+
+#ifndef _ASMLANGUAGE
+
+/**
+ * @brief Get the current interrupt stack frame
+ *
+ * @details This routine (only called from an ISR) returns a
+ * pointer to the current interrupt stack frame.
+ *
+ * @return pointer the current interrupt stack frame
+ */
+extern NANO_ISF *sys_debug_current_isf_get(void);
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __DEBUG_INFO_H */
diff --git a/misc/debug/Kconfig b/misc/debug/Kconfig
index f70ec32..0db58dd 100644
--- a/misc/debug/Kconfig
+++ b/misc/debug/Kconfig
@@ -64,6 +64,20 @@ config MEM_SAFE_NUM_EXTRA_REGIONS
 endmenu
 
 #
+# Generic Debugging Options
+#
+
+config DEBUG_INFO
+	bool "Enable system debugging information"
+	default n
+	depends on !X86_IAMCU
+	help
+	This option enables the addition of various information that can be used
+	by debuggers in debugging the system.
+
+	NOTE: Does not currently work with the x86 IAMCU ABI.
+
+#
 # GDB Server options
 #
 
-- 
1.9.1


From 895f8cc1e583f83dea30424b83cbcbe80fe5169c Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Thu, 14 Jan 2016 13:42:29 -0500
Subject: [PATCH 20/82] gdb/x86: save and restore registers when taking an
 exception

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/core/fatal.c b/arch/x86/core/fatal.c
index e16df02..93d441e 100644
--- a/arch/x86/core/fatal.c
+++ b/arch/x86/core/fatal.c
@@ -31,6 +31,7 @@
 #include <drivers/loapic.h>
 
 #ifdef CONFIG_GDB_SERVER
+#include <debug/gdb_arch.h>
 #include <debug/gdb_server.h>
 #endif
 
@@ -72,9 +73,12 @@ const NANO_ESF _default_esf = {
 FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
 					  const NANO_ESF *pEsf)
 {
-
 #ifdef CONFIG_GDB_SERVER
-	gdb_system_stop_here((void *) pEsf);
+	GDB_REG_SET regs;
+
+	gdb_arch_regs_from_esf(&regs, (NANO_ESF *) pEsf);
+	gdb_system_stop_here((void *) &regs);
+	gdb_arch_regs_to_esf(&regs, (NANO_ESF *) pEsf);
 #endif
 
 #ifdef CONFIG_PRINTK
-- 
1.9.1


From 93a1d45bf5ea27a707a878c9e339cb6786075988 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Thu, 14 Jan 2016 13:48:16 -0500
Subject: [PATCH 21/82] gdb: squash with micro sample


diff --git a/samples/microkernel/apps/gdb_server/prj_x86.conf b/samples/microkernel/apps/gdb_server/prj_x86.conf
index 06a58bb..4e7a4c9 100644
--- a/samples/microkernel/apps/gdb_server/prj_x86.conf
+++ b/samples/microkernel/apps/gdb_server/prj_x86.conf
@@ -2,4 +2,3 @@
 CONFIG_ENHANCED_SECURITY=n
 CONFIG_GDB_SERVER=y
 CONFIG_COMPILER_OPT="-O0 -g"
-CONFIG_CONSOLE_HANDLER=y
-- 
1.9.1


From 4d6a80a2f92d7798ff634ba7834cec18db459729 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Thu, 14 Jan 2016 13:48:24 -0500
Subject: [PATCH 22/82] gdb: squash with nano sample


diff --git a/samples/nanokernel/apps/gdb_server/prj.conf b/samples/nanokernel/apps/gdb_server/prj.conf
index 06a58bb..4e7a4c9 100644
--- a/samples/nanokernel/apps/gdb_server/prj.conf
+++ b/samples/nanokernel/apps/gdb_server/prj.conf
@@ -2,4 +2,3 @@
 CONFIG_ENHANCED_SECURITY=n
 CONFIG_GDB_SERVER=y
 CONFIG_COMPILER_OPT="-O0 -g"
-CONFIG_CONSOLE_HANDLER=y
-- 
1.9.1


From c07b94c5bea6fa66be8a2db949293195d63639c8 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Thu, 14 Jan 2016 13:50:50 -0500
Subject: [PATCH 23/82] gdb: retrieve registers when the GDB Server stops the
 system

Use the sys_debug_current_isf_get() routine to retrieve a register set
when the GDB Server stops the system.

This commit also adds a GDB Server configuration parameter to enable the
interrupt mode.  By default, the GDB server is configured to work in
interrupt mode. Polling mode can be selected by defining
CONFIG_GDB_SERVER_INTERRUPT_DRIVEN=n

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index d8df34a..3b5033c 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -77,6 +77,60 @@ void gdb_arch_init (void) {
 
 /**
  *
+ * @brief Fill a GDB register set from a given ESF register set
+ *
+ * This routine fills the provided GDB register set with values from given
+ * NANO_ESF register set.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+void gdb_arch_regs_from_esf (GDB_REG_SET * regs, NANO_ESF *esf) {
+	    regs->regs.eax = esf->eax;
+	    regs->regs.ecx = esf->ecx;
+	    regs->regs.edx = esf->edx;
+	    regs->regs.ebx = esf->ebx;
+	    regs->regs.esp = esf->esp;
+	    regs->regs.ebp = esf->ebp;
+	    regs->regs.esi = esf->esi;
+	    regs->regs.edi = esf->edi;
+	    regs->regs.eip = esf->eip;
+	    regs->regs.eflags = esf->eflags;
+	    regs->regs.cs = esf->cs;
+	    regs->regs.ss = esf->ss;
+}
+
+/**
+ *
+ * @brief Fill an ESF register set from a given GDB register set
+ *
+ * This routine fills the provided NANO_ESF register set with values
+ * from given GDB register set.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+void gdb_arch_regs_to_esf (GDB_REG_SET * regs, NANO_ESF *esf) {
+	    esf->eax = regs->regs.eax;
+	    esf->ecx = regs->regs.ecx;
+	    esf->edx = regs->regs.edx;
+	    esf->ebx = regs->regs.ebx;
+	    esf->esp = regs->regs.esp;
+	    esf->ebp = regs->regs.ebp;
+	    esf->esi = regs->regs.esi;
+	    esf->edi = regs->regs.edi;
+	    esf->eip = regs->regs.eip;
+	    esf->eflags = regs->regs.eflags;
+	    esf->cs = regs->regs.cs;
+	    esf->ss = regs->regs.ss;
+}
+
+/**
+ *
  * @brief Fill given buffer from given register set
  *
  * This routine fills the provided buffer with values from given register set.
@@ -108,20 +162,10 @@ void gdb_arch_regs_get (GDB_REG_SET * regs, char * buffer) {
     *((uint32_t *)buffer) = (uint32_t) regs->regs.eip;
     buffer += 4;
     *((uint32_t *)buffer) = regs->regs.eflags;
-#ifdef GDB_HAS_CPU_EXTRA_REGS_SUPPORT
-    buffer += 4;
-    *((uint32_t *)buffer) = regs->extra_regs.cs;
     buffer += 4;
-    *((uint32_t *)buffer) = regs->extra_regs.ss;
+    *((uint32_t *)buffer) = regs->regs.cs;
     buffer += 4;
-    *((uint32_t *)buffer) = regs->extra_regs.ds;
-    buffer += 4;
-    *((uint32_t *)buffer) = regs->extra_regs.es;
-    buffer += 4;
-    *((uint32_t *)buffer) = regs->extra_regs.fs;
-    buffer += 4;
-    *((uint32_t *)buffer) = regs->extra_regs.gs;
-#endif
+    *((uint32_t *)buffer) = regs->regs.ss;
 }
 
 /**
@@ -157,20 +201,10 @@ void gdb_arch_regs_set (GDB_REG_SET * regs,  char * buffer) {
     regs->regs.eip = *((uint32_t *)buffer);
     buffer += 4;
     regs->regs.eflags = *((uint32_t *)buffer);
-#ifdef GDB_HAS_CPU_EXTRA_REGS_SUPPORT
-    buffer += 4;
-    regs->extra_regs.cs = *((uint32_t *)buffer);
-    buffer += 4;
-    regs->extra_regs.ss = *((uint32_t *)buffer);
-    buffer += 4;
-    regs->extra_regs.ds = *((uint32_t *)buffer);
-    buffer += 4;
-    regs->extra_regs.es = *((uint32_t *)buffer);
     buffer += 4;
-    regs->extra_regs.fs = *((uint32_t *)buffer);
+    regs->regs.cs = *((uint32_t *)buffer);
     buffer += 4;
-    regs->extra_regs.gs = *((uint32_t *)buffer);
-#endif
+    regs->regs.ss = *((uint32_t *)buffer);
 }
 
 /**
@@ -205,10 +239,10 @@ void gdb_arch_reg_info_get (int reg_id, int * size, int * offset) {
  * \NOMANUAL
  */
 
-void gdb_trace_mode_clear (NANO_ESF * regs, int arg) {
-    regs->eflags &= ~INT_FLAG;
-    regs->eflags |= (arg & INT_FLAG);
-    regs->eflags &= ~TRACE_FLAG;
+void gdb_trace_mode_clear (GDB_REG_SET * regs, int arg) {
+	regs->regs.eflags &= ~INT_FLAG;
+	regs->regs.eflags |= (arg & INT_FLAG);
+	regs->regs.eflags &= ~TRACE_FLAG;
 }
 
 /**
@@ -222,12 +256,12 @@ void gdb_trace_mode_clear (NANO_ESF * regs, int arg) {
  * \NOMANUAL
  */
 
-int gdb_trace_mode_set (NANO_ESF * regs) {
+int gdb_trace_mode_set (GDB_REG_SET * regs) {
     int tmp;
 
-    tmp = regs->eflags;
-    regs->eflags &= ~INT_FLAG;
-    regs->eflags |= TRACE_FLAG;
+    tmp = regs->regs.eflags;
+    regs->regs.eflags &= ~INT_FLAG;
+    regs->regs.eflags |= TRACE_FLAG;
 
     return (tmp);
 }
diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
index caf935d..705de60 100644
--- a/arch/x86/include/debug/gdb_arch.h
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -41,6 +41,8 @@ extern "C" {
 
 /* define */
 
+#define GDB_ARCH_HAS_WRCONS
+
 #define GDB_TGT_ARCH    "i386"
 
 #define GDBNUMREGBYTES  (16*4)
@@ -58,20 +60,19 @@ typedef unsigned char GDB_INSTR;
 
 typedef struct
     {
-    NANO_ESF regs;
-#ifdef GDB_HAS_CPU_EXTRA_REGS_SUPPORT
-    GDB_EXTRA_REG_SET extra_regs;
-#endif
+    NANO_ISF regs;
     } GDB_REG_SET;
 
 /* function declaration */
 
 extern void gdb_arch_init (void);
+extern void gdb_arch_regs_from_esf (GDB_REG_SET * regs, NANO_ESF *esf);
+extern void gdb_arch_regs_to_esf (GDB_REG_SET * regs, NANO_ESF *esf);
 extern void gdb_arch_regs_get (GDB_REG_SET * regs, char * buffer) ;
 extern void gdb_arch_regs_set (GDB_REG_SET * regs,  char * buffer);
 extern void gdb_arch_reg_info_get (int reg_id, int * size, int * offset);
-extern void gdb_trace_mode_clear (NANO_ESF * regs, int arg);
-extern int gdb_trace_mode_set (NANO_ESF * regs);
+extern void gdb_trace_mode_clear (GDB_REG_SET * regs, int arg);
+extern int gdb_trace_mode_set (GDB_REG_SET * regs);
 
 #endif /* _ASMLANGUAGE */
 
diff --git a/include/misc/debug/gdb_server.h b/include/misc/debug/gdb_server.h
index 361d355..a41cda1 100644
--- a/include/misc/debug/gdb_server.h
+++ b/include/misc/debug/gdb_server.h
@@ -73,7 +73,7 @@ extern volatile int gdb_debug_status;
 
 /* function declaration */
 
-extern void gdb_system_stop_here (void * pEsf);
+extern void gdb_system_stop_here (void * regs);
 extern void gdb_handler (int mode, void * pEsf, int signal);
 
 
diff --git a/misc/debug/Kconfig b/misc/debug/Kconfig
index 0db58dd..57ddd7f 100644
--- a/misc/debug/Kconfig
+++ b/misc/debug/Kconfig
@@ -88,6 +88,14 @@ config	GDB_SERVER
 	help
 	This option enables the GDB Server support.
 
+config	GDB_SERVER_INTERRUPT_DRIVEN
+	bool
+	prompt "Interrupt driver GDB Server support"
+	default y
+	select CONSOLE_HANDLER
+	help
+	This option enables interrupt support for GDB Server.
+
 config GDB_SERVER_MAX_SW_BP
 	int
 	prompt "Maximum number of GDB server software breakpoints"
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index fbf5859..fbbc03e 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -366,10 +366,11 @@ Notification Packets:
 #include <uart.h>
 #include <cache.h>
 #include <init.h>
-#include <misc/debug/mem_safe.h>
 #include <debug/gdb_arch.h>
+#include <misc/debug/mem_safe.h>
 #include <gdb_server.h>
-#ifdef CONFIG_CONSOLE_HANDLER
+#include <debug_info.h>
+#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 #include <console/uart_console.h>
 #endif
 
@@ -382,6 +383,8 @@ Notification Packets:
 
 #define MAX_SW_BP       CONFIG_GDB_SERVER_MAX_SW_BP     /* Maximum number of software breakpoints */
 
+#define GDB_INVALID_REG_SET	((void *)-1)
+
 #define OUTBUF_FILL(x) strncpy ((char *)outBuf, x, GDB_BUF_SIZE - 1)
 
 #define STR_COMMA_SEPARATOR     ","
@@ -435,6 +438,7 @@ static int gdb_is_connected = 0;	/* A client is connected to GDB Server */
 static int gdb_no_ack = 0;
 static int gdb_stop_by_bp = 0;
 static int gdb_trace_lock_key = 0;
+static int gdb_regs_not_valid = 0;
 static volatile int gdb_event_is_pending = 0;
 static volatile int gdb_cpu_stop_signal;
 static volatile int gdb_cpu_pending_sig;
@@ -449,7 +453,7 @@ static unsigned char inBuf [GDB_BUF_SIZE];
 static unsigned char tmp_buffer [GDB_BUF_SIZE];
 static unsigned char tmp_reg_buffer [GDBNUMREGBYTES];
 
-#ifdef CONFIG_CONSOLE_HANDLER
+#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static struct nano_fifo avail_queue;
 static struct nano_fifo cmds_queue;
 #endif
@@ -480,10 +484,10 @@ static int gdb_instruction_set(void *addr, char *instruction, size_t size);
 
 static void gdb_post_event (void);
 static void gdb_ctrl_loop (void);
-static void gdb_system_stop (NANO_ESF * esf, int sig);
+static void gdb_system_stop (NANO_ISF * reg, int sig);
 static void gdb_system_resume (void);
 
-#ifdef CONFIG_CONSOLE_HANDLER
+#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static int gdb_irq_input_hook (struct device * dev, uint8_t ch);
 #endif
 
@@ -1447,6 +1451,11 @@ int gdb_protocol_parse (unsigned char * ptr)
 
             case 'g':                /* g -- Get Registers */
                 {
+		if (gdb_regs_not_valid)
+                    {
+                    OUTBUF_FILL ("E02");
+                    break;
+                    }
                 (void)gdb_arch_regs_get (&gdb_regs,(char *)tmp_reg_buffer);
                 mem2hex (tmp_reg_buffer, outBuf, GDBNUMREGBYTES, 1);
                 break;
@@ -1456,6 +1465,11 @@ int gdb_protocol_parse (unsigned char * ptr)
                 int i;
                 int value;
 
+		if (gdb_regs_not_valid)
+                    {
+                    OUTBUF_FILL ("E02");
+                    break;
+                    }
                 (void)gdb_arch_regs_get (&gdb_regs,
                                       (char *)tmp_reg_buffer);
                 for(i = 0; i < GDBNUMREGBYTES; i++) {
@@ -1475,6 +1489,11 @@ int gdb_protocol_parse (unsigned char * ptr)
                 int size = 4;
                 int i, value;
 
+		if (gdb_regs_not_valid)
+                    {
+                    OUTBUF_FILL ("E02");
+                    break;
+                    }
                 OUTBUF_FILL ("E02");
                 if (!hex2int (&ptr, &regNum) || *(ptr++) != '=')
                     break;
@@ -1500,6 +1519,11 @@ int gdb_protocol_parse (unsigned char * ptr)
                 int offset = 0;
                 int size = 4;
 
+		if (gdb_regs_not_valid)
+                    {
+                    OUTBUF_FILL ("E02");
+                    break;
+                    }
                 /* p<regno> */
                 
                 if (!hex2int(&ptr, &regNum)) 
@@ -1956,16 +1980,9 @@ static void gdb_trap_handler
 */
 
 void gdb_handler (int mode, void * exc_regs, int signal) {
-    NANO_ESF * pEsf = (NANO_ESF *) exc_regs;
-
     /* Save BP/Trace handler registers */
-    gdb_regs.regs = *pEsf;
-
-#ifdef GDB_HAS_CPU_EXTRA_REGS_SUPPORT
-    /* Save extra registers required by stop mode server */
-    (void) gdbArchCpuExtraRegsGet (cpuId, &gdb_regs.extra_regs,
-                                   pInfo);
-#endif
+    gdb_arch_regs_from_esf(&gdb_regs, (NANO_ESF *) exc_regs);
+    gdb_regs_not_valid = 0;
 
     if (mode == GDB_EXC_TRACE)
         {
@@ -1987,7 +2004,7 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
         intRegsUnlock (&gdb_regs.regs, gdb_trace_lock_key);
 #else
         /* Disable trace mode */
-        gdb_trace_mode_clear (&gdb_regs.regs, gdb_trace_lock_key);
+        gdb_trace_mode_clear (&gdb_regs, gdb_trace_lock_key);
 #endif /* DBG_NO_SINGLE_STEP */
         }
 
@@ -1997,13 +2014,23 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
     gdb_event_is_pending = 1;
     gdb_cpu_stop_signal = signal;
 
+#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
+    uart_irq_rx_disable(UART_CONSOLE_DEV);
+    uart_irq_tx_disable(UART_CONSOLE_DEV);
+    uart_irq_err_disable(UART_CONSOLE_DEV);
+#endif
+
     /* Enter stop mode agent control loop */
-    /*_func_gdbPollModeSet ();*/
     gdb_ctrl_loop ();
-   /* _func_gdbIntModeSet ();*/
+
+#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
+    uart_irq_rx_enable(UART_CONSOLE_DEV);
+    uart_irq_tx_enable(UART_CONSOLE_DEV);
+    uart_irq_err_enable(UART_CONSOLE_DEV);
+#endif
 
     /* Restore BP handler registers */
-    *pEsf = gdb_regs.regs;
+    gdb_arch_regs_to_esf(&gdb_regs, (NANO_ESF *) exc_regs);
 
     if ((mode == GDB_EXC_TRACE) || (mode == GDB_EXC_BP))
 	gdb_stop_by_bp = 0;
@@ -2063,7 +2090,7 @@ static void gdb_ctrl_loop (void)
 #else 
 		    /* Handle single step request for for runcontrol CPU */
 
-		    gdb_trace_lock_key = gdb_trace_mode_set (&gdb_regs.regs);
+		    gdb_trace_lock_key = gdb_trace_mode_set (&gdb_regs);
 #endif /* DBG_NO_SINGLE_STEP */
 		return;
 		}
@@ -2087,7 +2114,7 @@ static void gdb_ctrl_loop (void)
 *
 */
 
-static void gdb_system_stop (NANO_ESF * esf, int sig)
+static void gdb_system_stop (NANO_ISF * regs, int sig)
     {
     int oldlevel = irq_lock();
 
@@ -2096,8 +2123,12 @@ static void gdb_system_stop (NANO_ESF * esf, int sig)
     else gdb_cpu_stop_signal = GDB_SIG_INT; /* Stopped by a command */
 
     /* Save registers */
-    if (esf != NULL)
-	gdb_regs.regs = *esf;
+    if (regs == GDB_INVALID_REG_SET) gdb_regs_not_valid = 1;
+    else {
+	if (regs == NULL) regs = sys_debug_current_isf_get();
+	gdb_regs.regs = *regs;
+	gdb_regs_not_valid = 0;
+    }
 
     /* A GDB event is pending */
     gdb_event_is_pending = 1;
@@ -2105,6 +2136,9 @@ static void gdb_system_stop (NANO_ESF * esf, int sig)
     /* Transfer control to the control loop */
     gdb_ctrl_loop ();
 
+    /* Load registers */
+    if (!gdb_regs_not_valid) *regs = gdb_regs.regs;
+
     /* Resume system if not a single step request */
     gdb_system_resume ();
 
@@ -2121,7 +2155,7 @@ int gdb_instruction_set(void *addr, char *instruction, size_t size)
 	return 0;
 }
 
-#ifdef CONFIG_CONSOLE_HANDLER
+#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
     if (ch == GDB_STOP_CHAR) {
 	int oldlevel = irq_lock();
@@ -2140,18 +2174,18 @@ static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
 }
 #endif
 
-void gdb_system_stop_here (void * esf) {
+void gdb_system_stop_here (void * regs) {
     int oldlevel = irq_lock();
 
-#ifdef CONFIG_CONSOLE_HANDLER
+#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
     uart_irq_rx_disable(UART_CONSOLE_DEV);
     uart_irq_tx_disable(UART_CONSOLE_DEV);
     uart_irq_err_disable(UART_CONSOLE_DEV);
 #endif
 
-    gdb_system_stop ((NANO_ESF *) esf, GDB_SIG_STOP);
+    gdb_system_stop ((NANO_ISF *) regs, GDB_SIG_STOP);
 
-#ifdef CONFIG_CONSOLE_HANDLER
+#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
     uart_irq_rx_enable(UART_CONSOLE_DEV);
     uart_irq_tx_enable(UART_CONSOLE_DEV);
     uart_irq_err_enable(UART_CONSOLE_DEV);
@@ -2165,13 +2199,18 @@ static int init_gdb_server(struct device *unused) {
 
     if (!gdb_is_initialized) {
 	gdb_arch_init();
-#ifdef CONFIG_CONSOLE_HANDLER
+#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 	nano_fifo_init(&cmds_queue);
 	nano_fifo_init(&avail_queue);
 	uart_irq_input_hook_set(UART_CONSOLE_DEV, gdb_irq_input_hook);
 	uart_register_input(&avail_queue, &cmds_queue);
 #endif
+#ifdef CONFIG_MEM_SAFE_NUM_EXTRA_REGIONS
+	(void)sys_mem_safe_region_add((void *) 0x100000, 256*1024, SYS_MEM_SAFE_READ);
+	(void)sys_mem_safe_region_add((void *) 0x100000, 256*1024, SYS_MEM_SAFE_WRITE);
+#endif
         gdb_is_initialized = 1;
+	gdb_system_stop_here(GDB_INVALID_REG_SET);
     }
     return 0;
 }
-- 
1.9.1


From d3b3e9702c7445a43ed518f8da169d94c26c9bab Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Thu, 14 Jan 2016 14:32:30 -0500
Subject: [PATCH 24/82] GDB: Added support for reboot command

It is now possible to reboot the target from a GDB client if the
CONFIG_REBOOT component is included.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index fbbc03e..632a9ae 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -373,6 +373,9 @@ Notification Packets:
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 #include <console/uart_console.h>
 #endif
+#ifdef CONFIG_REBOOT
+#include <misc/reboot.h>
+#endif
 
 /* defines */
 
@@ -397,6 +400,9 @@ Notification Packets:
 #ifdef GDB_ARCH_HAS_CPUID
 #define STR_QWR_CPUID   ";qwr.cpuid+"
 #endif
+#ifdef CONFIG_REBOOT
+#define STR_REBOOT      ";reboot+"
+#endif
 
 /* typedef */
  
@@ -687,6 +693,35 @@ static unsigned char * mem2hex
 
 /*******************************************************************************
 *
+* gdb_strncat - concatenate characters from one string to another
+*
+* This routine appends up to <n> characters from string <src> to the
+* end of string <dst>.
+*
+* RETURNS: N/A
+*/
+
+static void gdb_strncat
+    (
+    char *	 dst,  	/* string to append to */
+    const char * src,   /* string to append */
+    size_t	 n     	/* max no. of characters to append */
+    )
+    {
+    if (n != 0)
+	{
+	while (*dst++ != '\0')			/* find end of string */
+	    ;
+	dst--;					/* rewind back of \0 */
+	while (((*dst++ = *src++) != '\0') && (--n > 0))
+	    ;
+	}
+    *dst = '\0';			/* NULL terminate string */
+    return;
+    }
+
+/*******************************************************************************
+*
 * gdb_mem_probe -
 *
 * This routine probe
@@ -1011,11 +1046,7 @@ static void write_xml_string (char * outBuf, const char * xml_string,
     {
     size_t max_length = strlen (xml_string);
     if (offset == max_length) {
-        /* XXX rlp - No strncat support - quick workaround
-         * strncat ((char *)outBuf, "l", length - 1); */
-    	size_t len = strlen ((char *)outBuf);
-    	*(outBuf + len) = 'l';
-    	*(outBuf + len + 1) = '\0';
+        gdb_strncat ((char *)outBuf, "l", length - 1);
     }
     else if (offset > max_length)
         OUTBUF_FILL ("E00");
@@ -1254,6 +1285,9 @@ int gdb_protocol_parse (unsigned char * ptr)
                 break;
                 }
             case 'k':   /* kill but do not kill here */
+#ifdef  CONFIG_REBOOT
+                sys_reboot(SYS_REBOOT_COLD);
+#endif
             case 'D':   /* detach  */
                 {
                 OUTBUF_FILL (STUB_OK);
@@ -1411,17 +1445,21 @@ int gdb_protocol_parse (unsigned char * ptr)
 #endif
                     size -= (strlen ((char *)outBuf) + 1);
 #ifdef GDB_ARCH_HAS_VMCS
-                    strncat ((char *)outBuf, STR_QWR_VMCS, size);
+                    gdb_strncat ((char *)outBuf, STR_QWR_VMCS, size);
                     size -= sizeof (STR_QWR_VMCS);
 #endif
 #ifdef GDB_ARCH_HAS_EXTENDED_REGISTERS
-                    strncat ((char *)outBuf, STR_QWR_EREGS, size);
+                    gdb_strncat ((char *)outBuf, STR_QWR_EREGS, size);
                     size -= sizeof (STR_QWR_EREGS);
 #endif
 #ifdef GDB_ARCH_HAS_CPUID
-                    strncat ((char *)outBuf, STR_QWR_CPUID, size);
+                    gdb_strncat ((char *)outBuf, STR_QWR_CPUID, size);
                     size -= sizeof (STR_QWR_CPUID);
 #endif
+#ifdef STR_REBOOT
+                    gdb_strncat ((char *)outBuf, STR_REBOOT, size);
+                    size -= sizeof (STR_REBOOT);
+#endif
                     }
                 else if (strncmp ((const char *)ptr, "Xfer:features:read:", 19) == 0)
                     {
-- 
1.9.1


From 0f04ff3fa8697934c3024d4929ed05859090d5f3 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Thu, 14 Jan 2016 15:03:54 -0500
Subject: [PATCH 25/82] gdb: retrieve the correct ESP value during exception
 handling

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index 3b5033c..05951b3 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -92,7 +92,10 @@ void gdb_arch_regs_from_esf (GDB_REG_SET * regs, NANO_ESF *esf) {
 	    regs->regs.ecx = esf->ecx;
 	    regs->regs.edx = esf->edx;
 	    regs->regs.ebx = esf->ebx;
-	    regs->regs.esp = esf->esp;
+	    /* NANO_ESF does not contain the correct value for ESP. We have
+	     * to compute it from the NANO_ESF pointer.
+	     */
+	    regs->regs.esp = ((unsigned long) esf + (sizeof(NANO_ESF) - 8));
 	    regs->regs.ebp = esf->ebp;
 	    regs->regs.esi = esf->esi;
 	    regs->regs.edi = esf->edi;
@@ -119,7 +122,10 @@ void gdb_arch_regs_to_esf (GDB_REG_SET * regs, NANO_ESF *esf) {
 	    esf->ecx = regs->regs.ecx;
 	    esf->edx = regs->regs.edx;
 	    esf->ebx = regs->regs.ebx;
-	    esf->esp = regs->regs.esp;
+	    /* Since NANO_ESF does not contain the correct value for ESP,
+	     * we do not restore it.
+	     */
+	    /*esf->esp = regs->regs.esp;*/
 	    esf->ebp = regs->regs.ebp;
 	    esf->esi = regs->regs.esi;
 	    esf->edi = regs->regs.edi;
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 632a9ae..5d93b31 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -2155,6 +2155,9 @@ static void gdb_ctrl_loop (void)
 static void gdb_system_stop (NANO_ISF * regs, int sig)
     {
     int oldlevel = irq_lock();
+#ifdef CONFIG_X86_32
+    int old_esp = 0;
+#endif
 
     gdb_debug_status = DEBUGGING;
     if (sig != 0) gdb_cpu_stop_signal = sig;
@@ -2165,6 +2168,13 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
     else {
 	if (regs == NULL) regs = sys_debug_current_isf_get();
 	gdb_regs.regs = *regs;
+#ifdef CONFIG_X86_32
+        /* NANO_ISF does not contain the correct value for ESP. We have
+	 * to compute it from the NANO_ISF pointer.
+	 */
+	old_esp = regs->esp;
+	gdb_regs.regs.esp = ((unsigned long) regs + (sizeof(NANO_ISF) - 8));
+#endif
 	gdb_regs_not_valid = 0;
     }
 
@@ -2175,7 +2185,12 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
     gdb_ctrl_loop ();
 
     /* Load registers */
-    if (!gdb_regs_not_valid) *regs = gdb_regs.regs;
+    if (!gdb_regs_not_valid) {
+	*regs = gdb_regs.regs;
+#ifdef CONFIG_X86_32
+	regs->esp = old_esp;
+#endif
+    }
 
     /* Resume system if not a single step request */
     gdb_system_resume ();
-- 
1.9.1


From edc22763dfbc5bc875f207f748e79f3cd23eed6c Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Thu, 14 Jan 2016 15:05:53 -0500
Subject: [PATCH 26/82] gdb: force CONFIG_REBOOT, have INTERRUPT_DRIVEN depend
 on GDB_SERVER

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/Kconfig b/misc/debug/Kconfig
index 57ddd7f..9fd4025 100644
--- a/misc/debug/Kconfig
+++ b/misc/debug/Kconfig
@@ -85,6 +85,7 @@ config	GDB_SERVER
 	bool
 	prompt "GDB Server [EXPERIMENTAL]"
 	default n
+	select REBOOT if PLATFORM_GALILEO
 	help
 	This option enables the GDB Server support.
 
@@ -92,6 +93,7 @@ config	GDB_SERVER_INTERRUPT_DRIVEN
 	bool
 	prompt "Interrupt driver GDB Server support"
 	default y
+	depends on GDB_SERVER
 	select CONSOLE_HANDLER
 	help
 	This option enables interrupt support for GDB Server.
-- 
1.9.1


From e3daacd7ca8dabba7824aa058dbd0d1b8aef8117 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Thu, 14 Jan 2016 15:42:32 -0500
Subject: [PATCH 27/82] gdb: Add a configuration parameter to tag the
 bootloader

CONFIG_GDB_SERVER_BOOTLOADER configuration parameter must be enabled ag
the GDB Server as a GDB Server bootloader

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/Kconfig b/misc/debug/Kconfig
index 9fd4025..997ef76 100644
--- a/misc/debug/Kconfig
+++ b/misc/debug/Kconfig
@@ -83,25 +83,32 @@ config DEBUG_INFO
 
 config	GDB_SERVER
 	bool
-	prompt "GDB Server [EXPERIMENTAL]"
+	prompt "Enable GDB Server [EXPERIMENTAL]"
 	default n
 	select REBOOT if PLATFORM_GALILEO
 	help
 	This option enables the GDB Server support.
 
+config GDB_SERVER_MAX_SW_BP
+	int "Maximum number of GDB Server Software breakpoints"
+	default 100
+	depends on GDB_SERVER
+	help
+	This option specifies the maximum number of Software breakpoints
+
 config	GDB_SERVER_INTERRUPT_DRIVEN
 	bool
-	prompt "Interrupt driver GDB Server support"
+	prompt "Enable GDB interrupt mode"
 	default y
 	depends on GDB_SERVER
 	select CONSOLE_HANDLER
 	help
 	This option enables interrupt support for GDB Server.
 
-config GDB_SERVER_MAX_SW_BP
-	int
-	prompt "Maximum number of GDB server software breakpoints"
-	default 100
+config	GDB_SERVER_BOOTLOADER
+	bool
+	prompt "Enable the bootloader mode"
+	default n
 	depends on GDB_SERVER
 	help
-	This option specifies the maximum number of software breakpoints
+	This option enables the bootloader mode of the GDB Server.
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 5d93b31..63a5b4a 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -403,6 +403,11 @@ Notification Packets:
 #ifdef CONFIG_REBOOT
 #define STR_REBOOT      ";reboot+"
 #endif
+#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+#define STR_TYPE      ";type=zephyr_boot"
+#else
+#define STR_TYPE      ";type=zephyr"
+#endif
 
 /* typedef */
  
@@ -444,7 +449,7 @@ static int gdb_is_connected = 0;	/* A client is connected to GDB Server */
 static int gdb_no_ack = 0;
 static int gdb_stop_by_bp = 0;
 static int gdb_trace_lock_key = 0;
-static int gdb_regs_not_valid = 0;
+static int gdb_regs_not_valid = 1;
 static volatile int gdb_event_is_pending = 0;
 static volatile int gdb_cpu_stop_signal;
 static volatile int gdb_cpu_pending_sig;
@@ -872,14 +877,16 @@ void gdb_post_event (void)
                         "T%02xthread:%02x", gdb_cpu_stop_signal, 1);
             ptr += count;
             bufSize -= count;
-            count = snprintf ((char *)ptr, bufSize, ";%x:", GDB_PC_REG);
-            ptr += count;
-            bufSize -= count;
-            gdb_arch_regs_get (&gdb_regs, (char *)tmp_reg_buffer);
-            gdb_arch_reg_info_get (GDB_PC_REG, &size, &offset);
-            savedPtr = ptr;
-            ptr = mem2hex (tmp_reg_buffer + offset, ptr, size, 1);
-            bufSize -= (ptr - savedPtr);
+            if (!gdb_regs_not_valid) {
+		count = snprintf ((char *)ptr, bufSize, ";%x:", GDB_PC_REG);
+		ptr += count;
+		bufSize -= count;
+		gdb_arch_regs_get (&gdb_regs, (char *)tmp_reg_buffer);
+		gdb_arch_reg_info_get (GDB_PC_REG, &size, &offset);
+		savedPtr = ptr;
+		ptr = mem2hex (tmp_reg_buffer + offset, ptr, size, 1);
+		bufSize -= (ptr - savedPtr);
+            }
 
             /* clear stop reason */
             gdb_cpu_stop_signal = GDB_SIG_NULL;
@@ -1460,6 +1467,8 @@ int gdb_protocol_parse (unsigned char * ptr)
                     gdb_strncat ((char *)outBuf, STR_REBOOT, size);
                     size -= sizeof (STR_REBOOT);
 #endif
+                    gdb_strncat ((char *)outBuf, STR_TYPE, size);
+                    size -= sizeof (STR_TYPE);
                     }
                 else if (strncmp ((const char *)ptr, "Xfer:features:read:", 19) == 0)
                     {
-- 
1.9.1


From 219a51c94740c133821d7c47188c6f2ef230b009 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Thu, 14 Jan 2016 15:44:55 -0500
Subject: [PATCH 28/82] gdb: increase Server buffer size for bootloader

This commit increases the size of the GDB Server buffer size (from to
8192) to speed up the load of the application image.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 63a5b4a..c012859 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -382,7 +382,11 @@ Notification Packets:
 #define STUB_OK "OK"
 #define STUB_ERROR "ENN"
 
-#define GDB_BUF_SIZE    600      /* Default GDB buffer size */
+#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+#define GDB_BUF_SIZE    8192	/* Default GDB buffer size */
+#else
+#define GDB_BUF_SIZE    600	/* Default GDB buffer size */
+#endif
 
 #define MAX_SW_BP       CONFIG_GDB_SERVER_MAX_SW_BP     /* Maximum number of software breakpoints */
 
-- 
1.9.1


From 7b4f16aaa62ca484d0940ad90c498fbb29770206 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Thu, 14 Jan 2016 15:51:42 -0500
Subject: [PATCH 29/82] debug: add missing dependency for mem_safe choice of
 implementations

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/Kconfig b/misc/debug/Kconfig
index 997ef76..8c81375 100644
--- a/misc/debug/Kconfig
+++ b/misc/debug/Kconfig
@@ -30,6 +30,7 @@ config MEM_SAFE
 
 choice
 prompt "Safe memory access implementation"
+depends on MEM_SAFE
 default MEM_SAFE_CHECK_BOUNDARIES
 
 config MEM_SAFE_CHECK_BOUNDARIES
-- 
1.9.1


From a0a87cf8bc08b2b70a97990fa12d1ed373dd875b Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Thu, 14 Jan 2016 16:10:36 -0500
Subject: [PATCH 30/82] gdb: fix component dependency issues

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/Kconfig b/misc/debug/Kconfig
index 8c81375..9afc6bc 100644
--- a/misc/debug/Kconfig
+++ b/misc/debug/Kconfig
@@ -86,7 +86,8 @@ config	GDB_SERVER
 	bool
 	prompt "Enable GDB Server [EXPERIMENTAL]"
 	default n
-	select REBOOT if PLATFORM_GALILEO
+	select REBOOT
+	select MEM_SAFE
 	help
 	This option enables the GDB Server support.
 
-- 
1.9.1


From 40dffe4d6fbe335084adfaaa4445e8f665ed36c2 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Thu, 14 Jan 2016 16:13:25 -0500
Subject: [PATCH 31/82] gdb: remove single access register support

In order to speed up debugging from a remote server, we disable the
support for reading/writing a single register. The whole set of
registers is retrieved in one shot and cached for late use.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index c012859..3670018 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -1533,6 +1533,8 @@ int gdb_protocol_parse (unsigned char * ptr)
                 OUTBUF_FILL (STUB_OK);
                 break;
                 }
+
+#ifdef GDB_HAS_SINGLE_REG_ACCESS
             case 'P':                /* Pn..=r.. -- Write register */
                 {
                 int regNum = 0;
@@ -1588,6 +1590,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                 mem2hex (tmp_reg_buffer + offset, outBuf, size, 1);
                 break;
                 }
+#endif /* GDB_HAS_SINGLE_REG_ACCESS */
 
             case 'm':                                /* Read Memory */
                 {                               /* m<addr>,<length> */
-- 
1.9.1


From 5527b5c0f115e2c313347e2846346764433c69ce Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Thu, 14 Jan 2016 16:16:09 -0500
Subject: [PATCH 32/82] gdb: squash with micro sample


diff --git a/samples/microkernel/apps/gdb_server/prj_x86.conf b/samples/microkernel/apps/gdb_server/prj_x86.conf
index 4e7a4c9..53183e3 100644
--- a/samples/microkernel/apps/gdb_server/prj_x86.conf
+++ b/samples/microkernel/apps/gdb_server/prj_x86.conf
@@ -1,4 +1,3 @@
 # Use standard security profile. (=> no need for a random number generator)
-CONFIG_ENHANCED_SECURITY=n
 CONFIG_GDB_SERVER=y
 CONFIG_COMPILER_OPT="-O0 -g"
-- 
1.9.1


From f336a9c30b978f0b374477689d9d39ae78c23a2e Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Thu, 14 Jan 2016 16:16:29 -0500
Subject: [PATCH 33/82] gdb: squash with nano sample


diff --git a/samples/nanokernel/apps/gdb_server/prj.conf b/samples/nanokernel/apps/gdb_server/prj.conf
index 4e7a4c9..53183e3 100644
--- a/samples/nanokernel/apps/gdb_server/prj.conf
+++ b/samples/nanokernel/apps/gdb_server/prj.conf
@@ -1,4 +1,3 @@
 # Use standard security profile. (=> no need for a random number generator)
-CONFIG_ENHANCED_SECURITY=n
 CONFIG_GDB_SERVER=y
 CONFIG_COMPILER_OPT="-O0 -g"
-- 
1.9.1


From d012fc05785ef78d09b034da474f1b032246101c Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Thu, 14 Jan 2016 16:18:58 -0500
Subject: [PATCH 34/82] gdb: use CONFIG_RAM_SIZE macro to configure memory safe
 regions

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 3670018..96e47f9 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -2275,8 +2275,8 @@ static int init_gdb_server(struct device *unused) {
 	uart_register_input(&avail_queue, &cmds_queue);
 #endif
 #ifdef CONFIG_MEM_SAFE_NUM_EXTRA_REGIONS
-	(void)sys_mem_safe_region_add((void *) 0x100000, 256*1024, SYS_MEM_SAFE_READ);
-	(void)sys_mem_safe_region_add((void *) 0x100000, 256*1024, SYS_MEM_SAFE_WRITE);
+	(void)sys_mem_safe_region_add((void *) 0x100000, CONFIG_RAM_SIZE*1024, SYS_MEM_SAFE_READ);
+	(void)sys_mem_safe_region_add((void *) 0x100000, CONFIG_RAM_SIZE*1024, SYS_MEM_SAFE_WRITE);
 #endif
         gdb_is_initialized = 1;
 	gdb_system_stop_here(GDB_INVALID_REG_SET);
-- 
1.9.1


From ec1e6494864533349623d9563c433669b66db678 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Fri, 15 Jan 2016 11:41:40 -0500
Subject: [PATCH 35/82] isf: merge with ISF implementation


diff --git a/arch/x86/core/i386_sysV_abi/intstub.S b/arch/x86/core/i386_sysV_abi/intstub.S
index fb4255b..839d189 100644
--- a/arch/x86/core/i386_sysV_abi/intstub.S
+++ b/arch/x86/core/i386_sysV_abi/intstub.S
@@ -134,10 +134,13 @@ SECTION_FUNC(TEXT, _IntEnt)
 	 * required by debug tools.
 	 */
 
-	push	%edi
-	push	%esi
-	push	%ebx
-	push	%ebp
+	pushl	%edi
+	pushl	%esi
+	pushl	%ebx
+	pushl	%ebp
+
+	leal	44(%esp), %ecx   /* Calculate ESP before interrupt occurred */
+	pushl	%ecx             /* Save calculated ESP */
 #endif
 
 #ifdef CONFIG_INT_LATENCY_BENCHMARK
@@ -360,6 +363,7 @@ BRANCH_LABEL(_IntExit)
 	popl	%esp		/* switch back to kernel stack */
 
 #ifdef CONFIG_DEBUG_INFO
+	popl	%ebp        /* Discard saved ESP */
 	popl	%ebp
 	popl	%ebx
 	popl	%esi
@@ -434,6 +438,7 @@ BRANCH_LABEL(nestedInterrupt)
 #endif
 
 #ifdef CONFIG_DEBUG_INFO
+	popl	%ebp        /* Discard saved ESP */
 	popl	%ebp
 	popl	%ebx
 	popl	%esi
diff --git a/include/arch/x86/arch.h b/include/arch/x86/arch.h
index 1a5057b..f196329 100644
--- a/include/arch/x86/arch.h
+++ b/include/arch/x86/arch.h
@@ -329,10 +329,16 @@ typedef struct nanoEsf {
  *
  * The interrupt stack frame includes the volatile registers EAX, ECX, and EDX
  * pushed on the stack by _IntEnt().
+ *
+ * The host-based debug tools such as GDB do not require the 5 non-volatile
+ * registers (EDI, ESI, EBX, EBP and ESP) to be preserved during an interrupt.
+ * The register values saved/restored by _Swap() called from _IntExit() are
+ * sufficient.
  */
 
 typedef struct nanoIsf {
 #ifdef CONFIG_DEBUG_INFO
+	unsigned int esp;
 	unsigned int ebp;
 	unsigned int ebx;
 	unsigned int esi;
-- 
1.9.1


From 93152c6ed14d9a96e1ec99bfa24f8f3cdd2dcdc4 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 11:46:36 -0500
Subject: [PATCH 36/82] gdb: update to follow NANO_ESF and NANO_ISF structure
 changes

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index 05951b3..d0ac7d5 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -92,17 +92,13 @@ void gdb_arch_regs_from_esf (GDB_REG_SET * regs, NANO_ESF *esf) {
 	    regs->regs.ecx = esf->ecx;
 	    regs->regs.edx = esf->edx;
 	    regs->regs.ebx = esf->ebx;
-	    /* NANO_ESF does not contain the correct value for ESP. We have
-	     * to compute it from the NANO_ESF pointer.
-	     */
-	    regs->regs.esp = ((unsigned long) esf + (sizeof(NANO_ESF) - 8));
+	    regs->regs.esp = esf->esp;
 	    regs->regs.ebp = esf->ebp;
 	    regs->regs.esi = esf->esi;
 	    regs->regs.edi = esf->edi;
 	    regs->regs.eip = esf->eip;
 	    regs->regs.eflags = esf->eflags;
 	    regs->regs.cs = esf->cs;
-	    regs->regs.ss = esf->ss;
 }
 
 /**
@@ -122,17 +118,13 @@ void gdb_arch_regs_to_esf (GDB_REG_SET * regs, NANO_ESF *esf) {
 	    esf->ecx = regs->regs.ecx;
 	    esf->edx = regs->regs.edx;
 	    esf->ebx = regs->regs.ebx;
-	    /* Since NANO_ESF does not contain the correct value for ESP,
-	     * we do not restore it.
-	     */
-	    /*esf->esp = regs->regs.esp;*/
+	    esf->esp = regs->regs.esp;
 	    esf->ebp = regs->regs.ebp;
 	    esf->esi = regs->regs.esi;
 	    esf->edi = regs->regs.edi;
 	    esf->eip = regs->regs.eip;
 	    esf->eflags = regs->regs.eflags;
 	    esf->cs = regs->regs.cs;
-	    esf->ss = regs->regs.ss;
 }
 
 /**
@@ -170,8 +162,6 @@ void gdb_arch_regs_get (GDB_REG_SET * regs, char * buffer) {
     *((uint32_t *)buffer) = regs->regs.eflags;
     buffer += 4;
     *((uint32_t *)buffer) = regs->regs.cs;
-    buffer += 4;
-    *((uint32_t *)buffer) = regs->regs.ss;
 }
 
 /**
@@ -209,8 +199,6 @@ void gdb_arch_regs_set (GDB_REG_SET * regs,  char * buffer) {
     regs->regs.eflags = *((uint32_t *)buffer);
     buffer += 4;
     regs->regs.cs = *((uint32_t *)buffer);
-    buffer += 4;
-    regs->regs.ss = *((uint32_t *)buffer);
 }
 
 /**
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 96e47f9..8f5b246 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -2171,9 +2171,6 @@ static void gdb_ctrl_loop (void)
 static void gdb_system_stop (NANO_ISF * regs, int sig)
     {
     int oldlevel = irq_lock();
-#ifdef CONFIG_X86_32
-    int old_esp = 0;
-#endif
 
     gdb_debug_status = DEBUGGING;
     if (sig != 0) gdb_cpu_stop_signal = sig;
@@ -2184,13 +2181,6 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
     else {
 	if (regs == NULL) regs = sys_debug_current_isf_get();
 	gdb_regs.regs = *regs;
-#ifdef CONFIG_X86_32
-        /* NANO_ISF does not contain the correct value for ESP. We have
-	 * to compute it from the NANO_ISF pointer.
-	 */
-	old_esp = regs->esp;
-	gdb_regs.regs.esp = ((unsigned long) regs + (sizeof(NANO_ISF) - 8));
-#endif
 	gdb_regs_not_valid = 0;
     }
 
@@ -2203,9 +2193,6 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
     /* Load registers */
     if (!gdb_regs_not_valid) {
 	*regs = gdb_regs.regs;
-#ifdef CONFIG_X86_32
-	regs->esp = old_esp;
-#endif
     }
 
     /* Resume system if not a single step request */
-- 
1.9.1


From 566941b6bb09f1072faebf60fd29d0444f59c3fc Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 13:11:06 -0500
Subject: [PATCH 37/82] gdb: fix to print GDB control characters (e.g %,$,...)
 on stdout

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/drivers/console/uart_console.c b/drivers/console/uart_console.c
index 221fea7..6cd4429 100644
--- a/drivers/console/uart_console.c
+++ b/drivers/console/uart_console.c
@@ -42,6 +42,10 @@
 #include <atomic.h>
 #include <misc/printk.h>
 
+#ifdef CONFIG_GDB_SERVER
+#include <debug/gdb_server.h>
+#endif
+
 static struct device *uart_console_dev;
 
 #if 0 /* NOTUSED */
@@ -77,6 +81,9 @@ static int console_in(void)
 
 static int console_out(int c)
 {
+#ifdef CONFIG_GDB_SERVER
+	if (gdb_console_out (c)) return c;
+#endif
 	uart_poll_out(uart_console_dev, (unsigned char)c);
 	if ('\n' == c) {
 		uart_poll_out(uart_console_dev, (unsigned char)'\r');
diff --git a/include/misc/debug/gdb_server.h b/include/misc/debug/gdb_server.h
index a41cda1..46e5149 100644
--- a/include/misc/debug/gdb_server.h
+++ b/include/misc/debug/gdb_server.h
@@ -75,7 +75,7 @@ extern volatile int gdb_debug_status;
 
 extern void gdb_system_stop_here (void * regs);
 extern void gdb_handler (int mode, void * pEsf, int signal);
-
+extern int gdb_console_out (char val);
 
 #endif /* _ASMLANGUAGE */
 
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 8f5b246..9f95066 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -388,6 +388,12 @@ Notification Packets:
 #define GDB_BUF_SIZE    600	/* Default GDB buffer size */
 #endif
 
+#ifndef GDB_NOTIF_DATA_SIZE
+#define GDB_NOTIF_DATA_SIZE     100     /* Size of notification data buffers */
+#endif
+#define NOTIF_PACKET_OVERHEAD   6       /* Overhead size for notification */
+                                        /* packet encoding. */
+
 #define MAX_SW_BP       CONFIG_GDB_SERVER_MAX_SW_BP     /* Maximum number of software breakpoints */
 
 #define GDB_INVALID_REG_SET	((void *)-1)
@@ -457,6 +463,8 @@ static int gdb_regs_not_valid = 1;
 static volatile int gdb_event_is_pending = 0;
 static volatile int gdb_cpu_stop_signal;
 static volatile int gdb_cpu_pending_sig;
+static volatile int gdb_notif_pkt_pending = 0;
+static volatile int gdb_notif_data_idx;
 static GDB_REG_SET gdb_regs;
 
 static const char * xml_target_header = "<?xml version=\"1.0\"?> " \
@@ -467,6 +475,9 @@ static unsigned char outBuf [GDB_BUF_SIZE];
 static unsigned char inBuf [GDB_BUF_SIZE];
 static unsigned char tmp_buffer [GDB_BUF_SIZE];
 static unsigned char tmp_reg_buffer [GDBNUMREGBYTES];
+static unsigned char gdb_notif_packet[GDB_BUF_SIZE];
+static unsigned char gdb_notif_data[GDB_NOTIF_DATA_SIZE];
+
 
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static struct nano_fifo avail_queue;
@@ -502,6 +513,10 @@ static void gdb_ctrl_loop (void);
 static void gdb_system_stop (NANO_ISF * reg, int sig);
 static void gdb_system_resume (void);
 
+static void gdb_notif_handle (void);
+static void gdb_notif_flush_request (void);
+static uint32_t gdb_console_write (char *buf, uint32_t len);
+
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static int gdb_irq_input_hook (struct device * dev, uint8_t ch);
 #endif
@@ -853,6 +868,169 @@ static int putPacket(unsigned char * buffer)
         } while (1);
     }
 
+/*******************************************************************************
+*
+* gdb_notif_flush_request - request a GDB Notification Packet flush
+*
+* This routine requests a flush of pending notification packets. This is done
+* by setting gdb_notif_pkt_pending to 1 before stopping the CPU. Once stopped,
+* the control loop will send pending packets before resuming the system.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+static void gdb_notif_flush_request (void)
+    {
+    /*
+     * Before stopping CPU we must indicate that we're stopping the
+     * system to handle a packet notification. During the packet notification,
+     * we should prevent CPU from reading protocol...
+     */
+
+    gdb_notif_pkt_pending = 1;
+    gdb_debug_status = DEBUGGING;
+    gdb_ctrl_loop ();
+    gdb_system_resume ();
+    }
+
+/*******************************************************************************
+*
+* gdb_console_write - write data to debug agent console
+*
+* This routine writes data to debug agent console. For performance reason, the
+* data is bufferized until we receive a carriage return character or until
+* the buffer gets full.
+*
+* The buffer is also automatically flushed when system is stopped.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+static uint32_t gdb_console_write (char *buf, uint32_t len) {
+    uint32_t ix;
+    unsigned char ch;
+    int lock_key = irq_lock();
+
+    /* Copy data to notification buffer for current CPU */
+    for (ix = 0; ix < len; ix++) {
+	ch = buf[ix];
+	gdb_notif_data[gdb_notif_data_idx++] = ch;
+
+	if ((gdb_notif_data_idx == GDB_NOTIF_DATA_SIZE) ||
+	    (ch == '\n') || (ch == '\r')) {
+	    /*
+	     * If the notification buffer for current CPU is full, or if we
+	     * found a new line or carriage return character, then we must
+	     * flush received data to remote client.
+	     */
+
+	    gdb_notif_data[gdb_notif_data_idx] = '\0';
+	    gdb_notif_flush_request ();
+	}
+    }
+    irq_unlock (lock_key);
+    return (len);
+}
+
+/*******************************************************************************
+*
+* gdb_notif_handle - handle notification packet
+*
+* This routine handles pending notification packets for the CPU. It is invoked
+* while running in GDB CPU control loop (When system is stopped).
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+static void gdb_notif_handle (void) {
+    char * name = "WrCons";
+    unsigned char checksum = 0;
+    int	write_ix = 0;
+    int	name_ix= 0;
+    int	buffer_ix= 0;
+    unsigned char ch;
+    int more_data = 0;
+    uint32_t remaining_notif_packet_size;
+    uint32_t gdb_notif_data_size;
+    uint32_t mem2hexsize;
+    unsigned char * ptr;
+
+    /* First, check if there is pending data */
+
+    if (gdb_notif_data[0] == '\0') return;
+
+again:
+    write_ix = 0;
+    name_ix = 0;
+    more_data = 0;
+
+    /* * Build notification packet.
+     * A notification packet has the form `%<data>#<checksum>', where data
+     * is the content of the notification, and checksum is a checksum of
+     * data, computed and formatted as for ordinary gdb packets. A
+     * notification's data never contains `$', `%' or `#' characters. Upon
+     * receiving a notification, the recipient sends no `+' or `-' to
+     * acknowledge the notification's receipt or to report its corruption.
+     * 
+     * Every notification's data begins with a name, which contains no colon
+     * characters, followed by a colon character.
+     */
+    gdb_notif_packet[write_ix++] = '%';
+
+    /* Add name to notification packet */ 
+    while ((ch = name[name_ix++])) {
+	gdb_notif_packet[write_ix++] = ch;
+	checksum += ch;
+    }
+
+    /* Name must be followed by a colon character. */
+    gdb_notif_packet[write_ix++] = ':';
+    checksum += ':';
+
+    /*
+     * Add data to notification packet.
+     * Warning: The mem2hex() encoding double the size of the data,
+     * so mem2hex() must not be called with a size higher than the
+     * remaining room in gdb_notif_packet[] divided by 2.
+     */
+    remaining_notif_packet_size = GDB_BUF_SIZE - (strlen (name) + NOTIF_PACKET_OVERHEAD);
+    gdb_notif_data_size =  strlen ((char *)&gdb_notif_data[buffer_ix]);
+    if (gdb_notif_data_size <= (remaining_notif_packet_size / 2))
+	mem2hexsize = gdb_notif_data_size;
+    else {
+	mem2hexsize = remaining_notif_packet_size / 2;
+	more_data = 1;	/* Not enough room in notif packet */
+    }
+
+    /* Use mem2hex() to encode data using hex values */
+    ptr = mem2hex (&gdb_notif_data[buffer_ix], &gdb_notif_packet[write_ix], mem2hexsize, 0);
+    buffer_ix += mem2hexsize;
+    write_ix += (ptr - &gdb_notif_packet[write_ix]);
+
+    /* Terminate packet with #<checksum> */
+    gdb_notif_packet[write_ix++] = '#';
+    gdb_notif_packet[write_ix++] = hexchars[(checksum >> 4)]; 
+    gdb_notif_packet[write_ix++] = hexchars[(checksum & 0xf)];
+
+    /* Send packet */
+    putDebugString (gdb_notif_packet, write_ix);
+
+    if (more_data) goto again;
+
+    /* Clear buffer & index */
+    gdb_notif_data[0] = '\0';
+    gdb_notif_data_idx = 0;
+}
+
 void gdb_post_event (void)
     {
     int async_stop = 0;
@@ -2115,8 +2293,7 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
 *
 */
 
-static void gdb_ctrl_loop (void)
-    {
+static void gdb_ctrl_loop (void) {
     char ch;
 
     /* uninstall breakpoints. */
@@ -2125,13 +2302,25 @@ static void gdb_ctrl_loop (void)
     /* Flush input buffer */
     while (uart_poll_in (UART_CONSOLE_DEV, &ch) == 0);
     while (gdb_debug_status != NOT_DEBUGGING) {
-        unsigned char * ptr;
+	unsigned char * ptr;
+
+	/*  Check if system has been stopped to handle a notification packet:
+	 * If a notification is pending (gdb_notif_pkt_pending), but no stop
+	 * signal has been set.
+	 */
+
+	if ((gdb_cpu_stop_signal == GDB_SIG_NULL) && gdb_notif_pkt_pending) {
+	    gdb_notif_handle ();
+	    /* Mark packet notification as done */
+	    gdb_notif_pkt_pending = 0;
+	    break;
+	}
 
         ptr = gdb_protocol_get_packet (inBuf, GDB_BUF_SIZE);
         if (ptr != NULL)
             gdb_protocol_parse (ptr);
 
-	    if (gdb_debug_status == SINGLE_STEP) {
+	if (gdb_debug_status == SINGLE_STEP) {
 #if DBG_NO_SINGLE_STEP
             GDB_INSTR dbgBreakInsn = DBG_BREAK_INST;
 
@@ -2142,13 +2331,13 @@ static void gdb_ctrl_loop (void)
             (void)CACHE_TEXT_LOCAL_UPDATE (gdbStepEmuNextPc, sizeof (GDB_INSTR));
             gdb_trace_lock_key = intRegsLock (&gdb_regs.regs);
 #else 
-		    /* Handle single step request for for runcontrol CPU */
+	    /* Handle single step request for for runcontrol CPU */
 
-		    gdb_trace_lock_key = gdb_trace_mode_set (&gdb_regs);
+	    gdb_trace_lock_key = gdb_trace_mode_set (&gdb_regs);
 #endif /* DBG_NO_SINGLE_STEP */
-		return;
-		}
+	    return;
 	}
+    }
 }
 
 /*******************************************************************************
@@ -2211,6 +2400,29 @@ int gdb_instruction_set(void *addr, char *instruction, size_t size)
 	return 0;
 }
 
+/*******************************************************************************
+*
+* gdb_console_out - wrapper to send a character to console
+*
+* This routine is a specific wrapper to send a character to console.
+* If the GDB Server is started, this routine intercepts the data and transfer
+* it to the connected debug clients using a GDB notification packet.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*/
+
+int gdb_console_out (char val)
+    {
+    /*
+     * If remote debug client is connected, then transfer data to remote
+     * client. Otherwise, discard this character.
+     */
+    if (gdb_is_connected) gdb_console_write (&val, 1);
+    return 1;
+    }
+
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
     if (ch == GDB_STOP_CHAR) {
-- 
1.9.1


From b44cec562fe04577abf68244db55d96c6337641e Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Fri, 15 Jan 2016 13:19:29 -0500
Subject: [PATCH 38/82] gdb: squash with previous


diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 9f95066..cec5241 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -2413,15 +2413,17 @@ int gdb_instruction_set(void *addr, char *instruction, size_t size)
 * ERRNO: N/A
 */
 
-int gdb_console_out (char val)
-    {
-    /*
-     * If remote debug client is connected, then transfer data to remote
-     * client. Otherwise, discard this character.
-     */
-    if (gdb_is_connected) gdb_console_write (&val, 1);
-    return 1;
-    }
+int gdb_console_out (char val) {
+	/*
+	 * If remote debug client is connected, then transfer data to remote
+	 * client. Otherwise, discard this character.
+	 */
+	if (gdb_is_connected) {
+		gdb_console_write (&val, 1);
+		return 1;
+	}
+	return 0;
+}
 
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
-- 
1.9.1


From 1614f538353617eaef34536fac6fd16577e060ed Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 13:12:39 -0500
Subject: [PATCH 39/82] gdb: include all registers in the event message

In order to optimize the number of GDB requests, all register values
are now part of the event message.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index d0ac7d5..43e575d 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -214,11 +214,11 @@ void gdb_arch_regs_set (GDB_REG_SET * regs,  char * buffer) {
 
 void gdb_arch_reg_info_get (int reg_id, int * size, int * offset) {
     /* Determine register size */
-    if (reg_id >= 0 && reg_id < 16)
+    if (reg_id >= 0 && reg_id < GDBNUMREGS)
         *size = 4;
 
     /* Determine register offset */
-    if (reg_id >= 0 && reg_id < 16)
+    if (reg_id >= 0 && reg_id < GDBNUMREGS)
         *offset = 4 * reg_id;
 }
 
diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
index 705de60..0fdf1f1 100644
--- a/arch/x86/include/debug/gdb_arch.h
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -42,10 +42,12 @@ extern "C" {
 /* define */
 
 #define GDB_ARCH_HAS_WRCONS
+#define GDB_ARCH_HAS_ALL_REGS
 
 #define GDB_TGT_ARCH    "i386"
 
-#define GDBNUMREGBYTES  (16*4)
+#define GDBNUMREGS	(16)
+#define GDBNUMREGBYTES  (GDBNUMREGS*4)
 
 #define GDB_PC_REG      8
 
@@ -61,6 +63,11 @@ typedef unsigned char GDB_INSTR;
 typedef struct
     {
     NANO_ISF regs;
+    unsigned int pad1;	/* padding for ss register */
+    unsigned int pad2;	/* padding for ds register */
+    unsigned int pad3;	/* padding for es register */
+    unsigned int pad4;	/* padding for fs register */
+    unsigned int pad5;	/* padding for gs register */
     } GDB_REG_SET;
 
 /* function declaration */
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index cec5241..d335c33 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -1046,8 +1046,10 @@ void gdb_post_event (void)
         size_t bufSize = GDB_BUF_SIZE;
         if (gdb_cpu_stop_signal != GDB_SIG_NULL)
             {
+#ifndef GDB_ARCH_HAS_ALL_REGS
             int offset = 0;
             int size = 4;
+#endif
             int count;
             unsigned char * savedPtr;
             if (ptr != outBuf)
@@ -1060,14 +1062,23 @@ void gdb_post_event (void)
             ptr += count;
             bufSize -= count;
             if (!gdb_regs_not_valid) {
+		gdb_arch_regs_get (&gdb_regs, (char *)tmp_reg_buffer);
+#ifdef GDB_ARCH_HAS_ALL_REGS
+		count = snprintf ((char *)ptr, bufSize, ";regs:");
+		ptr += count;
+		bufSize -= count;
+		savedPtr = ptr;
+		ptr = mem2hex (tmp_reg_buffer, ptr, sizeof(gdb_regs), 1);
+		bufSize -= (ptr - savedPtr);
+#else
 		count = snprintf ((char *)ptr, bufSize, ";%x:", GDB_PC_REG);
 		ptr += count;
 		bufSize -= count;
-		gdb_arch_regs_get (&gdb_regs, (char *)tmp_reg_buffer);
 		gdb_arch_reg_info_get (GDB_PC_REG, &size, &offset);
 		savedPtr = ptr;
 		ptr = mem2hex (tmp_reg_buffer + offset, ptr, size, 1);
 		bufSize -= (ptr - savedPtr);
+#endif
             }
 
             /* clear stop reason */
-- 
1.9.1


From b1518d8eef80ff9708a4107f26ff8f19ef277f75 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 13:21:57 -0500
Subject: [PATCH 40/82] gdb/x86: adjusts the initial stack frame created by
 _new_thread()

This commit adjusts the initial stack frame created by _new_thread()
such that the GDB stack frame unwinders recognize it as the outermost
frame in the thread's stack.

GDB normally stops unwinding a stack when it detects that it has reached
a function called main().  Kernel tasks, however, do not have a main()
function, and there does not appear to be a simple way of stopping the
unwinding of the stack.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/core/i386_sysV_abi/thread.c b/arch/x86/core/i386_sysV_abi/thread.c
index 5337fb9..883b649 100644
--- a/arch/x86/core/i386_sysV_abi/thread.c
+++ b/arch/x86/core/i386_sysV_abi/thread.c
@@ -41,10 +41,10 @@ tNANO _nanokernel = {0};
 
 /* forward declaration */
 
-#ifdef CONFIG_GDB_INFO
+#if defined(CONFIG_GDB_INFO) || defined(CONFIG_GDB_SERVER)
 void _thread_entry_wrapper(_thread_entry_t, _thread_arg_t,
 			   _thread_arg_t, _thread_arg_t);
-#endif /* CONFIG_GDB_INFO */
+#endif
 
 /**
  *
@@ -191,7 +191,7 @@ static void _new_thread_internal(char *pStackMem, unsigned stackSize,
 	_nano_timeout_tcs_init(tcs);
 }
 
-#ifdef CONFIG_GDB_INFO
+#if defined(CONFIG_GDB_INFO) || defined(CONFIG_GDB_SERVER)
 /**
  *
  * @brief Adjust stack before invoking _thread_entry
@@ -255,7 +255,7 @@ __asm__("\t.globl _thread_entry\n"
 				    */
 	"\tmovl $0, (%esp)\n" /* zero initialEFLAGS location */
 	"\tjmp _thread_entry\n");
-#endif /* CONFIG_GDB_INFO */
+#endif /* defined(CONFIG_GDB_INFO) || defined(CONFIG_GDB_SERVER) */
 
 /**
  *
@@ -312,7 +312,7 @@ void _new_thread(char *pStackMem, unsigned stackSize, _thread_entry_t pEntry,
 
 	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
 
-#ifdef CONFIG_GDB_INFO
+#if defined(CONFIG_GDB_INFO) || defined(CONFIG_GDB_SERVER)
 
 	/*
 	 * Arrange for the _thread_entry_wrapper() function to be called
@@ -321,11 +321,11 @@ void _new_thread(char *pStackMem, unsigned stackSize, _thread_entry_t pEntry,
 
 	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
 
-#else /* CONFIG_GDB_INFO */
+#else /* defined(CONFIG_GDB_INFO) || defined(CONFIG_GDB_SERVER) */
 
 	*--pInitialThread = (unsigned long)_thread_entry;
 
-#endif /* CONFIG_GDB_INFO */
+#endif /* defined(CONFIG_GDB_INFO) || defined(CONFIG_GDB_SERVER) */
 
 	/*
 	 * note: stack area for edi, esi, ebx, ebp, and eax registers can be
-- 
1.9.1


From 4444dfb69633744863dc9200a42855b7a2546943 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 13:27:43 -0500
Subject: [PATCH 41/82] gdb: make server more robust when application displays
 a lot of messages

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index d335c33..196ec5d 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -461,7 +461,7 @@ static int gdb_stop_by_bp = 0;
 static int gdb_trace_lock_key = 0;
 static int gdb_regs_not_valid = 1;
 static volatile int gdb_event_is_pending = 0;
-static volatile int gdb_cpu_stop_signal;
+static volatile int gdb_cpu_stop_signal = GDB_SIG_NULL;
 static volatile int gdb_cpu_pending_sig;
 static volatile int gdb_notif_pkt_pending = 0;
 static volatile int gdb_notif_data_idx;
@@ -1154,12 +1154,12 @@ unsigned char * gdb_protocol_get_packet(unsigned char * buffer, size_t size)
             {
             if (!gdb_event_is_pending)
                 return NULL;
-                
+
             /* ignore other chars than GDB break character */
             if ((ch == GDB_STOP_CHAR) || gdb_event_is_pending)
                     gdb_post_event ();
             }
-        
+
         checksum = 0;
 
         /*****************************************************
@@ -2306,12 +2306,19 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
 
 static void gdb_ctrl_loop (void) {
     char ch;
-
     /* uninstall breakpoints. */
     gdb_bps_uninstall ();
 
     /* Flush input buffer */
-    while (uart_poll_in (UART_CONSOLE_DEV, &ch) == 0);
+    while (uart_poll_in (UART_CONSOLE_DEV, &ch) == 0) {
+        if (ch == GDB_STOP_CHAR) {
+            gdb_debug_status = DEBUGGING;
+            gdb_cpu_stop_signal = GDB_SIG_INT;
+            gdb_event_is_pending = 1;
+            break;
+        }
+    }
+
     while (gdb_debug_status != NOT_DEBUGGING) {
 	unsigned char * ptr;
 
@@ -2319,7 +2326,6 @@ static void gdb_ctrl_loop (void) {
 	 * If a notification is pending (gdb_notif_pkt_pending), but no stop
 	 * signal has been set.
 	 */
-
 	if ((gdb_cpu_stop_signal == GDB_SIG_NULL) && gdb_notif_pkt_pending) {
 	    gdb_notif_handle ();
 	    /* Mark packet notification as done */
-- 
1.9.1


From 071e181d4a07d68ebf76ff52d05228d45c475a57 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Fri, 15 Jan 2016 14:05:34 -0500
Subject: [PATCH 42/82] gdb: squash with gdb_instruction_set() implementation


diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 196ec5d..aa81ff5 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -2408,7 +2408,7 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
     }
 
 
-int gdb_instruction_set(void *addr, char *instruction, size_t size)
+static int gdb_instruction_set(void *addr, char *instruction, size_t size)
 {
 	if (sys_mem_safe_write_to_text_section(addr, instruction, size) < 0) {
 		return -EFAULT;
-- 
1.9.1


From 74c6858e44110c811870e97d1abf8b45ab33b1fe Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 14:19:19 -0500
Subject: [PATCH 43/82] gdb: abstract some values per-architecture

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
index 0fdf1f1..fdac4a3 100644
--- a/arch/x86/include/debug/gdb_arch.h
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -44,6 +44,19 @@ extern "C" {
 #define GDB_ARCH_HAS_WRCONS
 #define GDB_ARCH_HAS_ALL_REGS
 
+#ifndef CONFIG_GDB_RAM_SIZE
+#define CONFIG_GDB_RAM_SIZE	CONFIG_RAM_SIZE*1024
+#endif
+#ifndef CONFIG_GDB_RAM_ADDRESS
+#define CONFIG_GDB_RAM_ADDRESS	0x100000
+#endif
+
+#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+#define GDB_BUF_SIZE    8192   /* Default GDB buffer size */
+#else
+#define GDB_BUF_SIZE    600    /* Default GDB buffer size */
+#endif
+
 #define GDB_TGT_ARCH    "i386"
 
 #define GDBNUMREGS	(16)
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index aa81ff5..f97af40 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -382,12 +382,6 @@ Notification Packets:
 #define STUB_OK "OK"
 #define STUB_ERROR "ENN"
 
-#ifdef CONFIG_GDB_SERVER_BOOTLOADER
-#define GDB_BUF_SIZE    8192	/* Default GDB buffer size */
-#else
-#define GDB_BUF_SIZE    600	/* Default GDB buffer size */
-#endif
-
 #ifndef GDB_NOTIF_DATA_SIZE
 #define GDB_NOTIF_DATA_SIZE     100     /* Size of notification data buffers */
 #endif
@@ -506,7 +500,7 @@ static int putDebugString (unsigned char *str, int len);
 static void putDebugChar(unsigned char ch);
 static int getDebugChar (void);
 
-static int gdb_instruction_set(void *addr, char *instruction, size_t size);
+static int gdb_instruction_set(void *addr, GDB_INSTR *instruction, size_t size);
 
 static void gdb_post_event (void);
 static void gdb_ctrl_loop (void);
@@ -2408,12 +2402,14 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
     }
 
 
-static int gdb_instruction_set(void *addr, char *instruction, size_t size)
+static int gdb_instruction_set(void *addr, GDB_INSTR *instruction, size_t size)
 {
-	if (sys_mem_safe_write_to_text_section(addr, instruction, size) < 0) {
+	if (sys_mem_safe_write_to_text_section(addr, (char *) instruction, size) < 0) {
 		return -EFAULT;
 	}
+#ifndef	GDB_ARCH_NO_CACHE
 	sys_cache_flush((vaddr_t)addr, size);
+#endif	/* GDB_ARCH_NO_CACHE */
 	return 0;
 }
 
@@ -2493,8 +2489,8 @@ static int init_gdb_server(struct device *unused) {
 	uart_register_input(&avail_queue, &cmds_queue);
 #endif
 #ifdef CONFIG_MEM_SAFE_NUM_EXTRA_REGIONS
-	(void)sys_mem_safe_region_add((void *) 0x100000, CONFIG_RAM_SIZE*1024, SYS_MEM_SAFE_READ);
-	(void)sys_mem_safe_region_add((void *) 0x100000, CONFIG_RAM_SIZE*1024, SYS_MEM_SAFE_WRITE);
+	(void)sys_mem_safe_region_add((void *) CONFIG_GDB_RAM_ADDRESS, CONFIG_GDB_RAM_SIZE, SYS_MEM_SAFE_READ);
+	(void)sys_mem_safe_region_add((void *) CONFIG_GDB_RAM_ADDRESS, CONFIG_GDB_RAM_SIZE, SYS_MEM_SAFE_WRITE);
 #endif
         gdb_is_initialized = 1;
 	gdb_system_stop_here(GDB_INVALID_REG_SET);
-- 
1.9.1


From 504ad9f5153c6fe49af4bd61cf6680c6a1f1fe06 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 14:22:31 -0500
Subject: [PATCH 44/82] gdb/x86: fix single stepping over "special"
 instructions

Fix single stepping when trying to step some special instructions like
sti/cli/hlt on x86.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index 43e575d..8dea8e0 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -241,6 +241,24 @@ void gdb_trace_mode_clear (GDB_REG_SET * regs, int arg) {
 
 /**
  *
+ * @brief Test if single stepping is possible for current PC
+ *
+ * This routine indicates if step is possible for current PC
+ *
+ * @return 1 if it is possible to step the instruction; -1 otherwise
+ *
+ * \NOMANUAL
+ */
+
+int gdb_arch_can_step (GDB_REG_SET * regs) {
+    unsigned char * pc = (unsigned char *) regs->regs.eip;
+
+    if (*pc == 0xf4) return 0;         /* hlt instruction */
+    return (1);
+}
+
+/**
+ *
  * @brief Set trace mode
  *
  * This routine makes CPU trace-enable.
@@ -252,8 +270,11 @@ void gdb_trace_mode_clear (GDB_REG_SET * regs, int arg) {
 
 int gdb_trace_mode_set (GDB_REG_SET * regs) {
     int tmp;
+    unsigned char * pc = (unsigned char *) regs->regs.eip;
 
     tmp = regs->regs.eflags;
+    if (*pc == 0xfb) tmp |= INT_FLAG;   /* sti instruction */
+    if (*pc == 0xfa) tmp &= ~INT_FLAG;  /* cli instruction */
     regs->regs.eflags &= ~INT_FLAG;
     regs->regs.eflags |= TRACE_FLAG;
 
diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
index fdac4a3..21c57b0 100644
--- a/arch/x86/include/debug/gdb_arch.h
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -43,6 +43,7 @@ extern "C" {
 
 #define GDB_ARCH_HAS_WRCONS
 #define GDB_ARCH_HAS_ALL_REGS
+#define GDB_ARCH_CAN_STEP       gdb_arch_can_step
 
 #ifndef CONFIG_GDB_RAM_SIZE
 #define CONFIG_GDB_RAM_SIZE	CONFIG_RAM_SIZE*1024
@@ -93,6 +94,7 @@ extern void gdb_arch_regs_set (GDB_REG_SET * regs,  char * buffer);
 extern void gdb_arch_reg_info_get (int reg_id, int * size, int * offset);
 extern void gdb_trace_mode_clear (GDB_REG_SET * regs, int arg);
 extern int gdb_trace_mode_set (GDB_REG_SET * regs);
+extern int gdb_arch_can_step (GDB_REG_SET * regs);
 
 #endif /* _ASMLANGUAGE */
 
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index f97af40..2fc0dfa 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -884,9 +884,14 @@ static void gdb_notif_flush_request (void)
      * we should prevent CPU from reading protocol...
      */
 
+    
+    if (gdb_debug_status != NOT_DEBUGGING) {
+        return;
+    }
     gdb_notif_pkt_pending = 1;
     gdb_debug_status = DEBUGGING;
     gdb_ctrl_loop ();
+    gdb_debug_status = NOT_DEBUGGING;
     gdb_system_resume ();
     }
 
@@ -2331,6 +2336,16 @@ static void gdb_ctrl_loop (void) {
         if (ptr != NULL)
             gdb_protocol_parse (ptr);
 
+#ifdef GDB_ARCH_CAN_STEP
+        if (gdb_debug_status == SINGLE_STEP) {
+           if (!GDB_ARCH_CAN_STEP(&gdb_regs)) {
+                gdb_debug_status = DEBUGGING;
+                gdb_event_is_pending = 1;
+                gdb_cpu_stop_signal = GDB_SIG_TRAP;
+            }
+        }
+#endif /* GDB_ARCH_CAN_STEP */
+
 	if (gdb_debug_status == SINGLE_STEP) {
 #if DBG_NO_SINGLE_STEP
             GDB_INSTR dbgBreakInsn = DBG_BREAK_INST;
-- 
1.9.1


From 62b835e3bb4c82b8ab8d8cd7faafaf68d61f85a1 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 14:33:40 -0500
Subject: [PATCH 45/82] gdb: arch-specific abstractions and features

- abstract ISF/ESF access per-arch
- enabling/disabling of UART (disabled for ARM)
- abstract single-stepping

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index 8dea8e0..0e29173 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -34,6 +34,7 @@
 
 #include <nanokernel.h>
 #include <nano_private.h>
+#include <string.h>
 #include <debug/gdb_arch.h>
 #include <debug/gdb_server.h>
 
@@ -103,6 +104,22 @@ void gdb_arch_regs_from_esf (GDB_REG_SET * regs, NANO_ESF *esf) {
 
 /**
  *
+ * @brief Fill a GDB register set from a given ISF register set
+ *
+ * This routine fills the provided GDB register set with values from given
+ * NANO_ISF register set.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+void gdb_arch_regs_from_isf (GDB_REG_SET *regs, NANO_ISF *isf) {
+    memcpy(&regs->regs, isf, sizeof(regs->regs));
+}
+
+/**
+ *
  * @brief Fill an ESF register set from a given GDB register set
  *
  * This routine fills the provided NANO_ESF register set with values
@@ -129,6 +146,22 @@ void gdb_arch_regs_to_esf (GDB_REG_SET * regs, NANO_ESF *esf) {
 
 /**
  *
+ * @brief Fill an ISF register set from a given GDB register set
+ *
+ * This routine fills the provided NANO_ISF register set with values
+ * from given GDB register set.
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+void gdb_arch_regs_to_isf (GDB_REG_SET * regs, NANO_ISF *isf) {
+    memcpy(isf, &regs->regs, sizeof(NANO_ISF));
+}
+
+/**
+ *
  * @brief Fill given buffer from given register set
  *
  * This routine fills the provided buffer with values from given register set.
diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
index 21c57b0..2469da0 100644
--- a/arch/x86/include/debug/gdb_arch.h
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -89,6 +89,8 @@ typedef struct
 extern void gdb_arch_init (void);
 extern void gdb_arch_regs_from_esf (GDB_REG_SET * regs, NANO_ESF *esf);
 extern void gdb_arch_regs_to_esf (GDB_REG_SET * regs, NANO_ESF *esf);
+extern void gdb_arch_regs_from_isf (GDB_REG_SET * regs, NANO_ISF *esf);
+extern void gdb_arch_regs_to_isf (GDB_REG_SET * regs, NANO_ISF *esf);
 extern void gdb_arch_regs_get (GDB_REG_SET * regs, char * buffer) ;
 extern void gdb_arch_regs_set (GDB_REG_SET * regs,  char * buffer);
 extern void gdb_arch_reg_info_get (int reg_id, int * size, int * offset);
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 2fc0dfa..7d71eb9 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -485,10 +485,10 @@ static struct nano_fifo cmds_queue;
  */
 static BP_ARRAY bpArray[MAX_SW_BP];
 
-#if	DBG_NO_SINGLE_STEP
-LOCAL GDB_INSTR * gdbStepEmuNextPc;
-LOCAL GDB_INSTR gdbStepEmuInsn;
-#endif /* DBG_NO_SINGLE_STEP */
+#ifdef GDB_ARCH_NO_SINGLE_STEP
+static GDB_INSTR * gdb_step_emu_next_pc;
+static GDB_INSTR gdb_step_emu_insn;
+#endif /* GDB_ARCH_NO_SINGLE_STEP */
 
 /* global definitions */
 
@@ -515,12 +515,6 @@ static uint32_t gdb_console_write (char *buf, uint32_t len);
 static int gdb_irq_input_hook (struct device * dev, uint8_t ch);
 #endif
 
-#if	DBG_NO_SINGLE_STEP || DBG_STEP_AND_BP_SHARED_VEC
-static void gdb_trap_handler (int level, GDB_INSTR * pAddr, void * pInfo,
-			   REG_SET * pRegisters, void *	pDbgRegSet,
-			   BOOL hardware);
-#endif	/* DBG_NO_SINGLE_STEP */
-
 static int hex(unsigned char ch)
 {
         if ((ch >= 'a') && (ch <= 'f')) {
@@ -2175,39 +2169,6 @@ static void gdb_system_resume (void)
     gdb_bps_install ();
     }
 
-#if DBG_NO_SINGLE_STEP || DBG_STEP_AND_BP_SHARED_VEC
-/*******************************************************************************
-*
-* gdb_trap_handler - trap handler for emulated single step
-*
-* This trap handler is used to catch and handle the exceptions generated by
-* emulated single step.
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-*/
-
-static void gdb_trap_handler
-    (
-    int         level,
-    GDB_INSTR *	pAddr,
-    void *      pInfo,
-    REG_SET *   pRegisters,
-    void *	pDbgRegSet,
-    BOOL	hardware
-    )
-    {
-    if (gdb_debug_status == SINGLE_STEP) {
-    	gdb_trace_handler (level, pInfo, pRegisters);
-    	return;
-    }
-    
-    gdb_bp_handler (level, pInfo, pRegisters, pDbgRegSet, hardware);
-    }
-#endif	/* DBG_NO_SINGLE_STEP */
-
 /*******************************************************************************
 *
 * gdb_handler - stop mode agent BP/trace handler
@@ -2235,19 +2196,15 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
         /* No longer pending trace mode exception */
         gdb_debug_status = DEBUGGING;
 
-#if DBG_NO_SINGLE_STEP
+#ifdef GDB_ARCH_NO_SINGLE_STEP
         /* remove temporary breakpoint */
-
-        VM_CONTEXT_BUFFER_WRITE (NULL, &gdbStepEmuInsn,
-                                 gdbStepEmuNextPc, sizeof (GDB_INSTR));
-        (void)CACHE_TEXT_LOCAL_UPDATE (gdbStepEmuNextPc, sizeof (GDB_INSTR));
-
+	(void)gdb_instruction_set (gdb_step_emu_next_pc, &gdb_step_emu_insn, sizeof(GDB_INSTR));
         /* Disable trace mode */
-        intRegsUnlock (&gdb_regs.regs, gdb_trace_lock_key);
+	gdb_int_regs_unlock (&gdb_regs, gdb_trace_lock_key);
 #else
         /* Disable trace mode */
         gdb_trace_mode_clear (&gdb_regs, gdb_trace_lock_key);
-#endif /* DBG_NO_SINGLE_STEP */
+#endif /* GDB_ARCH_NO_SINGLE_STEP */
         }
 
     if ((mode == GDB_EXC_TRACE) || (mode == GDB_EXC_BP))
@@ -2267,9 +2224,11 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
 
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
     uart_irq_rx_enable(UART_CONSOLE_DEV);
+#ifndef CONFIG_ARM
     uart_irq_tx_enable(UART_CONSOLE_DEV);
     uart_irq_err_enable(UART_CONSOLE_DEV);
 #endif
+#endif
 
     /* Restore BP handler registers */
     gdb_arch_regs_to_esf(&gdb_regs, (NANO_ESF *) exc_regs);
@@ -2347,20 +2306,18 @@ static void gdb_ctrl_loop (void) {
 #endif /* GDB_ARCH_CAN_STEP */
 
 	if (gdb_debug_status == SINGLE_STEP) {
-#if DBG_NO_SINGLE_STEP
-            GDB_INSTR dbgBreakInsn = DBG_BREAK_INST;
-
-            gdbStepEmuNextPc = wdbDbgGetNpc(&gdb_regs.regs);
-            gdbStepEmuInsn = *gdbStepEmuNextPc;
-            VM_CONTEXT_BUFFER_WRITE (NULL, &dbgBreakInsn,
-                                     gdbStepEmuNextPc, sizeof (GDB_INSTR));
-            (void)CACHE_TEXT_LOCAL_UPDATE (gdbStepEmuNextPc, sizeof (GDB_INSTR));
-            gdb_trace_lock_key = intRegsLock (&gdb_regs.regs);
+#ifdef GDB_ARCH_NO_SINGLE_STEP
+            GDB_INSTR bp_instr = GDB_BREAK_INST;
+
+            gdb_step_emu_next_pc = gdb_get_next_pc(&gdb_regs);
+            gdb_step_emu_insn = *gdb_step_emu_next_pc;
+            (void)gdb_instruction_set (gdb_step_emu_next_pc, &bp_instr, sizeof(GDB_INSTR));
+            gdb_trace_lock_key = gdb_int_regs_lock (&gdb_regs);
 #else 
 	    /* Handle single step request for for runcontrol CPU */
 
 	    gdb_trace_lock_key = gdb_trace_mode_set (&gdb_regs);
-#endif /* DBG_NO_SINGLE_STEP */
+#endif /* GDB_ARCH_NO_SINGLE_STEP */
 	    return;
 	}
     }
@@ -2395,7 +2352,7 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
     if (regs == GDB_INVALID_REG_SET) gdb_regs_not_valid = 1;
     else {
 	if (regs == NULL) regs = sys_debug_current_isf_get();
-	gdb_regs.regs = *regs;
+	gdb_arch_regs_from_isf(&gdb_regs, regs);
 	gdb_regs_not_valid = 0;
     }
 
@@ -2407,7 +2364,7 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
 
     /* Load registers */
     if (!gdb_regs_not_valid) {
-	*regs = gdb_regs.regs;
+	gdb_arch_regs_to_isf(&gdb_regs,regs);
     }
 
     /* Resume system if not a single step request */
@@ -2422,9 +2379,7 @@ static int gdb_instruction_set(void *addr, GDB_INSTR *instruction, size_t size)
 	if (sys_mem_safe_write_to_text_section(addr, (char *) instruction, size) < 0) {
 		return -EFAULT;
 	}
-#ifndef	GDB_ARCH_NO_CACHE
 	sys_cache_flush((vaddr_t)addr, size);
-#endif	/* GDB_ARCH_NO_CACHE */
 	return 0;
 }
 
@@ -2463,8 +2418,10 @@ static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
 	uart_irq_err_disable(dev);
 	gdb_system_stop (NULL, 0);
 	uart_irq_rx_enable(dev);
+#ifndef CONFIG_ARM
 	uart_irq_tx_enable(dev);
 	uart_irq_err_enable(dev);
+#endif
 	irq_unlock(oldlevel);
 	return 1;
     }
@@ -2485,9 +2442,11 @@ void gdb_system_stop_here (void * regs) {
 
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
     uart_irq_rx_enable(UART_CONSOLE_DEV);
+#ifndef CONFIG_ARM
     uart_irq_tx_enable(UART_CONSOLE_DEV);
     uart_irq_err_enable(UART_CONSOLE_DEV);
 #endif
+#endif
 
     irq_unlock(oldlevel);
 }
-- 
1.9.1


From f56b1bac31111626d50317936780a312da0c4df2 Mon Sep 17 00:00:00 2001
From: Didier Brachet <didier.brachet@windriver.com>
Date: Fri, 15 Jan 2016 14:38:21 -0500
Subject: [PATCH 46/82] gdb: reduce the number of buffers used by GDB server

To reduce the footprint of GDB server, reduce the number of static
buffers it is using.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 7d71eb9..2409bd6 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -390,9 +390,9 @@ Notification Packets:
 
 #define MAX_SW_BP       CONFIG_GDB_SERVER_MAX_SW_BP     /* Maximum number of software breakpoints */
 
-#define GDB_INVALID_REG_SET	((void *)-1)
+#define GDB_INVALID_REG_SET     ((void *)-1)
 
-#define OUTBUF_FILL(x) strncpy ((char *)outBuf, x, GDB_BUF_SIZE - 1)
+#define OUTBUF_FILL(x) strncpy ((char *)gdb_buffer, x, GDB_BUF_SIZE - 1)
 
 #define STR_COMMA_SEPARATOR     ","
 #ifdef GDB_ARCH_HAS_VMCS
@@ -436,10 +436,10 @@ typedef enum gdb_error_code
 
 typedef struct
     {
-    GDB_INSTR * addr;	/* breakpoint address */
-    GDB_INSTR insn;		/* saved instruction */
-    char valid;			/* breakpoint is valid? */
-    char enabled;		/* breakpoint is enabled? */
+    GDB_INSTR * addr;   /* breakpoint address */
+    GDB_INSTR insn;     /* saved instruction */
+    char valid;         /* breakpoint is valid? */
+    char enabled;       /* breakpoint is enabled? */
     } BP_ARRAY;
 
 /* local definitions */
@@ -449,7 +449,7 @@ static const unsigned char hexchars[] = {
         '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
 };
 
-static int gdb_is_connected = 0;	/* A client is connected to GDB Server */
+static int gdb_is_connected = 0;        /* A client is connected to GDB Server */
 static int gdb_no_ack = 0;
 static int gdb_stop_by_bp = 0;
 static int gdb_trace_lock_key = 0;
@@ -465,11 +465,12 @@ static const char * xml_target_header = "<?xml version=\"1.0\"?> " \
                             "<!DOCTYPE target SYSTEM " \
                             "\"gdb-target.dtd\"> <target version=\"1.0\">\n";
 static const char * xml_target_footer = "</target>";
-static unsigned char outBuf [GDB_BUF_SIZE];
-static unsigned char inBuf [GDB_BUF_SIZE];
-static unsigned char tmp_buffer [GDB_BUF_SIZE];
+static unsigned char gdb_buffer [GDB_BUF_SIZE];
+#if defined(GDB_ARCH_HAS_VMCS) || defined(GDB_ARCH_HAS_EXTENDED_REGISTERS)
+static unsigned char tmp_reg_buffer [GDB_BUF_SIZE];
+#else
 static unsigned char tmp_reg_buffer [GDBNUMREGBYTES];
-static unsigned char gdb_notif_packet[GDB_BUF_SIZE];
+#endif
 static unsigned char gdb_notif_data[GDB_NOTIF_DATA_SIZE];
 
 
@@ -496,7 +497,6 @@ volatile int gdb_debug_status = NOT_DEBUGGING;
 
 /* forward static declarations */
 static int putPacket(unsigned char * buffer);
-static int putDebugString (unsigned char *str, int len);
 static void putDebugChar(unsigned char ch);
 static int getDebugChar (void);
 
@@ -608,9 +608,9 @@ static int get_hex_byte(unsigned char **ptrp)
 
 static unsigned char *put_hex_byte(unsigned char *ptr, int value)
 {
-        *ptr++ = hexchars[value >> 4];
-        *ptr++ = hexchars[value & 0xf];
-        return ptr;
+    *ptr++ = hexchars[value >> 4];
+    *ptr++ = hexchars[value & 0xf];
+    return ptr;
 }
 
 /*
@@ -619,49 +619,49 @@ static unsigned char *put_hex_byte(unsigned char *ptr, int value)
  */
 
 static unsigned char * compress(unsigned char * buf)
+    {
+    unsigned char * read_ptr = buf;
+    unsigned char * write_ptr = buf;
+    unsigned char        ch;
+    size_t  count = strlen ((char *)buf);
+    int max_repeat = 126 - 29;
+    size_t ix;
+
+    for (ix = 0; ix < count; ix++)
         {
-        unsigned char * read_ptr = buf;
-        unsigned char * write_ptr = buf;
-        unsigned char        ch;
-        size_t     count = strlen ((char *)buf);
-        int        max_repeat = 126 - 29;
-        size_t     ix;
-
-        for (ix = 0; ix < count; ix++)
-            {
-            int        num = 0;
-            int        jx;
+        int        num = 0;
+        int        jx;
 
-            ch = *read_ptr++;
-            *write_ptr++ = ch;
-            for (jx = 1; ((jx + ix) < count) && (jx < max_repeat); jx++)
-                    {
-                if (read_ptr[jx - 1] == ch)
-                    num ++;
-                else
-                    break;
-                }
-            if (num >= 3)
+        ch = *read_ptr++;
+        *write_ptr++ = ch;
+        for (jx = 1; ((jx + ix) < count) && (jx < max_repeat); jx++)
                 {
-                /*
-                 * It is not possible to use the '$', '#' and '%' characters to 
-                 * encode the size per gdb remote protocol specification. 
-                 * skip them.
-                 */
-
-                while (((num + 29) == '$') || ((num + 29) == '#') ||
-                       ((num + 29) == '%'))
-                    num--;
-
-                *write_ptr++ = '*';
-                *write_ptr++ = (unsigned char)(num + 29);
-                read_ptr += num;
-                ix += num;
-                }
+            if (read_ptr[jx - 1] == ch)
+                num ++;
+            else
+                break;
+            }
+        if (num >= 3)
+            {
+            /*
+             * It is not possible to use the '$', '#' and '%' characters to 
+             * encode the size per gdb remote protocol specification. 
+             * skip them.
+             */
+
+            while (((num + 29) == '$') || ((num + 29) == '#') ||
+                   ((num + 29) == '%'))
+                num--;
+
+            *write_ptr++ = '*';
+            *write_ptr++ = (unsigned char)(num + 29);
+            read_ptr += num;
+            ix += num;
             }
-        *write_ptr = 0;
-        return (write_ptr);
         }
+    *write_ptr = 0;
+    return (write_ptr);
+    }
 
 /*******************************************************************************
 *
@@ -715,20 +715,20 @@ static unsigned char * mem2hex
 
 static void gdb_strncat
     (
-    char *	 dst,  	/* string to append to */
+    char *       dst,   /* string to append to */
     const char * src,   /* string to append */
-    size_t	 n     	/* max no. of characters to append */
+    size_t       n      /* max no. of characters to append */
     )
     {
     if (n != 0)
-	{
-	while (*dst++ != '\0')			/* find end of string */
-	    ;
-	dst--;					/* rewind back of \0 */
-	while (((*dst++ = *src++) != '\0') && (--n > 0))
-	    ;
-	}
-    *dst = '\0';			/* NULL terminate string */
+        {
+        while (*dst++ != '\0')                  /* find end of string */
+            ;
+        dst--;                                  /* rewind back of \0 */
+        while (((*dst++ = *src++) != '\0') && (--n > 0))
+            ;
+        }
+    *dst = '\0';                        /* NULL terminate string */
     return;
     }
 
@@ -746,54 +746,54 @@ static void gdb_strncat
 
 static int gdb_mem_probe
     (
-    char *	addr,		/* address to test */
-    int		mode,		/* VX_READ or VX_WRITE */
-    int		size,		/* number of bytes to test */
-    int		width,
-    int	    preserve	/* preserve memory on write test? */
+    char *      addr,           /* address to test */
+    int         mode,           /* VX_READ or VX_WRITE */
+    int         size,           /* number of bytes to test */
+    int         width,
+    int         preserve        /* preserve memory on write test? */
     )
     {
-    long	dummy;		/* dummy variable */
+    long        dummy;          /* dummy variable */
 
-    if (size == 0)		/* memory length is null, test is done */
-	return (0);
+    if (size == 0)              /* memory length is null, test is done */
+        return (0);
 
     /* Validate parameters */
 
     if (mode == SYS_MEM_SAFE_READ)
-	preserve = 0;
+        preserve = 0;
 
     if (width == 0)
-	width = 1;
+        width = 1;
 
     /* Check width parameter */
 
     if ((width != 1) && (width != 2) && (width != 4))
-	return (-1);
+        return (-1);
 
     /* Check addr, size & width parameters coherency */
 
     if (((unsigned long) addr % width) || (size % width))
-	return (-1);
+        return (-1);
 
     /* Check first address */
 
     if ((preserve && (sys_mem_probe (addr, SYS_MEM_SAFE_READ, width,
-    		      (char *)&dummy) != 0)) ||
-	(sys_mem_probe (addr, mode, width, (char *)&dummy) != 0))
-	return (-1);
+                          (char *)&dummy) != 0)) ||
+        (sys_mem_probe (addr, mode, width, (char *)&dummy) != 0))
+        return (-1);
 
     /* Check if we have tested the whole memory */
 
     if (width == size)
-	return (0);
+        return (0);
 
     /* Check last address */
 
     addr = addr + size - width;
     if ((preserve &&
-	(sys_mem_probe (addr, SYS_MEM_SAFE_READ, width, (char *)&dummy) != 0)) ||
-	(sys_mem_probe (addr, mode, width, (char *)&dummy) != 0)) {
+        (sys_mem_probe (addr, SYS_MEM_SAFE_READ, width, (char *)&dummy) != 0)) ||
+        (sys_mem_probe (addr, mode, width, (char *)&dummy) != 0)) {
         return (-1);
     }
 
@@ -803,15 +803,13 @@ static int gdb_mem_probe
 static int putPacket(unsigned char * buffer)
     {
     unsigned char checksum = 0;
-    int        writeIx = 0;
     int        count = 0;
     unsigned char ch;
 
     /*  $<packet info>#<checksum>. */
     do
         {
-        writeIx = 0;
-        tmp_buffer[writeIx++] = '$';
+        putDebugChar ('$');
         checksum = 0;
         count = 0;
 
@@ -819,17 +817,14 @@ static int putPacket(unsigned char * buffer)
 
         while ((ch = buffer[count]))
             {
-            tmp_buffer[writeIx++] = ch;
+            putDebugChar(ch);
             checksum = (unsigned char) (checksum + ch);
             count += 1;
             }
-        tmp_buffer[writeIx++] = '#';
-        tmp_buffer[writeIx++] = hexchars[(checksum >> 4)]; 
-        tmp_buffer[writeIx++] = hexchars[(checksum & 0xf)];
-
-        /* Send packet */
 
-        (void)putDebugString (tmp_buffer, writeIx);
+        putDebugChar ('#');
+        putDebugChar (hexchars[(checksum >> 4)]); 
+        putDebugChar (hexchars[(checksum & 0xf)]);
 
         if (gdb_no_ack == 0)
             {
@@ -839,10 +834,10 @@ static int putPacket(unsigned char * buffer)
             if (ch == '+')
                 return 0;
             if (ch == '$')
-                    {
+                {
                 putDebugChar ('-');
                 return 0;
-                    }
+                }
             if (ch == GDB_STOP_CHAR)
                 {
                 gdb_cpu_stop_signal = GDB_SIG_INT;
@@ -912,20 +907,20 @@ static uint32_t gdb_console_write (char *buf, uint32_t len) {
 
     /* Copy data to notification buffer for current CPU */
     for (ix = 0; ix < len; ix++) {
-	ch = buf[ix];
-	gdb_notif_data[gdb_notif_data_idx++] = ch;
-
-	if ((gdb_notif_data_idx == GDB_NOTIF_DATA_SIZE) ||
-	    (ch == '\n') || (ch == '\r')) {
-	    /*
-	     * If the notification buffer for current CPU is full, or if we
-	     * found a new line or carriage return character, then we must
-	     * flush received data to remote client.
-	     */
-
-	    gdb_notif_data[gdb_notif_data_idx] = '\0';
-	    gdb_notif_flush_request ();
-	}
+        ch = buf[ix];
+        gdb_notif_data[gdb_notif_data_idx++] = ch;
+
+        if ((gdb_notif_data_idx == GDB_NOTIF_DATA_SIZE) ||
+            (ch == '\n') || (ch == '\r')) {
+            /*
+             * If the notification buffer for current CPU is full, or if we
+             * found a new line or carriage return character, then we must
+             * flush received data to remote client.
+             */
+
+            gdb_notif_data[gdb_notif_data_idx] = '\0';
+            gdb_notif_flush_request ();
+        }
     }
     irq_unlock (lock_key);
     return (len);
@@ -945,26 +940,19 @@ static uint32_t gdb_console_write (char *buf, uint32_t len) {
 */
 
 static void gdb_notif_handle (void) {
-    char * name = "WrCons";
+    const char * name = "WrCons";
     unsigned char checksum = 0;
-    int	write_ix = 0;
-    int	name_ix= 0;
-    int	buffer_ix= 0;
+    int ix = 0;
     unsigned char ch;
     int more_data = 0;
-    uint32_t remaining_notif_packet_size;
-    uint32_t gdb_notif_data_size;
-    uint32_t mem2hexsize;
-    unsigned char * ptr;
+    uint32_t max_packet_size;
+    uint32_t data_size;
+    unsigned char * ptr = gdb_notif_data;
 
     /* First, check if there is pending data */
 
     if (gdb_notif_data[0] == '\0') return;
-
 again:
-    write_ix = 0;
-    name_ix = 0;
-    more_data = 0;
 
     /* * Build notification packet.
      * A notification packet has the form `%<data>#<checksum>', where data
@@ -977,45 +965,51 @@ again:
      * Every notification's data begins with a name, which contains no colon
      * characters, followed by a colon character.
      */
-    gdb_notif_packet[write_ix++] = '%';
+    putDebugChar ('%');
+    checksum = 0;
 
     /* Add name to notification packet */ 
-    while ((ch = name[name_ix++])) {
-	gdb_notif_packet[write_ix++] = ch;
-	checksum += ch;
+    ix = 0;
+    while ((ch = name[ix++])) {
+        putDebugChar (ch);
+        checksum += ch;
     }
 
     /* Name must be followed by a colon character. */
-    gdb_notif_packet[write_ix++] = ':';
+    putDebugChar (':');
     checksum += ':';
 
     /*
      * Add data to notification packet.
-     * Warning: The mem2hex() encoding double the size of the data,
-     * so mem2hex() must not be called with a size higher than the
-     * remaining room in gdb_notif_packet[] divided by 2.
+     * Warning: The value to hex encoding double the size of the data,
+     * so we must not encode more than the remaining GDB buffer size
+     * divided by 2.
      */
-    remaining_notif_packet_size = GDB_BUF_SIZE - (strlen (name) + NOTIF_PACKET_OVERHEAD);
-    gdb_notif_data_size =  strlen ((char *)&gdb_notif_data[buffer_ix]);
-    if (gdb_notif_data_size <= (remaining_notif_packet_size / 2))
-	mem2hexsize = gdb_notif_data_size;
-    else {
-	mem2hexsize = remaining_notif_packet_size / 2;
-	more_data = 1;	/* Not enough room in notif packet */
+    max_packet_size = GDB_BUF_SIZE - (strlen (name) + NOTIF_PACKET_OVERHEAD);
+
+    data_size = strlen ((char *)ptr);
+    if (data_size <= (max_packet_size / 2)) {
+        more_data = 0;
+    } else {
+        data_size = max_packet_size / 2;
+        more_data = 1;        /* Not enough room in notif packet */
     }
 
-    /* Use mem2hex() to encode data using hex values */
-    ptr = mem2hex (&gdb_notif_data[buffer_ix], &gdb_notif_packet[write_ix], mem2hexsize, 0);
-    buffer_ix += mem2hexsize;
-    write_ix += (ptr - &gdb_notif_packet[write_ix]);
+    /* Encode data using hex values */
+    for (ix = 0; ix < data_size; ix++) {
+        ch = hexchars[(*ptr >> 4)];
+        putDebugChar (ch);
+        checksum += ch;
+        ch = hexchars[(*ptr & 0xf)];
+        putDebugChar (ch);
+        checksum += ch;
+        ptr++;
+    }
 
     /* Terminate packet with #<checksum> */
-    gdb_notif_packet[write_ix++] = '#';
-    gdb_notif_packet[write_ix++] = hexchars[(checksum >> 4)]; 
-    gdb_notif_packet[write_ix++] = hexchars[(checksum & 0xf)];
-
-    /* Send packet */
-    putDebugString (gdb_notif_packet, write_ix);
+    putDebugChar ('#');
+    putDebugChar (hexchars[(checksum >> 4)]); 
+    putDebugChar (hexchars[(checksum & 0xf)]);
 
     if (more_data) goto again;
 
@@ -1034,8 +1028,8 @@ void gdb_post_event (void)
         async_stop = 1;
         }
     if (async_stop)
-	{
-        unsigned char * ptr = outBuf;
+        {
+        unsigned char * ptr = gdb_buffer;
         size_t bufSize = GDB_BUF_SIZE;
         if (gdb_cpu_stop_signal != GDB_SIG_NULL)
             {
@@ -1045,7 +1039,7 @@ void gdb_post_event (void)
 #endif
             int count;
             unsigned char * savedPtr;
-            if (ptr != outBuf)
+            if (ptr != gdb_buffer)
                 {
                 *ptr++ = '|';
                 bufSize--;
@@ -1055,22 +1049,22 @@ void gdb_post_event (void)
             ptr += count;
             bufSize -= count;
             if (!gdb_regs_not_valid) {
-		gdb_arch_regs_get (&gdb_regs, (char *)tmp_reg_buffer);
+                gdb_arch_regs_get (&gdb_regs, (char *)tmp_reg_buffer);
 #ifdef GDB_ARCH_HAS_ALL_REGS
-		count = snprintf ((char *)ptr, bufSize, ";regs:");
-		ptr += count;
-		bufSize -= count;
-		savedPtr = ptr;
-		ptr = mem2hex (tmp_reg_buffer, ptr, sizeof(gdb_regs), 1);
-		bufSize -= (ptr - savedPtr);
+                count = snprintf ((char *)ptr, bufSize, ";regs:");
+                ptr += count;
+                bufSize -= count;
+                savedPtr = ptr;
+                ptr = mem2hex (tmp_reg_buffer, ptr, sizeof(gdb_regs), 1);
+                bufSize -= (ptr - savedPtr);
 #else
-		count = snprintf ((char *)ptr, bufSize, ";%x:", GDB_PC_REG);
-		ptr += count;
-		bufSize -= count;
-		gdb_arch_reg_info_get (GDB_PC_REG, &size, &offset);
-		savedPtr = ptr;
-		ptr = mem2hex (tmp_reg_buffer + offset, ptr, size, 1);
-		bufSize -= (ptr - savedPtr);
+                count = snprintf ((char *)ptr, bufSize, ";%x:", GDB_PC_REG);
+                ptr += count;
+                bufSize -= count;
+                gdb_arch_reg_info_get (GDB_PC_REG, &size, &offset);
+                savedPtr = ptr;
+                ptr = mem2hex (tmp_reg_buffer + offset, ptr, size, 1);
+                bufSize -= (ptr - savedPtr);
 #endif
             }
 
@@ -1080,11 +1074,11 @@ void gdb_post_event (void)
         *ptr = '\0';
         }
     else
-	{
-        (void)snprintf ((char *)outBuf, GDB_BUF_SIZE, "S%02x", GDB_SIG_INT);
-	}
+        {
+        (void)snprintf ((char *)gdb_buffer, GDB_BUF_SIZE, "S%02x", GDB_SIG_INT);
+        }
 
-    (void)putPacket (outBuf);
+    (void)putPacket (gdb_buffer);
     }
 
 /*******************************************************************************
@@ -1137,7 +1131,7 @@ static int getDebugChar (void)
 unsigned char * gdb_protocol_get_packet(unsigned char * buffer, size_t size)
     {
     unsigned char ch;
-    unsigned char * pBuf = buffer;
+    unsigned char * pBuf;
 
     unsigned char checksum;
 
@@ -1150,10 +1144,11 @@ unsigned char * gdb_protocol_get_packet(unsigned char * buffer, size_t size)
 
             /* ignore other chars than GDB break character */
             if ((ch == GDB_STOP_CHAR) || gdb_event_is_pending)
-                    gdb_post_event ();
+                gdb_post_event ();
             }
 
         checksum = 0;
+        pBuf = buffer;
 
         /*****************************************************
         * Continue reading characters until a '#' is found
@@ -1234,12 +1229,12 @@ unsigned char * gdb_protocol_get_packet(unsigned char * buffer, size_t size)
 * ERRNO: N/A
 */
 
-static void write_xml_string (char * outBuf, const char * xml_string,
+static void write_xml_string (char * buffer, const char * xml_string,
                                 int offset, int length) 
     {
     size_t max_length = strlen (xml_string);
     if (offset == max_length) {
-        gdb_strncat ((char *)outBuf, "l", length - 1);
+        gdb_strncat ((char *)buffer, "l", length - 1);
     }
     else if (offset > max_length)
         OUTBUF_FILL ("E00");
@@ -1248,15 +1243,15 @@ static void write_xml_string (char * outBuf, const char * xml_string,
         if ((offset + max_length) <= length)
             {
             /* we can read the full data */
-            outBuf[0] = 'l';
-            strncpy (&outBuf[1], xml_string + offset,
+            buffer[0] = 'l';
+            strncpy (&buffer[1], xml_string + offset,
                      (length <= GDB_BUF_SIZE-2) ? length : GDB_BUF_SIZE-2);
             }
         else
             {
-            outBuf[0] = 'm';
-            strncpy (&outBuf[1], xml_string + offset, GDB_BUF_SIZE-2);
-            outBuf[length+1] = '\0';
+            buffer[0] = 'm';
+            strncpy (&buffer[1], xml_string + offset, GDB_BUF_SIZE-2);
+            buffer[length+1] = '\0';
             }
         }
     }
@@ -1308,17 +1303,17 @@ static char * get_xml_target_description (void)
 * is supported on current architecture, and that debug registers are not full.
 *
 * <type> : GDB breakpoint type:
-*	0 : software breakpoint	(GDB_SOFT_BP)
-*	1 : hardware breakpoint	(GDB_HW_INST_BP)
-*	2 : write watchpoint	(GDB_HW_DATA_WRITE_BP)
-*	3 : read watchpoint	(GDB_HW_DATA_READ_BP)
-*	4 : access watchpoint	(GDB_HW_DATA_ACCESS_BP)
+*        0 : software breakpoint        (GDB_SOFT_BP)
+*        1 : hardware breakpoint        (GDB_HW_INST_BP)
+*        2 : write watchpoint        (GDB_HW_DATA_WRITE_BP)
+*        3 : read watchpoint        (GDB_HW_DATA_READ_BP)
+*        4 : access watchpoint        (GDB_HW_DATA_ACCESS_BP)
 *
 * <addr>     : breakpoint address.
 * <length>   : length is in bytes. For a software breakpoint, length specifies
 *              the size of the instruction to be patched. For hardware
-*	       breakpoints and watchpoints length specifies the memory
-*	       region to be monitored.
+*               breakpoints and watchpoints length specifies the memory
+*               region to be monitored.
 * <pErrCode> : ptr to error code if failed to add breakpoint.
 *
 * RETURNS: 0, or -1 if failed to add breakpoint.
@@ -1328,7 +1323,7 @@ static char * get_xml_target_description (void)
 */
 
 int gdb_bp_add (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCode) {
-    int	ix;
+    int ix;
 
     if (type != GDB_SOFT_BP) {
         *pErrCode = GDB_ERROR_HW_BP_NOT_SUP;
@@ -1341,15 +1336,15 @@ int gdb_bp_add (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCo
     /* Add software breakpoint to BP list */
 
     for (ix = 0; ix < MAX_SW_BP; ix++)
-    	{
-	    if (bpArray[ix].valid == 0)
-	        {
-	        bpArray[ix].valid = 1;
-	        bpArray[ix].enabled = 0;
-	        bpArray[ix].addr = (GDB_INSTR *) addr;
-		return (0);
-	        }
-	    }
+        {
+        if (bpArray[ix].valid == 0)
+            {
+            bpArray[ix].valid = 1;
+            bpArray[ix].enabled = 0;
+            bpArray[ix].addr = (GDB_INSTR *) addr;
+            return (0);
+            }
+        }
 
     *pErrCode = GDB_ERROR_BP_LIST_FULL;
     return -1;
@@ -1364,8 +1359,8 @@ int gdb_bp_add (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCo
 * RETURNS: 0, or -1 if failed to remove breakpoint.
 */
 
-int gdb_bp_delete (GDB_BP_TYPE type, long addr, int	length, GDB_ERROR_CODE * pErrCode) {
-    int	ix, jx;
+int gdb_bp_delete (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCode) {
+    int ix, jx;
 
     if (type != GDB_SOFT_BP)
         {
@@ -1374,29 +1369,29 @@ int gdb_bp_delete (GDB_BP_TYPE type, long addr, int	length, GDB_ERROR_CODE * pEr
         }
 
     for (ix = 0; ix < MAX_SW_BP; ix++) {
-	    if (bpArray[ix].valid == 1 &&
-	        bpArray[ix].addr == (GDB_INSTR *) addr) {
-	        bpArray[ix].valid = 0;	/* invalidate entry */
-
-	        /*
-	         * Make sure all valid entries are contiguous to speed up
-	         * breakpoint table parsing.
-	         */
-
-	        for (jx = ix + 1; jx < MAX_SW_BP; jx++) {
-		        if (bpArray[jx].valid == 1) {
-		            bpArray[jx - 1] = bpArray[jx];
-		            bpArray[jx].valid = 0;
-		        } else
-		            break;
-		    }
-	        return (0);
-	    } else if (bpArray[ix].valid == 0) {
-	        /* The first non valid entry in the table is the last entry */
-
-	        break;
-	    }
-	}
+        if (bpArray[ix].valid == 1 &&
+            bpArray[ix].addr == (GDB_INSTR *) addr) {
+            bpArray[ix].valid = 0;      /* invalidate entry */
+
+            /*
+             * Make sure all valid entries are contiguous to speed up
+             * breakpoint table parsing.
+             */
+
+            for (jx = ix + 1; jx < MAX_SW_BP; jx++) {
+                if (bpArray[jx].valid == 1) {
+                    bpArray[jx - 1] = bpArray[jx];
+                    bpArray[jx].valid = 0;
+                } else
+                    break;
+            }
+            return (0);
+        } else if (bpArray[ix].valid == 0) {
+            /* The first non valid entry in the table is the last entry */
+
+            break;
+        }
+    }
 
     *pErrCode = GDB_ERROR_INVALID_BP;
     return (-1);
@@ -1415,16 +1410,16 @@ int gdb_bp_delete (GDB_BP_TYPE type, long addr, int	length, GDB_ERROR_CODE * pEr
 */
 
 void gdb_bps_remove (void) {
-    int	ix;
+    int ix;
 
     for (ix = 0; ix < MAX_SW_BP; ix++)
-	{
-	/* First non valid entry in the table is the last entry */
+        {
+        /* First non valid entry in the table is the last entry */
 
-	if (bpArray[ix].valid == 0)
-	    break;
-	bpArray[ix].valid = 0;
-	}
+        if (bpArray[ix].valid == 0)
+            break;
+        bpArray[ix].valid = 0;
+        }
 }
 
 /*******************************************************************************
@@ -1444,12 +1439,11 @@ int gdb_protocol_parse (unsigned char * ptr)
     {
     unsigned char ch;
 #ifdef RESUME_AT_SUPPORT
-    long long     save_pc;
+    long long save_pc;
 #endif
-    int                no_ack = 0;
+    int no_ack = 0;
    
     ch = *ptr++;
-    outBuf[0] = '\0';
 
     switch (ch)
         {
@@ -1466,7 +1460,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                     gdb_no_ack = 0;
                     }
 
-                (void)snprintf ((char *)outBuf, GDB_BUF_SIZE,
+                (void)snprintf ((char *)gdb_buffer, GDB_BUF_SIZE,
                                 "T02thread:%02x;", 1);
 
                 /*
@@ -1480,6 +1474,8 @@ int gdb_protocol_parse (unsigned char * ptr)
             case 'k':   /* kill but do not kill here */
 #ifdef  CONFIG_REBOOT
                 sys_reboot(SYS_REBOOT_COLD);
+                OUTBUF_FILL (STUB_OK);
+                break;
 #endif
             case 'D':   /* detach  */
                 {
@@ -1497,7 +1493,10 @@ int gdb_protocol_parse (unsigned char * ptr)
                 int        thread;
 
                 if (!hex2int (&ptr, &thread))
+                    {
+                    gdb_buffer[0] = '\0';
                     break;
+                    }
                 if (thread != 1)
                     OUTBUF_FILL (STUB_ERROR);
                 else
@@ -1510,6 +1509,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                     {
                     gdb_no_ack = 1;
                     OUTBUF_FILL (STUB_OK);
+                    break;
                     }
 #ifdef GDB_ARCH_HAS_VMCS
                 else if (strncmp((const char *)ptr, "wr.vmcs:", 8) == 0)
@@ -1518,7 +1518,6 @@ int gdb_protocol_parse (unsigned char * ptr)
                     int regNum = 0;
                     int thread_id;
                     ptr += 8;
-                    OUTBUF_FILL (STUB_ERROR);
                     if (hex2int((unsigned char ** )&ptr, &thread_id) &&
                         *ptr++ == ',' &&
                         hex2llong ((unsigned char ** )&ptr, &addr) &&
@@ -1536,23 +1535,29 @@ int gdb_protocol_parse (unsigned char * ptr)
                                 OUTBUF_FILL (STUB_OK);
                                 }
                             }
+                        else
+                            OUTBUF_FILL (STUB_ERROR);
                         }
+                    else 
+                        OUTBUF_FILL (STUB_ERROR);
+                    break;
                     }
 #endif
+                gdb_buffer[0] = '\0';
                 break;
                 }
             case 'q':                                /* Query Packet */
                 {
                 if (ptr[0] == 'C')
                     {
-                    (void)snprintf ((char *)outBuf, GDB_BUF_SIZE, "QC%x", 1);
+                    (void)snprintf ((char *)gdb_buffer, GDB_BUF_SIZE, "QC%x", 1);
                     }
                 else if (strncmp((const char *)ptr, "wr.", 3) == 0) 
                     {
                     ptr += 3;
 #ifdef GDB_ARCH_HAS_VMCS
                     if (strncmp ((const char *)ptr, "vmcs:", 5) == 0) 
-                            {
+                        {
                         long long addr;
                         int regNum = 0;
                         int thread_id;
@@ -1567,19 +1572,20 @@ int gdb_protocol_parse (unsigned char * ptr)
                             int size;
                             size = gdb_arch_read_vmcs (thread_id - 1,
                                                         (void *) ((long)addr),
-                                                        regNum, tmp_buffer);
+                                                        regNum, tmp_reg_buffer);
                             if (size > 0)
-                                mem2hex (tmp_buffer, outBuf, size, 1);
+                                mem2hex (tmp_reg_buffer, gdb_buffer, size, 1);
                             else
                                 OUTBUF_FILL (STUB_ERROR);
                             }
                         else
                             OUTBUF_FILL (STUB_ERROR);
+                        break;
                         }
 #endif
 #ifdef GDB_ARCH_HAS_EXTENDED_REGISTERS
                     if (strncmp ((const char *)ptr, "eregs:", 6) == 0) 
-                            {
+                        {
                         int size = -1;
                         int regNum = 0;
 
@@ -1588,17 +1594,18 @@ int gdb_protocol_parse (unsigned char * ptr)
                             {
                             size = gdb_arch_read_extended_registers
                                                     (global_cpu, regNum,
-                                                    (char *)tmp_buffer);
+                                                    (char *)tmp_reg_buffer);
                             }
                         if (size > 0)
-                            mem2hex (tmp_buffer, outBuf, size, 1);
+                            mem2hex (tmp_reg_buffer, gdb_buffer, size, 1);
                         else
                             OUTBUF_FILL (STUB_ERROR);
+                        break;
                         }
 #endif
 #ifdef GDB_ARCH_HAS_CPUID
                     if (strncmp ((const char *)ptr, "cpuid:", 6) == 0) 
-                            {
+                        {
                         uint32_t arg1 = 0;
                         uint32_t arg2 = 0;
                         uint32_t res1 = 0;
@@ -1614,7 +1621,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                             {
                             if (gdb_arch_cpuid_get (arg1, arg2,
                                         &res1, &res2, &res3, &res4) == 0)
-                                (void)snprintf ((char *)outBuf, sizeof(outBuf),
+                                (void)snprintf ((char *)gdb_buffer, sizeof(gdb_buffer),
                                                 "%08x%08x%08x%08x",
                                                 res1, res2, res3, res4);
                             else
@@ -1622,38 +1629,40 @@ int gdb_protocol_parse (unsigned char * ptr)
                             }
                         else
                             OUTBUF_FILL (STUB_ERROR);
+                        break;
                         }
 #endif /* GDB_ARCH_HAS_CPUID */
+                    gdb_buffer[0] = '\0';
                     }
                 else if (strcmp ((const char *)ptr, "Supported") == 0)
                     {
                     size_t size = GDB_BUF_SIZE;
 
 #ifdef GDB_ARCH_HAS_WRCONS
-                    (void)snprintf ((char *)outBuf, size,
+                    (void)snprintf ((char *)gdb_buffer, size,
                                   "PacketSize=%x;qXfer:features:read+;QStartNoAckMode+;WrCons+", GDB_BUF_SIZE);
 #else
-                    (void)snprintf ((char *)outBuf, size,
+                    (void)snprintf ((char *)gdb_buffer, size,
                                   "PacketSize=%x;qXfer:features:read+;QStartNoAckMode+", GDB_BUF_SIZE);
 #endif
-                    size -= (strlen ((char *)outBuf) + 1);
+                    size -= (strlen ((char *)gdb_buffer) + 1);
 #ifdef GDB_ARCH_HAS_VMCS
-                    gdb_strncat ((char *)outBuf, STR_QWR_VMCS, size);
+                    gdb_strncat ((char *)gdb_buffer, STR_QWR_VMCS, size);
                     size -= sizeof (STR_QWR_VMCS);
 #endif
 #ifdef GDB_ARCH_HAS_EXTENDED_REGISTERS
-                    gdb_strncat ((char *)outBuf, STR_QWR_EREGS, size);
+                    gdb_strncat ((char *)gdb_buffer, STR_QWR_EREGS, size);
                     size -= sizeof (STR_QWR_EREGS);
 #endif
 #ifdef GDB_ARCH_HAS_CPUID
-                    gdb_strncat ((char *)outBuf, STR_QWR_CPUID, size);
+                    gdb_strncat ((char *)gdb_buffer, STR_QWR_CPUID, size);
                     size -= sizeof (STR_QWR_CPUID);
 #endif
 #ifdef STR_REBOOT
-                    gdb_strncat ((char *)outBuf, STR_REBOOT, size);
+                    gdb_strncat ((char *)gdb_buffer, STR_REBOOT, size);
                     size -= sizeof (STR_REBOOT);
 #endif
-                    gdb_strncat ((char *)outBuf, STR_TYPE, size);
+                    gdb_strncat ((char *)gdb_buffer, STR_TYPE, size);
                     size -= sizeof (STR_TYPE);
                     }
                 else if (strncmp ((const char *)ptr, "Xfer:features:read:", 19) == 0)
@@ -1670,27 +1679,31 @@ int gdb_protocol_parse (unsigned char * ptr)
                             hex2int (&ptr, &length) &&
                             *ptr == '\0') 
                             {
-                            write_xml_string ((char *) outBuf,
-                                                    get_xml_target_description(),
+                            write_xml_string ((char *) gdb_buffer,
+                                                get_xml_target_description(),
                                                 offset, length); 
-                                }
+                            }
                         else
                             OUTBUF_FILL (STUB_ERROR);
                         }
+                    else
+                        gdb_buffer[0] = '\0';
                     }
+                else 
+                    gdb_buffer[0] = '\0';
                 break;
                 }
 
 
             case 'g':                /* g -- Get Registers */
                 {
-		if (gdb_regs_not_valid)
+                if (gdb_regs_not_valid)
                     {
                     OUTBUF_FILL ("E02");
                     break;
                     }
                 (void)gdb_arch_regs_get (&gdb_regs,(char *)tmp_reg_buffer);
-                mem2hex (tmp_reg_buffer, outBuf, GDBNUMREGBYTES, 1);
+                mem2hex (tmp_reg_buffer, gdb_buffer, GDBNUMREGBYTES, 1);
                 break;
                 }
             case 'G':                /* GXX... -- Write Registers */
@@ -1698,7 +1711,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                 int i;
                 int value;
 
-		if (gdb_regs_not_valid)
+                if (gdb_regs_not_valid)
                     {
                     OUTBUF_FILL ("E02");
                     break;
@@ -1706,9 +1719,8 @@ int gdb_protocol_parse (unsigned char * ptr)
                 (void)gdb_arch_regs_get (&gdb_regs,
                                       (char *)tmp_reg_buffer);
                 for(i = 0; i < GDBNUMREGBYTES; i++) {
-                    if((value = get_hex_byte(&ptr)) < 0) {
+                    if((value = get_hex_byte(&ptr)) < 0)
                         break;
-                    }
                     tmp_reg_buffer[i] = (unsigned char) value;
                 }
                 gdb_arch_regs_set (&gdb_regs, (char *)tmp_reg_buffer);
@@ -1724,14 +1736,16 @@ int gdb_protocol_parse (unsigned char * ptr)
                 int size = 4;
                 int i, value;
 
-		if (gdb_regs_not_valid)
+                if (gdb_regs_not_valid)
                     {
                     OUTBUF_FILL ("E02");
                     break;
                     }
-                OUTBUF_FILL ("E02");
                 if (!hex2int (&ptr, &regNum) || *(ptr++) != '=')
+                    { 
+                    OUTBUF_FILL ("E02");
                     break;
+                    }
 
                 gdb_arch_regs_get (&gdb_regs,(char *)tmp_reg_buffer);
                 gdb_arch_reg_info_get (regNum, &size, &offset);
@@ -1742,8 +1756,11 @@ int gdb_protocol_parse (unsigned char * ptr)
                         break;
                     tmp_reg_buffer[offset+i] = (unsigned char)value;
                     }
-                if (i != size)
+                if (i != size) 
+                    {
+                    OUTBUF_FILL (STUB_ERROR);
                     break;
+                    }
                 gdb_arch_regs_set (&gdb_regs,(char *)tmp_reg_buffer);
                 OUTBUF_FILL (STUB_OK);
                 break;
@@ -1754,7 +1771,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                 int offset = 0;
                 int size = 4;
 
-		if (gdb_regs_not_valid)
+                if (gdb_regs_not_valid)
                     {
                     OUTBUF_FILL ("E02");
                     break;
@@ -1769,7 +1786,7 @@ int gdb_protocol_parse (unsigned char * ptr)
 
                 gdb_arch_regs_get (&gdb_regs, (char *)tmp_reg_buffer);
                 gdb_arch_reg_info_get (regNum, &size, &offset);
-                mem2hex (tmp_reg_buffer + offset, outBuf, size, 1);
+                mem2hex (tmp_reg_buffer + offset, gdb_buffer, size, 1);
                 break;
                 }
 #endif /* GDB_HAS_SINGLE_REG_ACCESS */
@@ -1779,18 +1796,26 @@ int gdb_protocol_parse (unsigned char * ptr)
                 long long addr;
                 int length;
 
-                OUTBUF_FILL ("E01");
                 if (hex2llong ((unsigned char ** )&ptr, &addr) == 0)
+                    {
+                    OUTBUF_FILL ("E01");
                     break;                
+                    }
 
-                if (! (*ptr++ == ',' && hex2int (&ptr, &length)))
+                if (!(*ptr++ == ',' && hex2int (&ptr, &length)))
+                    {
+                    OUTBUF_FILL ("E01");
                     break;
+                    }
 
                 if (gdb_mem_probe ((void *)((long)addr), SYS_MEM_SAFE_READ, length, 0, 1) == -1)
+                    {
+                    OUTBUF_FILL ("E01");
                     break;  /* No read access */
+                    }
 
                 /* Now read memory */
-                mem2hex((unsigned char *)((long)addr), outBuf, length, 1);
+                mem2hex((unsigned char *)((long)addr), gdb_buffer, length, 1);
                 break;
                 }
             case 'M':                                /* Write Memory */
@@ -1798,20 +1823,28 @@ int gdb_protocol_parse (unsigned char * ptr)
                 long long addr;
                 int length;
                 int value, i;
-                OUTBUF_FILL ("E02");
 
                 /* M<addr>,<length>:<val><val>...<val> */
 
                 if (hex2llong ((unsigned char ** )&ptr, &addr) == 0)
+                    {
+                    OUTBUF_FILL ("E02");
                     break;
+                    }
 
                 if (! (*ptr++ == ',' &&
                        hex2int (&ptr, &length) &&
                        *ptr++ == ':'))
+                    {
+                    OUTBUF_FILL ("E02");
                     break;
+                    }
 
-                    if (gdb_mem_probe ((void *)((long)addr), SYS_MEM_SAFE_WRITE, length, 0, 1) == -1)
+                if (gdb_mem_probe ((void *)((long)addr), SYS_MEM_SAFE_WRITE, length, 0, 1) == -1)
+                    {
+                    OUTBUF_FILL ("E02");
                     break;  /* No write access */
+                    }
                 
                 /* Now write memory */
                 for(i = 0; i < length; i++)
@@ -1830,32 +1863,41 @@ int gdb_protocol_parse (unsigned char * ptr)
                 int length;
                 int i;
                 unsigned char value;
-		unsigned char * buffer;
-                OUTBUF_FILL ("E02");
+                unsigned char * buffer;
 
                 /* M<addr>,<length>:<val><val>...<val> */
 
                 if (hex2llong ((unsigned char ** )&ptr, &addr) == 0)
+                    {
+                    OUTBUF_FILL ("E02");
                     break;
+                    }
 
                 if (! (*ptr++ == ',' &&
                        hex2int (&ptr, &length) &&
                        *ptr++ == ':'))
+                    {
+                    OUTBUF_FILL ("E02");
                     break;
+                    }
 
                 if (gdb_mem_probe ((void *)((long)addr), SYS_MEM_SAFE_WRITE, length, 0, 1) == -1)
+                    {
+                    OUTBUF_FILL ("E02");
                     break;  /* No write access */
+                    }
 
                 /* Now write memory */
-		buffer = ptr;
+                buffer = ptr;
                 for(i = 0; i < length; i++)
                     {
                     value = buffer[0];
-		    buffer++;
-                    if (value == '}') {
-			value = buffer[0] ^ 0x20;
-			buffer++;
-		    }
+                    buffer++;
+                    if (value == '}')
+                        {
+                        value = buffer[0] ^ 0x20;
+                        buffer++;
+                        }
                     ((unsigned char *)((long)addr))[i] = (unsigned char) value;
                     }
 
@@ -1869,7 +1911,10 @@ int gdb_protocol_parse (unsigned char * ptr)
 
                 /* read signal number */
                 if (!hex2int (&ptr, &signal))
+                    {
+                    OUTBUF_FILL ("E02");
                     break;
+                    }
 
                 gdb_cpu_pending_sig = signal;
 
@@ -1907,7 +1952,10 @@ int gdb_protocol_parse (unsigned char * ptr)
 
                 /* read signal number */
                 if (!hex2int (&ptr, &signal))
+                    {
+                    OUTBUF_FILL ("E02");
                     break;
+                    }
 
                 gdb_cpu_pending_sig = signal;
 
@@ -1933,126 +1981,139 @@ int gdb_protocol_parse (unsigned char * ptr)
 #endif
                     }
 
-		gdb_debug_status = SINGLE_STEP;
-		no_ack = 1;
-		break;
-		}
-	    case 'v':
-		{
-		char action;
-		int signal = 0;
-
-		if (strcmp((const char *)ptr, "Cont?") == 0)
-		    {
-            OUTBUF_FILL ("vCont;c;s;C;S");
-		    break;
-		    }
-		else  if (strncmp((const char *)ptr, "Cont;", 5) != 0)
-		    break;
-		
-		ptr += 5;
-		action = *ptr++;
-		if ((action != 'c') && (action != 'C') &&
-		    (action != 's') && (action != 'S'))
-		    break;
-
-		if ((action == 'C') || (action == 'S'))
-		    {
-		    /* read signal number */
-		    if (!hex2int (&ptr, &signal))
-			break;
-		    }
-
-		if (*ptr == ':')
-		    {
-		    int thread;
-
-		    ptr++;
-		    hex2int (&ptr, &thread);
-		    }
-
-		if (signal != 0)
-		    gdb_cpu_pending_sig = signal;
-
-		if ((action == 'c') || (action == 'C'))
-		    gdb_debug_status = NOT_DEBUGGING;
-		else
-		    gdb_debug_status = SINGLE_STEP;
-		no_ack = 1;
-		break;
-		}
-
-	    case 'z':	/* ztype,addr,length */
-		{
-		int	type, length;
-		long long addr;
-		GDB_ERROR_CODE gdbErrCode;
-                OUTBUF_FILL ("E07");
-
-		/* get address which is required parameter */
-
-		if (hex2int (&ptr, &type) &&
-		    *ptr++ == ',' &&
-		    hex2llong ((unsigned char **)&ptr, &addr) &&
-		    *ptr++ == ',' &&
-		    hex2int (&ptr, &length))
-		    {
+                gdb_debug_status = SINGLE_STEP;
+                no_ack = 1;
+                break;
+                }
+            case 'v':
+                {
+                char action;
+                int signal = 0;
+
+                if (strcmp((const char *)ptr, "Cont?") == 0)
+                    {
+                    OUTBUF_FILL ("vCont;c;s;C;S");
+                    break;
+                    }
+                else  if (strncmp((const char *)ptr, "Cont;", 5) != 0)
+                    {
+                    gdb_buffer[0] = '\0';
+                    break;
+                    }
+                
+                ptr += 5;
+                action = *ptr++;
+                if ((action != 'c') && (action != 'C') &&
+                    (action != 's') && (action != 'S'))
+                    {
+                    gdb_buffer[0] = '\0';
+                    break;
+                    }
+
+                if ((action == 'C') || (action == 'S'))
+                    {
+                    /* read signal number */
+                    if (!hex2int (&ptr, &signal))
+                        {
+                        OUTBUF_FILL ("E02");
+                        break;
+                        }
+                    }
+
+                if (*ptr == ':')
+                    {
+                    int thread;
+                    ptr++;
+                    hex2int (&ptr, &thread);
+                    }
+
+                if (signal != 0)
+                    gdb_cpu_pending_sig = signal;
+
+                if ((action == 'c') || (action == 'C'))
+                    gdb_debug_status = NOT_DEBUGGING;
+                else
+                    gdb_debug_status = SINGLE_STEP;
+                no_ack = 1;
+                break;
+                }
+
+            case 'z':   /* ztype,addr,length */
+                {
+                int     type, length;
+                long long addr;
+                GDB_ERROR_CODE gdbErrCode;
+
+                /* get address which is required parameter */
+
+                if (hex2int (&ptr, &type) &&
+                    *ptr++ == ',' &&
+                    hex2llong ((unsigned char **)&ptr, &addr) &&
+                    *ptr++ == ',' &&
+                    hex2int (&ptr, &length))
+                    {
                     if (gdb_bp_delete (type, (long) addr, length,
                                      &gdbErrCode) == 0)
                         OUTBUF_FILL ("OK");
                     else
                         {
-                        (void) snprintf ((char *)outBuf, GDB_BUF_SIZE, "E%02d",
-                                  gdbErrCode);
+                        (void) snprintf ((char *)gdb_buffer,
+                                        GDB_BUF_SIZE, "E%02d", gdbErrCode);
                         }
                     }
-		break;
-		}
-	    case 'Z':	/* Ztype,addr[:<vaddr1>[:...:<vaddrN>]],length */
-		{
-		    int	type, length;
-		    long long addr;
-		    GDB_ERROR_CODE gdbErrCode;
-
-            OUTBUF_FILL ("E07");
-
-            /* read <type> & <addr> */
-            if (! (hex2int (&ptr, &type) && *ptr++ == ',' &&
-                   hex2llong ((unsigned char **)&ptr, &addr)))
-                break;
-
-            if (! (*ptr++ == ',' && hex2int (&ptr, &length)))
+                else
+                    OUTBUF_FILL ("E07");
                 break;
-
-            if (gdb_bp_add (type, (long) addr, length, &gdbErrCode) == 0)
-                {
-                OUTBUF_FILL (STUB_OK);
                 }
-            else
+            case 'Z':   /* Ztype,addr[:<vaddr1>[:...:<vaddrN>]],length */
                 {
-                (void) snprintf ((char *)outBuf, GDB_BUF_SIZE, "E%02d",
-                              gdbErrCode);
-                }
+                int type, length;
+                long long addr;
+                GDB_ERROR_CODE gdbErrCode;
 
-		    break;
-		}
-	    default:
-		/*
-		 * In case of an unsupported command, send an empty 
-		 * response.
-		 */
 
-		outBuf[0] = '\0';
-		break;
-	}
+                /* read <type> & <addr> */
+                if (! (hex2int (&ptr, &type) && *ptr++ == ',' &&
+                       hex2llong ((unsigned char **)&ptr, &addr)))
+                    {
+                    OUTBUF_FILL ("E07");
+                    break;
+                    }
 
-	/* Send the acknowledgment command when necessary */
+                if (! (*ptr++ == ',' && hex2int (&ptr, &length)))
+                    {
+                    OUTBUF_FILL ("E07");
+                    break;
+                    }
 
-	if (!no_ack)
-	    {
-	    if (putPacket (outBuf) < 0)
-		return -1;
-	    }
+                if (gdb_bp_add (type, (long) addr, length, &gdbErrCode) == 0)
+                    {
+                    OUTBUF_FILL (STUB_OK);
+                    }
+                else
+                    {
+                    (void) snprintf ((char *)gdb_buffer, GDB_BUF_SIZE, "E%02d",
+                                  gdbErrCode);
+                    }
+                break;
+                }
+            default:
+                /*
+                 * In case of an unsupported command, send an empty 
+                 * response.
+                 */
+
+                gdb_buffer[0] = '\0';
+                break;
+        }
+
+        /* Send the acknowledgment command when necessary */
+
+        if (!no_ack)
+            {
+            if (putPacket (gdb_buffer) < 0)
+                return -1;
+            }
 
     return 0;
     }
@@ -2068,18 +2129,6 @@ static void putDebugChar(unsigned char ch) {
     return;
 }
 
-static int putDebugString (unsigned char *str, int len)
-{
-    int num = 0;
-
-    if (len > 0 && (str != NULL))
-        {
-        for (num = 0; num < len; num ++)
-            putDebugChar (str[num]);
-        }
-    return num;
-}
-
 /*******************************************************************************
 *
 * gdb_bps_install - install breakpoints
@@ -2103,16 +2152,16 @@ static void gdb_bps_install (void)
     /* Software breakpoints installation */
 
     for (ix = 0; ix < MAX_SW_BP; ix++) {
-	    if (bpArray[ix].valid == 1 && !bpArray[ix].enabled) {
-	        GDB_INSTR * addr = bpArray[ix].addr;
-		bpArray[ix].insn = *addr;
-		(void)gdb_instruction_set (addr, &bpInst, sizeof(GDB_INSTR));
-		bpArray[ix].enabled = 1;
-	    } else if (bpArray[ix].valid == 0) {
-	        /* First non valid entry in the table is the last entry */
-	        break;
-	    }
-	}
+            if (bpArray[ix].valid == 1 && !bpArray[ix].enabled) {
+                GDB_INSTR * addr = bpArray[ix].addr;
+                bpArray[ix].insn = *addr;
+                (void)gdb_instruction_set (addr, &bpInst, sizeof(GDB_INSTR));
+                bpArray[ix].enabled = 1;
+            } else if (bpArray[ix].valid == 0) {
+                /* First non valid entry in the table is the last entry */
+                break;
+            }
+        }
 }
 
 
@@ -2135,15 +2184,15 @@ static void gdb_bps_uninstall (void) {
     uint32_t ix;
 
     for (ix = 0; ix < MAX_SW_BP; ix++) {
-	    if (bpArray[ix].valid == 1 && bpArray[ix].enabled) {
-	        GDB_INSTR * addr = bpArray[ix].addr;
-		(void)gdb_instruction_set(addr, &bpArray[ix].insn, sizeof(GDB_INSTR));
-		bpArray[ix].enabled = 0;
-	    } else if (bpArray[ix].valid == 0) {
-	        /* First non valid entry in the table is the last entry */
-	        break;
-	    }
-	}
+            if (bpArray[ix].valid == 1 && bpArray[ix].enabled) {
+                GDB_INSTR * addr = bpArray[ix].addr;
+                (void)gdb_instruction_set(addr, &bpArray[ix].insn, sizeof(GDB_INSTR));
+                bpArray[ix].enabled = 0;
+            } else if (bpArray[ix].valid == 0) {
+                /* First non valid entry in the table is the last entry */
+                break;
+            }
+        }
 }
 
 /*******************************************************************************
@@ -2198,9 +2247,9 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
 
 #ifdef GDB_ARCH_NO_SINGLE_STEP
         /* remove temporary breakpoint */
-	(void)gdb_instruction_set (gdb_step_emu_next_pc, &gdb_step_emu_insn, sizeof(GDB_INSTR));
+        (void)gdb_instruction_set (gdb_step_emu_next_pc, &gdb_step_emu_insn, sizeof(GDB_INSTR));
         /* Disable trace mode */
-	gdb_int_regs_unlock (&gdb_regs, gdb_trace_lock_key);
+        gdb_int_regs_unlock (&gdb_regs, gdb_trace_lock_key);
 #else
         /* Disable trace mode */
         gdb_trace_mode_clear (&gdb_regs, gdb_trace_lock_key);
@@ -2208,7 +2257,7 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
         }
 
     if ((mode == GDB_EXC_TRACE) || (mode == GDB_EXC_BP))
-	gdb_stop_by_bp = 1;
+        gdb_stop_by_bp = 1;
 
     gdb_event_is_pending = 1;
     gdb_cpu_stop_signal = signal;
@@ -2234,7 +2283,7 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
     gdb_arch_regs_to_esf(&gdb_regs, (NANO_ESF *) exc_regs);
 
     if ((mode == GDB_EXC_TRACE) || (mode == GDB_EXC_BP))
-	gdb_stop_by_bp = 0;
+        gdb_stop_by_bp = 0;
 
     /* Resume system if not handing a single step */
     gdb_system_resume ();
@@ -2249,12 +2298,12 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
 * This routine loops while waiting for debug events which can be:
 *
 * - System resumed: gdb_debug_status != NOT_DEBUGGING
-*	The control loop must be exited.
+*       The control loop must be exited.
 *
 * - Single step request for current CPU: gdb_debug_status == SINGLE_STEP
-*	Notify client that CPU is already stopped.
-*	This is done by setting gdb_event_is_pending = 1.
-*	gdb_event_is_pending will be handled by next gdb_protocol_get_packet() on CPU 0.
+*       Notify client that CPU is already stopped.
+*       This is done by setting gdb_event_is_pending = 1.
+*       gdb_event_is_pending will be handled by next gdb_protocol_get_packet() on CPU 0.
 *
 * RETURNS: N/A
 *
@@ -2278,20 +2327,20 @@ static void gdb_ctrl_loop (void) {
     }
 
     while (gdb_debug_status != NOT_DEBUGGING) {
-	unsigned char * ptr;
-
-	/*  Check if system has been stopped to handle a notification packet:
-	 * If a notification is pending (gdb_notif_pkt_pending), but no stop
-	 * signal has been set.
-	 */
-	if ((gdb_cpu_stop_signal == GDB_SIG_NULL) && gdb_notif_pkt_pending) {
-	    gdb_notif_handle ();
-	    /* Mark packet notification as done */
-	    gdb_notif_pkt_pending = 0;
-	    break;
-	}
+        unsigned char * ptr;
+
+        /*  Check if system has been stopped to handle a notification packet:
+         * If a notification is pending (gdb_notif_pkt_pending), but no stop
+         * signal has been set.
+         */
+        if ((gdb_cpu_stop_signal == GDB_SIG_NULL) && gdb_notif_pkt_pending) {
+            gdb_notif_handle ();
+            /* Mark packet notification as done */
+            gdb_notif_pkt_pending = 0;
+            break;
+        }
 
-        ptr = gdb_protocol_get_packet (inBuf, GDB_BUF_SIZE);
+        ptr = gdb_protocol_get_packet (gdb_buffer, GDB_BUF_SIZE);
         if (ptr != NULL)
             gdb_protocol_parse (ptr);
 
@@ -2305,7 +2354,7 @@ static void gdb_ctrl_loop (void) {
         }
 #endif /* GDB_ARCH_CAN_STEP */
 
-	if (gdb_debug_status == SINGLE_STEP) {
+        if (gdb_debug_status == SINGLE_STEP) {
 #ifdef GDB_ARCH_NO_SINGLE_STEP
             GDB_INSTR bp_instr = GDB_BREAK_INST;
 
@@ -2314,12 +2363,12 @@ static void gdb_ctrl_loop (void) {
             (void)gdb_instruction_set (gdb_step_emu_next_pc, &bp_instr, sizeof(GDB_INSTR));
             gdb_trace_lock_key = gdb_int_regs_lock (&gdb_regs);
 #else 
-	    /* Handle single step request for for runcontrol CPU */
+            /* Handle single step request for for runcontrol CPU */
 
-	    gdb_trace_lock_key = gdb_trace_mode_set (&gdb_regs);
+            gdb_trace_lock_key = gdb_trace_mode_set (&gdb_regs);
 #endif /* GDB_ARCH_NO_SINGLE_STEP */
-	    return;
-	}
+            return;
+        }
     }
 }
 
@@ -2351,9 +2400,9 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
     /* Save registers */
     if (regs == GDB_INVALID_REG_SET) gdb_regs_not_valid = 1;
     else {
-	if (regs == NULL) regs = sys_debug_current_isf_get();
-	gdb_arch_regs_from_isf(&gdb_regs, regs);
-	gdb_regs_not_valid = 0;
+        if (regs == NULL) regs = sys_debug_current_isf_get();
+        gdb_arch_regs_from_isf(&gdb_regs, regs);
+        gdb_regs_not_valid = 0;
     }
 
     /* A GDB event is pending */
@@ -2364,7 +2413,7 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
 
     /* Load registers */
     if (!gdb_regs_not_valid) {
-	gdb_arch_regs_to_isf(&gdb_regs,regs);
+        gdb_arch_regs_to_isf(&gdb_regs,regs);
     }
 
     /* Resume system if not a single step request */
@@ -2376,11 +2425,11 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
 
 static int gdb_instruction_set(void *addr, GDB_INSTR *instruction, size_t size)
 {
-	if (sys_mem_safe_write_to_text_section(addr, (char *) instruction, size) < 0) {
-		return -EFAULT;
-	}
-	sys_cache_flush((vaddr_t)addr, size);
-	return 0;
+        if (sys_mem_safe_write_to_text_section(addr, (char *) instruction, size) < 0) {
+            return -EFAULT;
+        }
+        sys_cache_flush((vaddr_t)addr, size);
+        return 0;
 }
 
 /*******************************************************************************
@@ -2411,19 +2460,19 @@ int gdb_console_out (char val) {
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
     if (ch == GDB_STOP_CHAR) {
-	int oldlevel = irq_lock();
+        int oldlevel = irq_lock();
 
-	uart_irq_rx_disable(dev);
-	uart_irq_tx_disable(dev);
-	uart_irq_err_disable(dev);
-	gdb_system_stop (NULL, 0);
-	uart_irq_rx_enable(dev);
+        uart_irq_rx_disable(dev);
+        uart_irq_tx_disable(dev);
+        uart_irq_err_disable(dev);
+        gdb_system_stop (NULL, 0);
+        uart_irq_rx_enable(dev);
 #ifndef CONFIG_ARM
-	uart_irq_tx_enable(dev);
-	uart_irq_err_enable(dev);
+        uart_irq_tx_enable(dev);
+        uart_irq_err_enable(dev);
 #endif
-	irq_unlock(oldlevel);
-	return 1;
+        irq_unlock(oldlevel);
+        return 1;
     }
     return 0;
 }
@@ -2455,19 +2504,19 @@ static int init_gdb_server(struct device *unused) {
     static int gdb_is_initialized = 0;
 
     if (!gdb_is_initialized) {
-	gdb_arch_init();
+        gdb_arch_init();
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
-	nano_fifo_init(&cmds_queue);
-	nano_fifo_init(&avail_queue);
-	uart_irq_input_hook_set(UART_CONSOLE_DEV, gdb_irq_input_hook);
-	uart_register_input(&avail_queue, &cmds_queue);
+        nano_fifo_init(&cmds_queue);
+        nano_fifo_init(&avail_queue);
+        uart_irq_input_hook_set(UART_CONSOLE_DEV, gdb_irq_input_hook);
+        uart_register_input(&avail_queue, &cmds_queue);
 #endif
 #ifdef CONFIG_MEM_SAFE_NUM_EXTRA_REGIONS
-	(void)sys_mem_safe_region_add((void *) CONFIG_GDB_RAM_ADDRESS, CONFIG_GDB_RAM_SIZE, SYS_MEM_SAFE_READ);
-	(void)sys_mem_safe_region_add((void *) CONFIG_GDB_RAM_ADDRESS, CONFIG_GDB_RAM_SIZE, SYS_MEM_SAFE_WRITE);
+        (void)sys_mem_safe_region_add((void *) CONFIG_GDB_RAM_ADDRESS, CONFIG_GDB_RAM_SIZE, SYS_MEM_SAFE_READ);
+        (void)sys_mem_safe_region_add((void *) CONFIG_GDB_RAM_ADDRESS, CONFIG_GDB_RAM_SIZE, SYS_MEM_SAFE_WRITE);
 #endif
         gdb_is_initialized = 1;
-	gdb_system_stop_here(GDB_INVALID_REG_SET);
+        gdb_system_stop_here(GDB_INVALID_REG_SET);
     }
     return 0;
 }
-- 
1.9.1


From 27c2ab7b12c55ce156319a0f811944d9f85a7c21 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 15:12:42 -0500
Subject: [PATCH 47/82] gdb: remove notification packet and runcontrol support
 for GDB bootloader

To reduce a little bit more the footprint of the GDB server bootloader,
the notification packet and runcontrol support have been disabled for
bootloader.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index 0e29173..b142021 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -45,17 +45,21 @@
 
 /* statics */
 
+#ifdef GDB_ARCH_HAS_RUNCONTROL
 static NANO_CPU_EXC_STUB_DECL(nano_bp_exc_stub);
 static NANO_CPU_EXC_STUB_DECL(nano_trace_exc_stub);
 static NANO_CPU_EXC_STUB_DECL(nano_fpe_stub);
 static NANO_CPU_EXC_STUB_DECL(nano_pfault_stub);
+#endif
 
 /* forward declarations */
 
+#ifdef GDB_ARCH_HAS_RUNCONTROL
 static void gdb_bp_handler (NANO_ESF * pEsf);
 static void gdb_trace_handler (NANO_ESF * esf);
 static void gdb_fpe_handle (NANO_ESF * esf);
 static void gdb_pfault_handle (NANO_ESF * esf);
+#endif
 
 /**
  *
@@ -70,10 +74,12 @@ static void gdb_pfault_handle (NANO_ESF * esf);
  */
 
 void gdb_arch_init (void) {
+#ifdef GDB_ARCH_HAS_RUNCONTROL
     nanoCpuExcConnect (IV_DIVIDE_ERROR, gdb_fpe_handle, nano_fpe_stub);
     nanoCpuExcConnect (IV_DEBUG, gdb_trace_handler, nano_trace_exc_stub);
     nanoCpuExcConnect (IV_BREAKPOINT, gdb_bp_handler, nano_bp_exc_stub);
     nanoCpuExcConnect (IV_PAGE_FAULT, gdb_pfault_handle, nano_pfault_stub);
+#endif
 }
 
 /**
@@ -255,6 +261,7 @@ void gdb_arch_reg_info_get (int reg_id, int * size, int * offset) {
         *offset = 4 * reg_id;
 }
 
+#ifdef GDB_ARCH_HAS_RUNCONTROL
 /**
  *
  * @brief Clear trace mode
@@ -383,3 +390,4 @@ static void gdb_pfault_handle (NANO_ESF * esf) {
     gdb_debug_status = DEBUGGING;
     gdb_handler (GDB_EXC_OTHER, esf, GDB_SIG_SIGSEGV);
     }
+#endif
diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
index 2469da0..e1f316a 100644
--- a/arch/x86/include/debug/gdb_arch.h
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -41,9 +41,12 @@ extern "C" {
 
 /* define */
 
-#define GDB_ARCH_HAS_WRCONS
 #define GDB_ARCH_HAS_ALL_REGS
+#ifndef CONFIG_GDB_SERVER_BOOTLOADER
+#define GDB_ARCH_HAS_WRCONS
+#define GDB_ARCH_HAS_RUNCONTROL
 #define GDB_ARCH_CAN_STEP       gdb_arch_can_step
+#endif
 
 #ifndef CONFIG_GDB_RAM_SIZE
 #define CONFIG_GDB_RAM_SIZE	CONFIG_RAM_SIZE*1024
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 2409bd6..7e20694 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -413,8 +413,19 @@ Notification Packets:
 #define STR_TYPE      ";type=zephyr"
 #endif
 
+#ifdef GDB_ARCH_HAS_RUNCONTROL
+#define	GDB_SYSTEM_RESUME	gdb_system_resume()
+#define	GDB_BPS_REMOVE		gdb_bps_remove()
+#define GDB_BPS_UNINSTALL	gdb_bps_uninstall()
+#else
+#define	GDB_SYSTEM_RESUME
+#define	GDB_BPS_REMOVE
+#define GDB_BPS_UNINSTALL
+#endif
+
 /* typedef */
  
+#ifdef GDB_ARCH_HAS_RUNCONTROL
 typedef enum gdb_bp_type
     {
     GDB_SOFT_BP,                /* software breakpoint */
@@ -425,6 +436,15 @@ typedef enum gdb_bp_type
     GDB_UNKNOWN_BP_TYPE = -1    /* unknown breakpoint type */
     } GDB_BP_TYPE;
 
+typedef struct
+    {
+    GDB_INSTR * addr;   /* breakpoint address */
+    GDB_INSTR insn;     /* saved instruction */
+    char valid;         /* breakpoint is valid? */
+    char enabled;       /* breakpoint is enabled? */
+    } BP_ARRAY;
+#endif
+
 typedef enum gdb_error_code
     {
     GDB_ERROR_BP_LIST_FULL = 1,         /* Reach max number of Hard&Soft BPs */
@@ -434,14 +454,6 @@ typedef enum gdb_error_code
     GDB_ERROR_HW_BP_NOT_SUP
     } GDB_ERROR_CODE;
 
-typedef struct
-    {
-    GDB_INSTR * addr;   /* breakpoint address */
-    GDB_INSTR insn;     /* saved instruction */
-    char valid;         /* breakpoint is valid? */
-    char enabled;       /* breakpoint is enabled? */
-    } BP_ARRAY;
-
 /* local definitions */
 
 static const unsigned char hexchars[] = {
@@ -451,14 +463,10 @@ static const unsigned char hexchars[] = {
 
 static int gdb_is_connected = 0;        /* A client is connected to GDB Server */
 static int gdb_no_ack = 0;
-static int gdb_stop_by_bp = 0;
-static int gdb_trace_lock_key = 0;
 static int gdb_regs_not_valid = 1;
 static volatile int gdb_event_is_pending = 0;
 static volatile int gdb_cpu_stop_signal = GDB_SIG_NULL;
 static volatile int gdb_cpu_pending_sig;
-static volatile int gdb_notif_pkt_pending = 0;
-static volatile int gdb_notif_data_idx;
 static GDB_REG_SET gdb_regs;
 
 static const char * xml_target_header = "<?xml version=\"1.0\"?> " \
@@ -471,13 +479,10 @@ static unsigned char tmp_reg_buffer [GDB_BUF_SIZE];
 #else
 static unsigned char tmp_reg_buffer [GDBNUMREGBYTES];
 #endif
-static unsigned char gdb_notif_data[GDB_NOTIF_DATA_SIZE];
-
 
-#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
-static struct nano_fifo avail_queue;
-static struct nano_fifo cmds_queue;
-#endif
+#ifdef GDB_ARCH_HAS_RUNCONTROL
+static int gdb_stop_by_bp = 0;
+static int gdb_trace_lock_key = 0;
 
 /*
  * GDB breakpoint table. Note that all the valid entries in the
@@ -490,6 +495,18 @@ static BP_ARRAY bpArray[MAX_SW_BP];
 static GDB_INSTR * gdb_step_emu_next_pc;
 static GDB_INSTR gdb_step_emu_insn;
 #endif /* GDB_ARCH_NO_SINGLE_STEP */
+#endif
+
+#ifdef GDB_ARCH_HAS_WRCONS
+static volatile int gdb_notif_pkt_pending = 0;
+static volatile int gdb_notif_data_idx;
+static unsigned char gdb_notif_data[GDB_NOTIF_DATA_SIZE];
+#endif
+
+#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
+static struct nano_fifo avail_queue;
+static struct nano_fifo cmds_queue;
+#endif
 
 /* global definitions */
 
@@ -500,16 +517,23 @@ static int putPacket(unsigned char * buffer);
 static void putDebugChar(unsigned char ch);
 static int getDebugChar (void);
 
-static int gdb_instruction_set(void *addr, GDB_INSTR *instruction, size_t size);
-
 static void gdb_post_event (void);
 static void gdb_ctrl_loop (void);
 static void gdb_system_stop (NANO_ISF * reg, int sig);
+
+#ifdef GDB_ARCH_HAS_RUNCONTROL
 static void gdb_system_resume (void);
+static int gdb_instruction_set(void *addr, GDB_INSTR *instruction, size_t size);
+int gdb_bp_add (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCode);
+int gdb_bp_delete (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCode);
+void gdb_bps_remove (void);
+#endif
 
+#ifdef GDB_ARCH_HAS_WRCONS
 static void gdb_notif_handle (void);
 static void gdb_notif_flush_request (void);
 static uint32_t gdb_console_write (char *buf, uint32_t len);
+#endif
 
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static int gdb_irq_input_hook (struct device * dev, uint8_t ch);
@@ -851,6 +875,7 @@ static int putPacket(unsigned char * buffer)
         } while (1);
     }
 
+#ifdef GDB_ARCH_HAS_WRCONS
 /*******************************************************************************
 *
 * gdb_notif_flush_request - request a GDB Notification Packet flush
@@ -865,8 +890,7 @@ static int putPacket(unsigned char * buffer)
 *
 */
 
-static void gdb_notif_flush_request (void)
-    {
+static void gdb_notif_flush_request (void) {
     /*
      * Before stopping CPU we must indicate that we're stopping the
      * system to handle a packet notification. During the packet notification,
@@ -881,8 +905,8 @@ static void gdb_notif_flush_request (void)
     gdb_debug_status = DEBUGGING;
     gdb_ctrl_loop ();
     gdb_debug_status = NOT_DEBUGGING;
-    gdb_system_resume ();
-    }
+    GDB_SYSTEM_RESUME;
+}
 
 /*******************************************************************************
 *
@@ -1017,6 +1041,7 @@ again:
     gdb_notif_data[0] = '\0';
     gdb_notif_data_idx = 0;
 }
+#endif
 
 void gdb_post_event (void)
     {
@@ -1293,135 +1318,6 @@ static char * get_xml_target_description (void)
     return target_description;
     }
 
-
-/*******************************************************************************
-*
-* gdb_bp_add - add a new breakpoint or watchpoint to breakpoint list
-*
-* This routine adds a new breakpoint or watchpoint to breakpoint list.
-* For watchpoints, this routine checks that the given type/length combination
-* is supported on current architecture, and that debug registers are not full.
-*
-* <type> : GDB breakpoint type:
-*        0 : software breakpoint        (GDB_SOFT_BP)
-*        1 : hardware breakpoint        (GDB_HW_INST_BP)
-*        2 : write watchpoint        (GDB_HW_DATA_WRITE_BP)
-*        3 : read watchpoint        (GDB_HW_DATA_READ_BP)
-*        4 : access watchpoint        (GDB_HW_DATA_ACCESS_BP)
-*
-* <addr>     : breakpoint address.
-* <length>   : length is in bytes. For a software breakpoint, length specifies
-*              the size of the instruction to be patched. For hardware
-*               breakpoints and watchpoints length specifies the memory
-*               region to be monitored.
-* <pErrCode> : ptr to error code if failed to add breakpoint.
-*
-* RETURNS: 0, or -1 if failed to add breakpoint.
-*
-* ERRNO: N/A
-*
-*/
-
-int gdb_bp_add (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCode) {
-    int ix;
-
-    if (type != GDB_SOFT_BP) {
-        *pErrCode = GDB_ERROR_HW_BP_NOT_SUP;
-        return -1;
-    }
-
-    if (gdb_mem_probe ((void *)addr, SYS_MEM_SAFE_READ, length, 0, 1) == -1)
-            return (-1);
-
-    /* Add software breakpoint to BP list */
-
-    for (ix = 0; ix < MAX_SW_BP; ix++)
-        {
-        if (bpArray[ix].valid == 0)
-            {
-            bpArray[ix].valid = 1;
-            bpArray[ix].enabled = 0;
-            bpArray[ix].addr = (GDB_INSTR *) addr;
-            return (0);
-            }
-        }
-
-    *pErrCode = GDB_ERROR_BP_LIST_FULL;
-    return -1;
-    }
-
-/*******************************************************************************
-*
-* gdb_bp_delete - delete a breakpoint or watchpoint from breakpoint list
-*
-* This routine removes a breakpoint or watchpoint from breakpoint list.
-*
-* RETURNS: 0, or -1 if failed to remove breakpoint.
-*/
-
-int gdb_bp_delete (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCode) {
-    int ix, jx;
-
-    if (type != GDB_SOFT_BP)
-        {
-        *pErrCode = GDB_ERROR_HW_BP_NOT_SUP;
-        return -1;
-        }
-
-    for (ix = 0; ix < MAX_SW_BP; ix++) {
-        if (bpArray[ix].valid == 1 &&
-            bpArray[ix].addr == (GDB_INSTR *) addr) {
-            bpArray[ix].valid = 0;      /* invalidate entry */
-
-            /*
-             * Make sure all valid entries are contiguous to speed up
-             * breakpoint table parsing.
-             */
-
-            for (jx = ix + 1; jx < MAX_SW_BP; jx++) {
-                if (bpArray[jx].valid == 1) {
-                    bpArray[jx - 1] = bpArray[jx];
-                    bpArray[jx].valid = 0;
-                } else
-                    break;
-            }
-            return (0);
-        } else if (bpArray[ix].valid == 0) {
-            /* The first non valid entry in the table is the last entry */
-
-            break;
-        }
-    }
-
-    *pErrCode = GDB_ERROR_INVALID_BP;
-    return (-1);
-    }
-
-/*******************************************************************************
-*
-* gdb_bps_remove - remove all installed breakpoints
-*
-* This routine removes all installed breakpoints.
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-*/
-
-void gdb_bps_remove (void) {
-    int ix;
-
-    for (ix = 0; ix < MAX_SW_BP; ix++)
-        {
-        /* First non valid entry in the table is the last entry */
-
-        if (bpArray[ix].valid == 0)
-            break;
-        bpArray[ix].valid = 0;
-        }
-}
-
 /*******************************************************************************
 *
 * gdb_protocol_parse - parse given GDB command string
@@ -1435,8 +1331,7 @@ void gdb_bps_remove (void) {
 *
 */
 
-int gdb_protocol_parse (unsigned char * ptr)
-    {
+int gdb_protocol_parse (unsigned char * ptr) {
     unsigned char ch;
 #ifdef RESUME_AT_SUPPORT
     long long save_pc;
@@ -1467,7 +1362,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                  * This is an initial connection, should remove all 
                  * the breakpoints and cleanup.
                  */
-                gdb_bps_remove ();
+                GDB_BPS_REMOVE;
                 gdb_is_connected = 1;
                 break;
                 }
@@ -1480,10 +1375,10 @@ int gdb_protocol_parse (unsigned char * ptr)
             case 'D':   /* detach  */
                 {
                 OUTBUF_FILL (STUB_OK);
-                gdb_bps_remove ();
+                GDB_BPS_REMOVE;
                 gdb_is_connected = 0;
                 gdb_debug_status = NOT_DEBUGGING;
-                gdb_system_resume ();
+                GDB_SYSTEM_RESUME;
                 no_ack = 1;
                 gdb_no_ack = 0;
                 break;
@@ -2038,6 +1933,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                 break;
                 }
 
+#ifdef GDB_ARCH_HAS_RUNCONTROL
             case 'z':   /* ztype,addr,length */
                 {
                 int     type, length;
@@ -2097,6 +1993,7 @@ int gdb_protocol_parse (unsigned char * ptr)
                     }
                 break;
                 }
+#endif
             default:
                 /*
                  * In case of an unsupported command, send an empty 
@@ -2116,7 +2013,7 @@ int gdb_protocol_parse (unsigned char * ptr)
             }
 
     return 0;
-    }
+}
 
 /*
  * function: putDebugChar
@@ -2128,6 +2025,135 @@ static void putDebugChar(unsigned char ch) {
     (void) uart_poll_out (UART_CONSOLE_DEV, ch);
     return;
 }
+  
+#ifdef GDB_ARCH_HAS_RUNCONTROL
+/*******************************************************************************
+*
+* gdb_bp_add - add a new breakpoint or watchpoint to breakpoint list
+*
+* This routine adds a new breakpoint or watchpoint to breakpoint list.
+* For watchpoints, this routine checks that the given type/length combination
+* is supported on current architecture, and that debug registers are not full.
+*
+* <type> : GDB breakpoint type:
+*        0 : software breakpoint        (GDB_SOFT_BP)
+*        1 : hardware breakpoint        (GDB_HW_INST_BP)
+*        2 : write watchpoint        (GDB_HW_DATA_WRITE_BP)
+*        3 : read watchpoint        (GDB_HW_DATA_READ_BP)
+*        4 : access watchpoint        (GDB_HW_DATA_ACCESS_BP)
+*
+* <addr>     : breakpoint address.
+* <length>   : length is in bytes. For a software breakpoint, length specifies
+*              the size of the instruction to be patched. For hardware
+*               breakpoints and watchpoints length specifies the memory
+*               region to be monitored.
+* <pErrCode> : ptr to error code if failed to add breakpoint.
+*
+* RETURNS: 0, or -1 if failed to add breakpoint.
+*
+* ERRNO: N/A
+*
+*/
+
+int gdb_bp_add (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCode) {
+    int ix;
+
+    if (type != GDB_SOFT_BP) {
+        *pErrCode = GDB_ERROR_HW_BP_NOT_SUP;
+        return -1;
+    }
+
+    if (gdb_mem_probe ((void *)addr, SYS_MEM_SAFE_READ, length, 0, 1) == -1)
+            return (-1);
+
+    /* Add software breakpoint to BP list */
+
+    for (ix = 0; ix < MAX_SW_BP; ix++)
+        {
+        if (bpArray[ix].valid == 0)
+            {
+            bpArray[ix].valid = 1;
+            bpArray[ix].enabled = 0;
+            bpArray[ix].addr = (GDB_INSTR *) addr;
+            return (0);
+            }
+        }
+
+    *pErrCode = GDB_ERROR_BP_LIST_FULL;
+    return -1;
+    }
+
+/*******************************************************************************
+*
+* gdb_bp_delete - delete a breakpoint or watchpoint from breakpoint list
+*
+* This routine removes a breakpoint or watchpoint from breakpoint list.
+*
+* RETURNS: 0, or -1 if failed to remove breakpoint.
+*/
+
+int gdb_bp_delete (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCode) {
+    int ix, jx;
+
+    if (type != GDB_SOFT_BP)
+        {
+        *pErrCode = GDB_ERROR_HW_BP_NOT_SUP;
+        return -1;
+        }
+
+    for (ix = 0; ix < MAX_SW_BP; ix++) {
+        if (bpArray[ix].valid == 1 &&
+            bpArray[ix].addr == (GDB_INSTR *) addr) {
+            bpArray[ix].valid = 0;      /* invalidate entry */
+
+            /*
+             * Make sure all valid entries are contiguous to speed up
+             * breakpoint table parsing.
+             */
+
+            for (jx = ix + 1; jx < MAX_SW_BP; jx++) {
+                if (bpArray[jx].valid == 1) {
+                    bpArray[jx - 1] = bpArray[jx];
+                    bpArray[jx].valid = 0;
+                } else
+                    break;
+            }
+            return (0);
+        } else if (bpArray[ix].valid == 0) {
+            /* The first non valid entry in the table is the last entry */
+
+            break;
+        }
+    }
+
+    *pErrCode = GDB_ERROR_INVALID_BP;
+    return (-1);
+    }
+
+/*******************************************************************************
+*
+* gdb_bps_remove - remove all installed breakpoints
+*
+* This routine removes all installed breakpoints.
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+void gdb_bps_remove (void) {
+    int ix;
+
+    for (ix = 0; ix < MAX_SW_BP; ix++)
+        {
+        /* First non valid entry in the table is the last entry */
+
+        if (bpArray[ix].valid == 0)
+            break;
+        bpArray[ix].valid = 0;
+        }
+}
 
 /*******************************************************************************
 *
@@ -2286,9 +2312,18 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
         gdb_stop_by_bp = 0;
 
     /* Resume system if not handing a single step */
-    gdb_system_resume ();
+    GDB_SYSTEM_RESUME;
     }
 
+static int gdb_instruction_set(void *addr, GDB_INSTR *instruction, size_t size) {
+    if (sys_mem_safe_write_to_text_section(addr,
+		(char *) instruction, size) < 0) return -EFAULT;
+    sys_cache_flush((vaddr_t)addr, size);
+    return 0;
+}
+
+#endif
+
 /*******************************************************************************
 *
 * gdb_ctrl_loop - GDB control loop
@@ -2314,7 +2349,7 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
 static void gdb_ctrl_loop (void) {
     char ch;
     /* uninstall breakpoints. */
-    gdb_bps_uninstall ();
+    GDB_BPS_UNINSTALL;
 
     /* Flush input buffer */
     while (uart_poll_in (UART_CONSOLE_DEV, &ch) == 0) {
@@ -2329,6 +2364,7 @@ static void gdb_ctrl_loop (void) {
     while (gdb_debug_status != NOT_DEBUGGING) {
         unsigned char * ptr;
 
+#ifdef GDB_ARCH_HAS_WRCONS
         /*  Check if system has been stopped to handle a notification packet:
          * If a notification is pending (gdb_notif_pkt_pending), but no stop
          * signal has been set.
@@ -2339,11 +2375,13 @@ static void gdb_ctrl_loop (void) {
             gdb_notif_pkt_pending = 0;
             break;
         }
+#endif
 
         ptr = gdb_protocol_get_packet (gdb_buffer, GDB_BUF_SIZE);
         if (ptr != NULL)
             gdb_protocol_parse (ptr);
 
+#ifdef GDB_ARCH_HAS_RUNCONTROL
 #ifdef GDB_ARCH_CAN_STEP
         if (gdb_debug_status == SINGLE_STEP) {
            if (!GDB_ARCH_CAN_STEP(&gdb_regs)) {
@@ -2369,6 +2407,7 @@ static void gdb_ctrl_loop (void) {
 #endif /* GDB_ARCH_NO_SINGLE_STEP */
             return;
         }
+#endif
     }
 }
 
@@ -2417,21 +2456,12 @@ static void gdb_system_stop (NANO_ISF * regs, int sig)
     }
 
     /* Resume system if not a single step request */
-    gdb_system_resume ();
+    GDB_SYSTEM_RESUME;
 
     irq_unlock(oldlevel);
     }
 
 
-static int gdb_instruction_set(void *addr, GDB_INSTR *instruction, size_t size)
-{
-        if (sys_mem_safe_write_to_text_section(addr, (char *) instruction, size) < 0) {
-            return -EFAULT;
-        }
-        sys_cache_flush((vaddr_t)addr, size);
-        return 0;
-}
-
 /*******************************************************************************
 *
 * gdb_console_out - wrapper to send a character to console
@@ -2446,6 +2476,7 @@ static int gdb_instruction_set(void *addr, GDB_INSTR *instruction, size_t size)
 */
 
 int gdb_console_out (char val) {
+#ifdef GDB_ARCH_HAS_WRCONS
 	/*
 	 * If remote debug client is connected, then transfer data to remote
 	 * client. Otherwise, discard this character.
@@ -2454,6 +2485,7 @@ int gdb_console_out (char val) {
 		gdb_console_write (&val, 1);
 		return 1;
 	}
+#endif
 	return 0;
 }
 
-- 
1.9.1


From b7fa6dad3c2d11f2c770717abfd58a410aad4989 Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 15:23:23 -0500
Subject: [PATCH 48/82] gdb: quick-n-dirty hack for ARM

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 7e20694..7357f18 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -376,6 +376,11 @@ Notification Packets:
 #ifdef CONFIG_REBOOT
 #include <misc/reboot.h>
 #endif
+#ifdef CONFIG_ARM
+#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+#include <system_timer.h>
+#endif
+#endif
 
 /* defines */
 
@@ -480,6 +485,12 @@ static unsigned char tmp_reg_buffer [GDB_BUF_SIZE];
 static unsigned char tmp_reg_buffer [GDBNUMREGBYTES];
 #endif
 
+#ifdef CONFIG_ARM
+#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+static int boot_regs_set = 0;
+#endif
+#endif
+
 #ifdef GDB_ARCH_HAS_RUNCONTROL
 static int gdb_stop_by_bp = 0;
 static int gdb_trace_lock_key = 0;
@@ -1619,6 +1630,11 @@ int gdb_protocol_parse (unsigned char * ptr) {
                     tmp_reg_buffer[i] = (unsigned char) value;
                 }
                 gdb_arch_regs_set (&gdb_regs, (char *)tmp_reg_buffer);
+#ifdef CONFIG_ARM
+#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+                boot_regs_set = 1;
+#endif
+#endif
                 OUTBUF_FILL (STUB_OK);
                 break;
                 }
@@ -2492,18 +2508,34 @@ int gdb_console_out (char val) {
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
     if (ch == GDB_STOP_CHAR) {
+#ifndef CONFIG_ARM
         int oldlevel = irq_lock();
+#else
+        (void)irq_lock();
+#endif
 
         uart_irq_rx_disable(dev);
         uart_irq_tx_disable(dev);
         uart_irq_err_disable(dev);
         gdb_system_stop (NULL, 0);
+#ifdef CONFIG_ARM
+#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+        if (boot_regs_set) {
+            sys_clock_disable();
+            irq_disable(uart_irq_get(UART_CONSOLE_DEV));
+            boot_regs_set = 0;
+            return 1;
+        }
+#endif
+#endif
         uart_irq_rx_enable(dev);
 #ifndef CONFIG_ARM
         uart_irq_tx_enable(dev);
         uart_irq_err_enable(dev);
 #endif
+#ifndef CONFIG_ARM
         irq_unlock(oldlevel);
+#endif
         return 1;
     }
     return 0;
-- 
1.9.1


From bb66df3cdda14fef685bcf2e3e9dcc029da3e46d Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 15:25:41 -0500
Subject: [PATCH 49/82] gdb: cleanup

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 7357f18..fd2cf79 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -356,6 +356,10 @@ Notification Packets:
         %WrCons:<notificationData>#<checksum>
 */
 
+#if defined(CONFIG_ARM) && defined(CONFIG_GDB_SERVER_BOOTLOADER)
+#define GDB_ARM_BOOTLOADER
+#endif
+
 #include <nanokernel.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -376,11 +380,9 @@ Notification Packets:
 #ifdef CONFIG_REBOOT
 #include <misc/reboot.h>
 #endif
-#ifdef CONFIG_ARM
-#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+#ifdef GDB_ARM_BOOTLOADER
 #include <system_timer.h>
 #endif
-#endif
 
 /* defines */
 
@@ -485,11 +487,9 @@ static unsigned char tmp_reg_buffer [GDB_BUF_SIZE];
 static unsigned char tmp_reg_buffer [GDBNUMREGBYTES];
 #endif
 
-#ifdef CONFIG_ARM
-#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+#ifdef GDB_ARM_BOOTLOADER
 static int boot_regs_set = 0;
 #endif
-#endif
 
 #ifdef GDB_ARCH_HAS_RUNCONTROL
 static int gdb_stop_by_bp = 0;
@@ -1630,11 +1630,9 @@ int gdb_protocol_parse (unsigned char * ptr) {
                     tmp_reg_buffer[i] = (unsigned char) value;
                 }
                 gdb_arch_regs_set (&gdb_regs, (char *)tmp_reg_buffer);
-#ifdef CONFIG_ARM
-#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+#ifdef GDB_ARM_BOOTLOADER
                 boot_regs_set = 1;
 #endif
-#endif
                 OUTBUF_FILL (STUB_OK);
                 break;
                 }
@@ -2304,23 +2302,9 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
     gdb_event_is_pending = 1;
     gdb_cpu_stop_signal = signal;
 
-#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
-    uart_irq_rx_disable(UART_CONSOLE_DEV);
-    uart_irq_tx_disable(UART_CONSOLE_DEV);
-    uart_irq_err_disable(UART_CONSOLE_DEV);
-#endif
-
     /* Enter stop mode agent control loop */
     gdb_ctrl_loop ();
 
-#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
-    uart_irq_rx_enable(UART_CONSOLE_DEV);
-#ifndef CONFIG_ARM
-    uart_irq_tx_enable(UART_CONSOLE_DEV);
-    uart_irq_err_enable(UART_CONSOLE_DEV);
-#endif
-#endif
-
     /* Restore BP handler registers */
     gdb_arch_regs_to_esf(&gdb_regs, (NANO_ESF *) exc_regs);
 
@@ -2508,18 +2492,10 @@ int gdb_console_out (char val) {
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
 static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
     if (ch == GDB_STOP_CHAR) {
-#ifndef CONFIG_ARM
-        int oldlevel = irq_lock();
-#else
         (void)irq_lock();
-#endif
 
-        uart_irq_rx_disable(dev);
-        uart_irq_tx_disable(dev);
-        uart_irq_err_disable(dev);
         gdb_system_stop (NULL, 0);
-#ifdef CONFIG_ARM
-#ifdef CONFIG_GDB_SERVER_BOOTLOADER
+#ifdef GDB_ARM_BOOTLOADER
         if (boot_regs_set) {
             sys_clock_disable();
             irq_disable(uart_irq_get(UART_CONSOLE_DEV));
@@ -2527,15 +2503,6 @@ static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
             return 1;
         }
 #endif
-#endif
-        uart_irq_rx_enable(dev);
-#ifndef CONFIG_ARM
-        uart_irq_tx_enable(dev);
-        uart_irq_err_enable(dev);
-#endif
-#ifndef CONFIG_ARM
-        irq_unlock(oldlevel);
-#endif
         return 1;
     }
     return 0;
@@ -2544,23 +2511,7 @@ static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
 
 void gdb_system_stop_here (void * regs) {
     int oldlevel = irq_lock();
-
-#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
-    uart_irq_rx_disable(UART_CONSOLE_DEV);
-    uart_irq_tx_disable(UART_CONSOLE_DEV);
-    uart_irq_err_disable(UART_CONSOLE_DEV);
-#endif
-
     gdb_system_stop ((NANO_ISF *) regs, GDB_SIG_STOP);
-
-#ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
-    uart_irq_rx_enable(UART_CONSOLE_DEV);
-#ifndef CONFIG_ARM
-    uart_irq_tx_enable(UART_CONSOLE_DEV);
-    uart_irq_err_enable(UART_CONSOLE_DEV);
-#endif
-#endif
-
     irq_unlock(oldlevel);
 }
 
-- 
1.9.1


From 14926631e684bac3496aeec26aecc9002c1f251b Mon Sep 17 00:00:00 2001
From: Renan Le Padellec <renan.le-padellec@windriver.com>
Date: Fri, 15 Jan 2016 15:29:48 -0500
Subject: [PATCH 50/82] gdb: add hardware breakpoints and watchpoints support
 for x86

This commit adds the support for both hardware breakpoints and
watchpoints for x86. This support is disabled by default for now.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/Makefile b/arch/x86/debug/Makefile
index ce30c44..0ed4eee 100644
--- a/arch/x86/debug/Makefile
+++ b/arch/x86/debug/Makefile
@@ -1,3 +1,3 @@
 ccflags-y += -I$(srctree)/kernel/nanokernel/include
 
-obj-$(CONFIG_GDB_SERVER) = gdb_arch.o
+obj-$(CONFIG_GDB_SERVER) = gdb_arch.o gdb_dbg_regs.o
diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index b142021..ee3cd60 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -59,6 +59,10 @@ static void gdb_bp_handler (NANO_ESF * pEsf);
 static void gdb_trace_handler (NANO_ESF * esf);
 static void gdb_fpe_handle (NANO_ESF * esf);
 static void gdb_pfault_handle (NANO_ESF * esf);
+#ifdef GDB_ARCH_HAS_HW_BP
+static int gdb_hw_bp_find (GDB_DBG_REGS * regs, GDB_BP_TYPE * bp_type,
+                            long * address);
+#endif
 #endif
 
 /**
@@ -262,6 +266,252 @@ void gdb_arch_reg_info_get (int reg_id, int * size, int * offset) {
 }
 
 #ifdef GDB_ARCH_HAS_RUNCONTROL
+#ifdef GDB_ARCH_HAS_HW_BP
+/**
+ *
+ * @brief Get the HW BP architecture type for a common GDB type
+ *
+ * This routine gets the specific architecture value that corresponds to a
+ * common hardware breakpoint type.
+ *
+ * @return The architecture type
+ *
+ * \NOMANUAL
+ */
+
+static char gdb_hw_bp_type_get (GDB_BP_TYPE type, int length, GDB_ERROR_CODE * err) {
+    char hw_type = -1;
+
+    switch (type) {
+        /* Following combinations are supported on IA */
+        case GDB_HW_INST_BP:
+            hw_type = 0;
+            break;
+        case GDB_HW_DATA_WRITE_BP:
+            if (length == 1) {
+                hw_type = 0x1;
+            } else if (length == 2) {
+                hw_type = 0x5;
+            } else if (length == 4) {
+                hw_type = 0xd;
+            } else if (length == 8) {
+                hw_type = 0x9;
+            }
+            break;
+        case GDB_HW_DATA_ACCESS_BP:
+            if (length == 1) {
+                hw_type = 0x3;
+            } else if (length == 2) {
+                hw_type = 0x7;
+            } else if (length == 4) {
+                hw_type = 0xf;
+            } else if (length == 8) {
+                hw_type = 0xb;
+            }
+            break;
+        case GDB_HW_DATA_READ_BP:
+            /* Data read not supported on IA */
+            /*
+             * NOTE: Read only watchpoints are not supported by IA debug
+             * registers, but it could be possible to use RW watchpoints
+             * and ignore the RW watchpoint if it has been hit by a write
+             * operation.
+             */
+            *err = GDB_ERROR_HW_BP_NOT_SUP;
+            return -1;
+        default:
+            /* Unknown type */
+            *err = GDB_ERROR_HW_BP_INVALID_TYPE;
+            return -1;
+    }
+    return hw_type;
+}
+
+/**
+ *
+ * @brief Set the debug registers for a specific HW BP.
+ *
+ * This routine sets the <regs> debug registers according to the HW breakpoint
+ * description.
+ *
+ * @return 0 debug registers have been modified or -1 on error
+ *
+ * \NOMANUAL
+ */
+
+int gdb_hw_bp_set (GDB_DBG_REGS * regs, long addr, GDB_BP_TYPE type, int length, GDB_ERROR_CODE * err) {
+    char hw_type;
+
+    if ((hw_type = gdb_hw_bp_type_get (type, length, err)) < 0) {
+        return -1;
+    }
+
+    if (regs->db0 == 0) {
+        regs->db0 = addr;
+        regs->db7 |= (hw_type << 16) | 0x02;
+    }
+    else if (regs->db1 == 0) {
+        regs->db1 = addr;
+        regs->db7 |= (hw_type << 20) | 0x08;
+    }
+    else if (regs->db2 == 0) {
+        regs->db2 = addr;
+        regs->db7 |= (hw_type << 24) | 0x20;
+    }
+    else if (regs->db3 == 0) {
+        regs->db3 = addr;
+        regs->db7 |= (hw_type << 28) | 0x80;
+    }
+    else {
+        *err = GDB_ERROR_HW_BP_DBG_REGS_FULL;
+        return -1;
+    }
+
+    /* set GE bit if it is data breakpoint */
+    if (hw_type != 0) {
+        regs->db7 |= 0x200;
+    }
+    return 0;
+}
+
+/**
+ *
+ * @brief Clear the debug registers for a specific HW BP.
+ *
+ * This routine updates the <regs> debug registers to remove a HW breakpoint.
+ *
+ * @return 0 debug registers have been modified or -1 on error
+ *
+ * \NOMANUAL
+ */
+
+int gdb_hw_bp_clear (GDB_DBG_REGS * regs, long addr, GDB_BP_TYPE type, int length, GDB_ERROR_CODE * err) {
+    char hw_type;
+
+    if ((hw_type = gdb_hw_bp_type_get (type, length, err)) < 0) {
+        return -1;
+    }
+
+    if ((regs->db0 == addr) && (((regs->db7 >> 16) & 0xf) == hw_type)) {
+        regs->db0 = 0;
+        regs->db7 &= ~((hw_type << 16) | 0x02);
+    } else if ((regs->db1 == addr) &&
+                (((regs->db7 >> 20) & 0xf) == hw_type)) {
+        regs->db1 = 0;
+        regs->db7 &= ~((hw_type << 20) | 0x08);
+    } else if ((regs->db2 == addr) &&
+                (((regs->db7 >> 24) & 0xf) == hw_type)) {
+        regs->db2 = 0;
+        regs->db7 &= ~((hw_type << 24) | 0x20);
+    } else if ((regs->db3 == addr) &&
+                (((regs->db7 >> 28) & 0xf) == hw_type)) {
+        regs->db3 = 0;
+        regs->db7 &= ~((hw_type << 28) | 0x80);
+    } else {
+        /* Unknown breakpoint */
+        *err = GDB_ERROR_INVALID_BP;
+        return -1;
+    }
+    return 0;
+}
+
+/**
+ *
+ * @brief Look for a Hardware breakpoint
+ *
+ * This routine checks from the <regs> debug register set if a Hardware
+ * breakpoint has been hit.
+ *
+ * @return 0 if a HW BP has been found, -1 otherwise
+ *
+ * \NOMANUAL
+ */
+
+static int gdb_hw_bp_find (GDB_DBG_REGS * regs, GDB_BP_TYPE * bp_type, long * address) {
+    int ix;
+    unsigned char type = 0;
+    long addr = 0;
+    int status_bit;
+    int enable_bit;
+
+    /* get address and type of breakpoint from DR6 and DR7 */
+    for (ix = 0; ix < 4; ix++) {
+        status_bit = 1 << ix;
+        enable_bit = 2 << (ix << 1);
+
+        if ((regs->db6 & status_bit) && (regs->db7 & enable_bit)) {
+            switch (ix) {
+                case 0:
+                    addr = regs->db0;
+                    type = (regs->db7 & 0x000f0000) >> 16;
+                    break;
+
+                case 1:
+                    addr = regs->db1;
+                    type = (regs->db7 & 0x00f00000) >> 20;
+                    break;
+
+                case 2:
+                    addr = regs->db2;
+                    type = (regs->db7 & 0x0f000000) >> 24;
+                    break;
+
+                case 3:
+                    addr = regs->db3;
+                    type = (regs->db7 & 0xf0000000) >> 28;
+                    break;
+            }
+        }
+    }
+
+    if ((addr == 0) && (type == 0))
+        return -1;
+
+    *address = addr;
+    switch (type) {
+        case 0x1:
+        case 0x5:
+        case 0xd:
+        case 0x9:
+            *bp_type = GDB_HW_DATA_WRITE_BP;
+            break;
+        case 0x3:
+        case 0x7:
+        case 0xf:
+        case 0xb:
+            *bp_type = GDB_HW_DATA_ACCESS_BP;
+            break;
+        default:
+	        *bp_type = GDB_HW_INST_BP;
+            break;
+    }
+    return 0;
+}
+
+/**
+ *
+ * @brief Clear all debug registers.
+ *
+ * This routine clears all debug registers
+ *
+ * @return N/A
+ *
+ * \NOMANUAL
+ */
+
+void gdb_dbg_regs_clear (void) {
+	GDB_DBG_REGS regs;
+
+    regs.db0 = 0;
+    regs.db1 = 0;
+    regs.db2 = 0;
+    regs.db3 = 0;
+    regs.db6 = 0;
+    regs.db7 = 0;
+    gdb_dbg_regs_set (&regs);
+}
+#endif
+
 /**
  *
  * @brief Clear trace mode
@@ -334,9 +584,30 @@ int gdb_trace_mode_set (GDB_REG_SET * regs) {
  */
 
 static void gdb_trace_handler (NANO_ESF * esf) {
+#ifdef GDB_ARCH_HAS_HW_BP
+	GDB_DBG_REGS regs;
+#endif
+
     (void)irq_lock();
+#ifndef GDB_ARCH_HAS_HW_BP
     gdb_handler (GDB_EXC_TRACE, esf, GDB_SIG_TRAP);
+#else
+    gdb_dbg_regs_get (&regs);
+    if ((regs.db6  & 0x00004000) == 0x00004000) {
+        gdb_handler (GDB_EXC_TRACE, esf, GDB_SIG_TRAP);
+    } else {
+        int type;
+        long addr;
+
+        gdb_dbg_regs_clear ();
+        (void) gdb_hw_bp_find (&regs, &type, &addr);
+        gdb_cpu_stop_hw_bp_addr = addr;
+        gdb_cpu_stop_bp_type = type;
+        gdb_debug_status = DEBUGGING;
+        gdb_handler (GDB_EXC_BP, esf, GDB_SIG_TRAP);
     }
+#endif
+}
 
 /**
  *
@@ -353,7 +624,11 @@ static void gdb_trace_handler (NANO_ESF * esf) {
 static void gdb_bp_handler (NANO_ESF * esf) {
     (void)irq_lock();
     gdb_debug_status = DEBUGGING;
+#ifdef GDB_ARCH_HAS_HW_BP
+    gdb_cpu_stop_bp_type = GDB_SOFT_BP;
+#endif
     esf->eip -= sizeof(GDB_INSTR);
+
     gdb_handler (GDB_EXC_BP, esf, GDB_SIG_TRAP);
 }
 
diff --git a/arch/x86/debug/gdb_dbg_regs.S b/arch/x86/debug/gdb_dbg_regs.S
new file mode 100644
index 0000000..dd6f0c1
--- /dev/null
+++ b/arch/x86/debug/gdb_dbg_regs.S
@@ -0,0 +1,90 @@
+/* gdb_dbg_regs.S - Utilities to read/write debug registers */
+
+/*
+ * Copyright (c) 2015 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+DESCRIPTION
+This module provides the implementation of the gdb_dbg_regs_set/get()
+utilities.
+ */
+
+#define _ASMLANGUAGE
+
+#include <arch/x86/asm.h>
+
+	/* exports (internal APIs) */
+
+	GTEXT(gdb_dbg_regs_set)
+	GTEXT(gdb_dbg_regs_get)
+
+/**
+ *
+ * @brief Write debug registers
+ *
+ * This function is used to write to debug registers
+ *
+ * C function prototype:
+ *
+ *   void gdb_dbg_regs_set (GDB_DBG_REGS * regs);
+ *
+ * @return N/A
+ */
+
+SECTION_FUNC(TEXT, gdb_dbg_regs_set)
+    movl    SP_ARG1(%esp),%edx
+    movl    0(%edx),%eax
+    movl    %eax,%db0
+    movl    4(%edx),%eax
+    movl    %eax,%db1
+    movl    8(%edx),%eax
+    movl    %eax,%db2
+    movl    12(%edx),%eax
+    movl    %eax,%db3
+    movl    16(%edx),%eax
+    movl    %eax,%db6
+    movl    20(%edx),%eax
+    movl    %eax,%db7
+    ret
+
+/**
+ *
+ * @brief Read debug registers
+ *
+ * This function is used to read debug registers
+ *
+ * C function prototype:
+ *
+ *   void gdb_dbg_regs_get (GDB_DBG_REGS * regs);
+ *
+ * @return N/A
+ */
+
+SECTION_FUNC(TEXT, gdb_dbg_regs_get)
+    movl    SP_ARG1(%esp),%edx
+    movl    %db0,%eax
+    movl    %eax,0(%edx)
+    movl    %db1,%eax
+    movl    %eax,4(%edx)
+    movl    %db2,%eax
+    movl    %eax,8(%edx)
+    movl    %db3,%eax
+    movl    %eax,12(%edx)
+    movl    %db6,%eax
+    movl    %eax,16(%edx)
+    movl    %db7,%eax
+    movl    %eax,20(%edx)
+    ret
diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
index e1f316a..e49cccb 100644
--- a/arch/x86/include/debug/gdb_arch.h
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -38,11 +38,13 @@ extern "C" {
 #endif /* __cplusplus */
 
 #include <nano_private.h>
+#include <debug/gdb_server.h>
 
 /* define */
 
 #define GDB_ARCH_HAS_ALL_REGS
 #ifndef CONFIG_GDB_SERVER_BOOTLOADER
+#undef  GDB_ARCH_HAS_HW_BP
 #define GDB_ARCH_HAS_WRCONS
 #define GDB_ARCH_HAS_RUNCONTROL
 #define GDB_ARCH_CAN_STEP       gdb_arch_can_step
@@ -76,16 +78,30 @@ extern "C" {
 
 typedef unsigned char GDB_INSTR;
 
-
-typedef struct
-    {
+typedef struct {
     NANO_ISF regs;
     unsigned int pad1;	/* padding for ss register */
     unsigned int pad2;	/* padding for ds register */
     unsigned int pad3;	/* padding for es register */
     unsigned int pad4;	/* padding for fs register */
     unsigned int pad5;	/* padding for gs register */
-    } GDB_REG_SET;
+} GDB_REG_SET;
+
+typedef struct {
+    unsigned int    db0;    /* debug register 0 */
+    unsigned int    db1;    /* debug register 1 */
+    unsigned int    db2;    /* debug register 2 */
+    unsigned int    db3;    /* debug register 3 */
+    unsigned int    db6;    /* debug register 6 */
+    unsigned int    db7;    /* debug register 7 */
+} GDB_DBG_REGS;
+
+#ifdef GDB_ARCH_HAS_RUNCONTROL
+#ifdef GDB_ARCH_HAS_HW_BP
+extern volatile int gdb_cpu_stop_bp_type;
+extern long gdb_cpu_stop_hw_bp_addr;
+#endif
+#endif
 
 /* function declaration */
 
@@ -100,6 +116,13 @@ extern void gdb_arch_reg_info_get (int reg_id, int * size, int * offset);
 extern void gdb_trace_mode_clear (GDB_REG_SET * regs, int arg);
 extern int gdb_trace_mode_set (GDB_REG_SET * regs);
 extern int gdb_arch_can_step (GDB_REG_SET * regs);
+#ifdef GDB_ARCH_HAS_HW_BP
+extern int gdb_hw_bp_set (GDB_DBG_REGS * regs, long addr, GDB_BP_TYPE type, int length, GDB_ERROR_CODE * err);
+extern int gdb_hw_bp_clear (GDB_DBG_REGS * regs, long addr, GDB_BP_TYPE type, int length, GDB_ERROR_CODE * err);
+extern void gdb_dbg_regs_set (GDB_DBG_REGS * regs);
+extern void gdb_dbg_regs_get (GDB_DBG_REGS * regs);
+extern void gdb_dbg_regs_clear (void);
+#endif
 
 #endif /* _ASMLANGUAGE */
 
diff --git a/include/misc/debug/gdb_server.h b/include/misc/debug/gdb_server.h
index 46e5149..37c3791 100644
--- a/include/misc/debug/gdb_server.h
+++ b/include/misc/debug/gdb_server.h
@@ -50,22 +50,37 @@ extern "C" {
 
 /* typedef */
 
-typedef enum gdb_exception_mode
-     {
+typedef enum {
+    GDB_ERROR_BP_LIST_FULL = 1,         /* Reach max number of Hard&Soft BPs */
+    GDB_ERROR_INVALID_BP,               /* No such BP in breakpoints list */
+    GDB_ERROR_HW_BP_INVALID_TYPE,       /* Unsupported type/len combination */
+    GDB_ERROR_HW_BP_DBG_REGS_FULL,      /* Debug register set full */
+    GDB_ERROR_HW_BP_NOT_SUP
+} GDB_ERROR_CODE;
+
+typedef enum {
+    GDB_SOFT_BP,        /* software breakpoint */
+    GDB_HW_INST_BP,     /* hardware instruction breakpoint */
+    GDB_HW_DATA_WRITE_BP,   /* write watchpoint */
+    GDB_HW_DATA_READ_BP,    /* read watchpoint */
+    GDB_HW_DATA_ACCESS_BP,  /* access watchpoint */
+    GDB_UNKNOWN_BP_TYPE = -1    /* unknown breakpoint type */
+} GDB_BP_TYPE;
+
+typedef enum {
      GDB_EXC_TRACE,              /* trace exception */
      GDB_EXC_BP,                 /* breakpoint exception */
      GDB_EXC_OTHER,              /* other exceptions */
-     } EXC_MODE;
+} EXC_MODE;
 
-enum gdb_signal
-    {
+typedef enum {
     GDB_SIG_NULL = -1,
     GDB_SIG_INT = 2,
     GDB_SIG_TRAP = 5,
     GDB_SIG_FPE = 8,
     GDB_SIG_SIGSEGV = 11,
     GDB_SIG_STOP = 17
-    };
+} GDB_SIGNAL;
 
 /* externs */
 
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index fd2cf79..00ffd5b 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -433,16 +433,6 @@ Notification Packets:
 /* typedef */
  
 #ifdef GDB_ARCH_HAS_RUNCONTROL
-typedef enum gdb_bp_type
-    {
-    GDB_SOFT_BP,                /* software breakpoint */
-    GDB_HW_INST_BP,             /* hardware instruction breakpoint */
-    GDB_HW_DATA_WRITE_BP,       /* write watchpoint */
-    GDB_HW_DATA_READ_BP,        /* read watchpoint */
-    GDB_HW_DATA_ACCESS_BP,      /* access watchpoint */
-    GDB_UNKNOWN_BP_TYPE = -1    /* unknown breakpoint type */
-    } GDB_BP_TYPE;
-
 typedef struct
     {
     GDB_INSTR * addr;   /* breakpoint address */
@@ -452,15 +442,6 @@ typedef struct
     } BP_ARRAY;
 #endif
 
-typedef enum gdb_error_code
-    {
-    GDB_ERROR_BP_LIST_FULL = 1,         /* Reach max number of Hard&Soft BPs */
-    GDB_ERROR_INVALID_BP,               /* No such BP in breakpoints list */
-    GDB_ERROR_HW_BP_INVALID_TYPE,       /* Unsupported type/len combination */
-    GDB_ERROR_HW_BP_DBG_REGS_FULL,      /* Debug register set full */
-    GDB_ERROR_HW_BP_NOT_SUP
-    } GDB_ERROR_CODE;
-
 /* local definitions */
 
 static const unsigned char hexchars[] = {
@@ -492,6 +473,10 @@ static int boot_regs_set = 0;
 #endif
 
 #ifdef GDB_ARCH_HAS_RUNCONTROL
+#ifdef GDB_ARCH_HAS_HW_BP
+static int gdb_hw_bp_cnt = 0;
+static GDB_DBG_REGS dbg_regs;
+#endif
 static int gdb_stop_by_bp = 0;
 static int gdb_trace_lock_key = 0;
 
@@ -523,6 +508,13 @@ static struct nano_fifo cmds_queue;
 
 volatile int gdb_debug_status = NOT_DEBUGGING;
 
+#ifdef GDB_ARCH_HAS_RUNCONTROL
+#ifdef GDB_ARCH_HAS_HW_BP
+volatile int gdb_cpu_stop_bp_type = GDB_SOFT_BP;
+long gdb_cpu_stop_hw_bp_addr = 0;
+#endif
+#endif
+
 /* forward static declarations */
 static int putPacket(unsigned char * buffer);
 static void putDebugChar(unsigned char ch);
@@ -1054,36 +1046,72 @@ again:
 }
 #endif
 
-void gdb_post_event (void)
-    {
+void gdb_post_event (void) {
     int async_stop = 0;
 
     gdb_event_is_pending = 0;
-    if (gdb_cpu_stop_signal != GDB_SIG_NULL)
-        {
+    if (gdb_cpu_stop_signal != GDB_SIG_NULL) {
         async_stop = 1;
-        }
-    if (async_stop)
-        {
+    }
+    if (async_stop) {
         unsigned char * ptr = gdb_buffer;
         size_t bufSize = GDB_BUF_SIZE;
-        if (gdb_cpu_stop_signal != GDB_SIG_NULL)
-            {
+        if (gdb_cpu_stop_signal != GDB_SIG_NULL) {
 #ifndef GDB_ARCH_HAS_ALL_REGS
             int offset = 0;
             int size = 4;
 #endif
             int count;
             unsigned char * savedPtr;
-            if (ptr != gdb_buffer)
-                {
+            if (ptr != gdb_buffer) {
                 *ptr++ = '|';
                 bufSize--;
-                }
+            }
             count = snprintf ((char *)ptr, bufSize,
                         "T%02xthread:%02x", gdb_cpu_stop_signal, 1);
             ptr += count;
             bufSize -= count;
+#ifdef GDB_ARCH_HAS_HW_BP
+            /*
+             * If it's an hardware breakpoint, report the address and access
+             * type at the origin of the HW breakpoint. Supported syntaxes:
+             *        watch:<dataAddr> : Write access
+             *        rwatch:<dataAddr> : Read access
+             *        awatch:<dataAddr> : Read/Write Access
+             * Instruction hardware breakpoints are reported as software
+             * breakpoints
+             */
+
+            if ((gdb_cpu_stop_signal == GDB_SIG_TRAP) &&
+                (gdb_cpu_stop_bp_type != GDB_SOFT_BP) &&
+                (gdb_cpu_stop_bp_type != GDB_HW_INST_BP)) {
+                count = 0;
+                switch (gdb_cpu_stop_bp_type) {
+                    case GDB_HW_DATA_WRITE_BP:
+                        count = snprintf ((char *)ptr, bufSize, ";watch");
+                        break;
+
+                    case GDB_HW_DATA_READ_BP:
+                        count = snprintf ((char *)ptr, bufSize, ";rwatch");
+                        break;
+
+                    case GDB_HW_DATA_ACCESS_BP:
+                        count = snprintf ((char *)ptr, bufSize, ";awatch");
+                        break;
+                }
+                if (count != 0) {
+                    ptr += count;
+                    bufSize -=count;
+                    count = snprintf ((char *)ptr, bufSize, ":%lx",
+                                        gdb_cpu_stop_hw_bp_addr);
+                    ptr += count;
+                    bufSize -= count;
+                }
+            gdb_cpu_stop_hw_bp_addr = 0;
+            gdb_cpu_stop_bp_type = GDB_SOFT_BP;
+            gdb_cpu_stop_signal = GDB_SIG_NULL;
+            }
+#endif
             if (!gdb_regs_not_valid) {
                 gdb_arch_regs_get (&gdb_regs, (char *)tmp_reg_buffer);
 #ifdef GDB_ARCH_HAS_ALL_REGS
@@ -1106,16 +1134,15 @@ void gdb_post_event (void)
 
             /* clear stop reason */
             gdb_cpu_stop_signal = GDB_SIG_NULL;
-            }
-        *ptr = '\0';
         }
-    else
-        {
+        *ptr = '\0';
+    }
+    else {
         (void)snprintf ((char *)gdb_buffer, GDB_BUF_SIZE, "S%02x", GDB_SIG_INT);
-        }
+    }
 
     (void)putPacket (gdb_buffer);
-    }
+}
 
 /*******************************************************************************
 *
@@ -2041,6 +2068,53 @@ static void putDebugChar(unsigned char ch) {
 }
   
 #ifdef GDB_ARCH_HAS_RUNCONTROL
+#ifdef GDB_ARCH_HAS_HW_BP
+/*******************************************************************************
+*
+* gdb_hw_bp_add - add an hardware breakpoint to debug registers set
+*
+* This routine adds an hardware breakpoint to debug registers structure.
+* It does not update the debug registers, this is only done using
+* wdbDbgRegsSet().
+*
+* RETURNS: 0, or -1 if failed (Error code returned via pErrCode).
+*
+* ERRNO: N/A
+*
+*/
+
+int gdb_hw_bp_add (long addr, GDB_BP_TYPE type, int length, GDB_ERROR_CODE * err) {
+    if (gdb_hw_bp_set (&dbg_regs, addr, type, length, err) == -1) {
+        return -1;
+    }
+
+    gdb_hw_bp_cnt++;
+    return 0;
+}
+
+/*******************************************************************************
+*
+* gdb_hw_bp_remove - remove an hardware breakpoint from debug registers set
+*
+* This routine removes an hardware breakpoint from debug registers structure.
+* It does not update the debug registers, this is only done using
+* wdbDbgRegsSet().
+*
+* RETURNS: OK or ERROR (Error code returned via pErrCode).
+*
+* ERRNO: N/A
+*
+*/
+
+int gdb_hw_bp_remove (long addr, GDB_BP_TYPE type, int length, GDB_ERROR_CODE * err) {
+    if (gdb_hw_bp_clear (&dbg_regs, addr, type, length, err) == -1) {
+        return -1;
+    }
+    gdb_hw_bp_cnt--;
+    return 0;
+}
+#endif
+
 /*******************************************************************************
 *
 * gdb_bp_add - add a new breakpoint or watchpoint to breakpoint list
@@ -2073,8 +2147,12 @@ int gdb_bp_add (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pErrCo
     int ix;
 
     if (type != GDB_SOFT_BP) {
+#ifdef GDB_ARCH_HAS_HW_BP
+        return (gdb_hw_bp_add (addr, type, length, pErrCode));
+#else
         *pErrCode = GDB_ERROR_HW_BP_NOT_SUP;
         return -1;
+#endif
     }
 
     if (gdb_mem_probe ((void *)addr, SYS_MEM_SAFE_READ, length, 0, 1) == -1)
@@ -2111,8 +2189,12 @@ int gdb_bp_delete (GDB_BP_TYPE type, long addr, int length, GDB_ERROR_CODE * pEr
 
     if (type != GDB_SOFT_BP)
         {
+#ifdef GDB_ARCH_HAS_HW_BP
+        return (gdb_hw_bp_remove (addr, type, length, pErrCode));
+#else
         *pErrCode = GDB_ERROR_HW_BP_NOT_SUP;
         return -1;
+#endif
         }
 
     for (ix = 0; ix < MAX_SW_BP; ix++) {
@@ -2184,26 +2266,30 @@ void gdb_bps_remove (void) {
 *
 */
 
-static void gdb_bps_install (void)
-    {
+static void gdb_bps_install (void) {
     uint32_t ix;
     GDB_INSTR bpInst = GDB_BREAK_INST;
 
     /* Software breakpoints installation */
 
     for (ix = 0; ix < MAX_SW_BP; ix++) {
-            if (bpArray[ix].valid == 1 && !bpArray[ix].enabled) {
-                GDB_INSTR * addr = bpArray[ix].addr;
-                bpArray[ix].insn = *addr;
-                (void)gdb_instruction_set (addr, &bpInst, sizeof(GDB_INSTR));
-                bpArray[ix].enabled = 1;
-            } else if (bpArray[ix].valid == 0) {
-                /* First non valid entry in the table is the last entry */
-                break;
-            }
+        if (bpArray[ix].valid == 1 && !bpArray[ix].enabled) {
+            GDB_INSTR * addr = bpArray[ix].addr;
+            bpArray[ix].insn = *addr;
+            (void)gdb_instruction_set (addr, &bpInst, sizeof(GDB_INSTR));
+            bpArray[ix].enabled = 1;
+        } else if (bpArray[ix].valid == 0) {
+            /* First non valid entry in the table is the last entry */
+            break;
         }
-}
+    }
 
+#ifdef GDB_ARCH_HAS_HW_BP
+    if (gdb_hw_bp_cnt > 0) {
+        gdb_dbg_regs_set (&dbg_regs);
+    }
+#endif
+}
 
 /*******************************************************************************
 *
@@ -2224,15 +2310,21 @@ static void gdb_bps_uninstall (void) {
     uint32_t ix;
 
     for (ix = 0; ix < MAX_SW_BP; ix++) {
-            if (bpArray[ix].valid == 1 && bpArray[ix].enabled) {
-                GDB_INSTR * addr = bpArray[ix].addr;
-                (void)gdb_instruction_set(addr, &bpArray[ix].insn, sizeof(GDB_INSTR));
-                bpArray[ix].enabled = 0;
-            } else if (bpArray[ix].valid == 0) {
-                /* First non valid entry in the table is the last entry */
-                break;
-            }
+    	if (bpArray[ix].valid == 1 && bpArray[ix].enabled) {
+    		GDB_INSTR * addr = bpArray[ix].addr;
+            (void)gdb_instruction_set(addr, &bpArray[ix].insn, sizeof(GDB_INSTR));
+            bpArray[ix].enabled = 0;
+        } else if (bpArray[ix].valid == 0) {
+            /* First non valid entry in the table is the last entry */
+            break;
         }
+    }
+    
+#ifdef GDB_ARCH_HAS_HW_BP
+    if (gdb_hw_bp_cnt > 0) {
+    	gdb_dbg_regs_clear ();
+    }
+#endif
 }
 
 /*******************************************************************************
-- 
1.9.1


From 0754ccb87f50b7505adada3b8ce2a3c3823c8163 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 13:34:03 -0500
Subject: [PATCH 51/82] gdb: obtain UART console devivce object at runtime

The UART on which the console is present is not a static definition
anymore, but rather it is obtained via device_get_binding() at runtime.
The name of the UART device on which the console is present is
availablle via the kconfig option (UART_CONSOLE_ON_DEV_NAME).

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 00ffd5b..83e4865 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -504,6 +504,8 @@ static struct nano_fifo avail_queue;
 static struct nano_fifo cmds_queue;
 #endif
 
+static struct device *uart_console_dev;
+
 /* global definitions */
 
 volatile int gdb_debug_status = NOT_DEBUGGING;
@@ -1162,7 +1164,7 @@ static int getDebugChar (void)
     {
     char ch;
 
-    while (uart_poll_in (UART_CONSOLE_DEV, &ch) != 0)
+    while (uart_poll_in (uart_console_dev, &ch) != 0)
         {
         if (gdb_event_is_pending)
             return -1;
@@ -2063,7 +2065,7 @@ int gdb_protocol_parse (unsigned char * ptr) {
  *      - Write a single character from a port.
  */
 static void putDebugChar(unsigned char ch) {
-    (void) uart_poll_out (UART_CONSOLE_DEV, ch);
+    (void) uart_poll_out (uart_console_dev, ch);
     return;
 }
   
@@ -2444,7 +2446,7 @@ static void gdb_ctrl_loop (void) {
     GDB_BPS_UNINSTALL;
 
     /* Flush input buffer */
-    while (uart_poll_in (UART_CONSOLE_DEV, &ch) == 0) {
+    while (uart_poll_in (uart_console_dev, &ch) == 0) {
         if (ch == GDB_STOP_CHAR) {
             gdb_debug_status = DEBUGGING;
             gdb_cpu_stop_signal = GDB_SIG_INT;
@@ -2590,7 +2592,7 @@ static int gdb_irq_input_hook (struct device * dev, uint8_t ch) {
 #ifdef GDB_ARM_BOOTLOADER
         if (boot_regs_set) {
             sys_clock_disable();
-            irq_disable(uart_irq_get(UART_CONSOLE_DEV));
+            irq_disable(uart_irq_get(uart_console_dev));
             boot_regs_set = 0;
             return 1;
         }
@@ -2612,10 +2614,13 @@ static int init_gdb_server(struct device *unused) {
 
     if (!gdb_is_initialized) {
         gdb_arch_init();
+
+		uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
+
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
         nano_fifo_init(&cmds_queue);
         nano_fifo_init(&avail_queue);
-        uart_irq_input_hook_set(UART_CONSOLE_DEV, gdb_irq_input_hook);
+        uart_irq_input_hook_set(uart_console_dev, gdb_irq_input_hook);
         uart_register_input(&avail_queue, &cmds_queue);
 #endif
 #ifdef CONFIG_MEM_SAFE_NUM_EXTRA_REGIONS
-- 
1.9.1


From ddd0d10effb086667af1ed54fb57f7c8767b1900 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 13:55:58 -0500
Subject: [PATCH 52/82] gdb/x86: HACKish - create stubs for exceptions needed
 by the server

- divide error: no error code
- debug: no error code
- breakpoint: no error code
- page fault: error code

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 3c07221..165b98f 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -232,6 +232,7 @@ config NUM_DYNAMIC_STUBS
 
 config NUM_DYNAMIC_EXC_STUBS
 	int "Number of dynamic exception stubs"
+	default 1 if GDB_SERVER
 	default 0
 	help
 	This option specifies the maximum number of dynamically allocated
@@ -241,6 +242,7 @@ config NUM_DYNAMIC_EXC_STUBS
 config NUM_DYNAMIC_EXC_NOERR_STUBS
 	int "Number of dynamic no-error exception stubs"
 	default 0
+	default 3 if GDB_SERVER
 	help
 	This option specifies the maximum number of dynamically allocated
 	exception stubs that are to be used with exceptions that do not push
-- 
1.9.1


From e3a2bc5eb3c9f345cc5a5cb0338674049d94ab24 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 14:01:04 -0500
Subject: [PATCH 53/82] gdb: remove creation of exception stubs

This has be deprecated in favour of kconfig options.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index ee3cd60..021aa05 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -45,13 +45,6 @@
 
 /* statics */
 
-#ifdef GDB_ARCH_HAS_RUNCONTROL
-static NANO_CPU_EXC_STUB_DECL(nano_bp_exc_stub);
-static NANO_CPU_EXC_STUB_DECL(nano_trace_exc_stub);
-static NANO_CPU_EXC_STUB_DECL(nano_fpe_stub);
-static NANO_CPU_EXC_STUB_DECL(nano_pfault_stub);
-#endif
-
 /* forward declarations */
 
 #ifdef GDB_ARCH_HAS_RUNCONTROL
@@ -79,10 +72,10 @@ static int gdb_hw_bp_find (GDB_DBG_REGS * regs, GDB_BP_TYPE * bp_type,
 
 void gdb_arch_init (void) {
 #ifdef GDB_ARCH_HAS_RUNCONTROL
-    nanoCpuExcConnect (IV_DIVIDE_ERROR, gdb_fpe_handle, nano_fpe_stub);
-    nanoCpuExcConnect (IV_DEBUG, gdb_trace_handler, nano_trace_exc_stub);
-    nanoCpuExcConnect (IV_BREAKPOINT, gdb_bp_handler, nano_bp_exc_stub);
-    nanoCpuExcConnect (IV_PAGE_FAULT, gdb_pfault_handle, nano_pfault_stub);
+    nanoCpuExcConnect (IV_DIVIDE_ERROR, gdb_fpe_handle);
+    nanoCpuExcConnect (IV_DEBUG, gdb_trace_handler);
+    nanoCpuExcConnect (IV_BREAKPOINT, gdb_bp_handler);
+    nanoCpuExcConnect (IV_PAGE_FAULT, gdb_pfault_handle);
 #endif
 }
 
-- 
1.9.1


From e873c9fcd2de52005b7cfdccb74291186d0bcc47 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 14:03:26 -0500
Subject: [PATCH 54/82] gdb: GDB_SERVER selects DEBUG_INFO

Needed for saving extra GPRs and access to the ISF.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/Kconfig b/misc/debug/Kconfig
index 9afc6bc..67ff5f0 100644
--- a/misc/debug/Kconfig
+++ b/misc/debug/Kconfig
@@ -88,6 +88,7 @@ config	GDB_SERVER
 	default n
 	select REBOOT
 	select MEM_SAFE
+	select DEBUG_INFO
 	help
 	This option enables the GDB Server support.
 
-- 
1.9.1


From eff1686c6366ad23f82e74bbb5fe393684f1105d Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 14:13:16 -0500
Subject: [PATCH 55/82] gdb: sys_mem_xxx have been renamed to _mem_xxx

They are hidden debugging APIs.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 83e4865..4b10b2b 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -807,9 +807,9 @@ static int gdb_mem_probe
 
     /* Check first address */
 
-    if ((preserve && (sys_mem_probe (addr, SYS_MEM_SAFE_READ, width,
+    if ((preserve && (_mem_probe (addr, SYS_MEM_SAFE_READ, width,
                           (char *)&dummy) != 0)) ||
-        (sys_mem_probe (addr, mode, width, (char *)&dummy) != 0))
+        (_mem_probe (addr, mode, width, (char *)&dummy) != 0))
         return (-1);
 
     /* Check if we have tested the whole memory */
@@ -821,8 +821,8 @@ static int gdb_mem_probe
 
     addr = addr + size - width;
     if ((preserve &&
-        (sys_mem_probe (addr, SYS_MEM_SAFE_READ, width, (char *)&dummy) != 0)) ||
-        (sys_mem_probe (addr, mode, width, (char *)&dummy) != 0)) {
+        (_mem_probe (addr, SYS_MEM_SAFE_READ, width, (char *)&dummy) != 0)) ||
+        (_mem_probe (addr, mode, width, (char *)&dummy) != 0)) {
         return (-1);
     }
 
@@ -2410,7 +2410,7 @@ void gdb_handler (int mode, void * exc_regs, int signal) {
     }
 
 static int gdb_instruction_set(void *addr, GDB_INSTR *instruction, size_t size) {
-    if (sys_mem_safe_write_to_text_section(addr,
+    if (_mem_safe_write_to_text_section(addr,
 		(char *) instruction, size) < 0) return -EFAULT;
     sys_cache_flush((vaddr_t)addr, size);
     return 0;
@@ -2624,8 +2624,8 @@ static int init_gdb_server(struct device *unused) {
         uart_register_input(&avail_queue, &cmds_queue);
 #endif
 #ifdef CONFIG_MEM_SAFE_NUM_EXTRA_REGIONS
-        (void)sys_mem_safe_region_add((void *) CONFIG_GDB_RAM_ADDRESS, CONFIG_GDB_RAM_SIZE, SYS_MEM_SAFE_READ);
-        (void)sys_mem_safe_region_add((void *) CONFIG_GDB_RAM_ADDRESS, CONFIG_GDB_RAM_SIZE, SYS_MEM_SAFE_WRITE);
+        (void)_mem_safe_region_add((void *) CONFIG_GDB_RAM_ADDRESS, CONFIG_GDB_RAM_SIZE, SYS_MEM_SAFE_READ);
+        (void)_mem_safe_region_add((void *) CONFIG_GDB_RAM_ADDRESS, CONFIG_GDB_RAM_SIZE, SYS_MEM_SAFE_WRITE);
 #endif
         gdb_is_initialized = 1;
         gdb_system_stop_here(GDB_INVALID_REG_SET);
-- 
1.9.1


From 95c69d24ae35bb101420c8252fbac79461300723 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 14:49:39 -0500
Subject: [PATCH 56/82] samples/gdb_server: use qemu_x86 board instead of
 basic_atom platform

PLATFORM_CONFIG has been replaced by BOARD. basic_atom is deprecated,
qemu_x86 is now the x86 board for QEMU.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/samples/microkernel/apps/gdb_server/Makefile b/samples/microkernel/apps/gdb_server/Makefile
index 824b540..01ab057 100644
--- a/samples/microkernel/apps/gdb_server/Makefile
+++ b/samples/microkernel/apps/gdb_server/Makefile
@@ -1,6 +1,6 @@
 MDEF_FILE = prj.mdef
 KERNEL_TYPE = micro
-PLATFORM_CONFIG ?= basic_atom
+BOARD ?= qemu_x86
 CONF_FILE = prj_$(ARCH).conf
 
 include ${ZEPHYR_BASE}/Makefile.inc
-- 
1.9.1


From 95ce000d3f2b937438059fd223d3996129e4d901 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 14:53:05 -0500
Subject: [PATCH 57/82] arch/x86/core/fatal.c: update gdb_server.h path

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/core/fatal.c b/arch/x86/core/fatal.c
index 93d441e..3fb3ee2 100644
--- a/arch/x86/core/fatal.c
+++ b/arch/x86/core/fatal.c
@@ -32,7 +32,7 @@
 
 #ifdef CONFIG_GDB_SERVER
 #include <debug/gdb_arch.h>
-#include <debug/gdb_server.h>
+#include <misc/debug/gdb_server.h>
 #endif
 
 /*
-- 
1.9.1


From a695884663e19314164888796eda1506fd715f5b Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 14:53:05 -0500
Subject: [PATCH 58/82] arch/x86/debug/gdb_arch.c: update gdb_server.h path

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index 021aa05..42d3671 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -36,7 +36,7 @@
 #include <nano_private.h>
 #include <string.h>
 #include <debug/gdb_arch.h>
-#include <debug/gdb_server.h>
+#include <misc/debug/gdb_server.h>
 
 /* defines */
 
-- 
1.9.1


From 122a2ad300287be2efe5f58d21eb57feb295ba1d Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 14:53:05 -0500
Subject: [PATCH 59/82] arch/x86/include/debug/gdb_arch.h: update gdb_server.h
 path

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
index e49cccb..5ef8814 100644
--- a/arch/x86/include/debug/gdb_arch.h
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -38,7 +38,7 @@ extern "C" {
 #endif /* __cplusplus */
 
 #include <nano_private.h>
-#include <debug/gdb_server.h>
+#include <misc/debug/gdb_server.h>
 
 /* define */
 
-- 
1.9.1


From 821e76fbbfcc790a30c2332acbf4ce778f9b16a7 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 14:53:05 -0500
Subject: [PATCH 60/82] drivers/console/uart_console.c: update gdb_server.h
 path

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/drivers/console/uart_console.c b/drivers/console/uart_console.c
index 6cd4429..af1f68c 100644
--- a/drivers/console/uart_console.c
+++ b/drivers/console/uart_console.c
@@ -43,7 +43,7 @@
 #include <misc/printk.h>
 
 #ifdef CONFIG_GDB_SERVER
-#include <debug/gdb_server.h>
+#include <misc/debug/gdb_server.h>
 #endif
 
 static struct device *uart_console_dev;
-- 
1.9.1


From 36224e3a89f2979f4f89919b741cbf87f9f8a917 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 16:28:56 -0500
Subject: [PATCH 61/82] gdb: correct path to uart_console.h

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 4b10b2b..d000dd8 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -375,7 +375,7 @@ Notification Packets:
 #include <gdb_server.h>
 #include <debug_info.h>
 #ifdef CONFIG_GDB_SERVER_INTERRUPT_DRIVEN
-#include <console/uart_console.h>
+#include <drivers/console/uart_console.h>
 #endif
 #ifdef CONFIG_REBOOT
 #include <misc/reboot.h>
-- 
1.9.1


From 6d2dc381f6cb5e6986be7adc2d09b1808f1fa2c6 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 16:46:52 -0500
Subject: [PATCH 62/82] gdb: select CACHE_FLUSHING

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/Kconfig b/misc/debug/Kconfig
index 67ff5f0..6e4a474 100644
--- a/misc/debug/Kconfig
+++ b/misc/debug/Kconfig
@@ -86,6 +86,7 @@ config	GDB_SERVER
 	bool
 	prompt "Enable GDB Server [EXPERIMENTAL]"
 	default n
+	select CACHE_FLUSHING
 	select REBOOT
 	select MEM_SAFE
 	select DEBUG_INFO
-- 
1.9.1


From daceef49b201df4249c12976681de033961e901a Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 16:47:18 -0500
Subject: [PATCH 63/82] gdb: add include/drivers to the include path

gdb_server.c needs it to be able to include uart.h.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/misc/debug/Makefile b/misc/debug/Makefile
index f6b8c73..eaf2ee6 100644
--- a/misc/debug/Makefile
+++ b/misc/debug/Makefile
@@ -1,4 +1,5 @@
 ccflags-y +=-I$(srctree)/include/misc/debug
+CFLAGS_gdb_server.o =-I$(srctree)/include/drivers
 
 obj-y =
 obj-$(CONFIG_MEM_SAFE_CHECK_BOUNDARIES) += mem_safe_check_boundaries.o
-- 
1.9.1


From 8b47fb541811fa0a0052e73c78a4bdf88286a737 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 18 Jan 2016 17:36:00 -0500
Subject: [PATCH 64/82] x86: move reboot via RST_CNT from galileo to generic
 x86

That implementation is not galileo-specific, but rather a generic way of
rebooting an x86 target. Needs SoC support.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 165b98f..85ef5b4 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -117,7 +117,21 @@ config SSE_FP_MATH
 	Disabling this option means that the compiler utilizes only the
 	x87 instruction set for floating point operations.
 
+choice
+prompt "Reboot implementation"
+depends on REBOOT
+default REBOOT_RST_CNT
+
+config REBOOT_RST_CNT
+	bool
+	prompt "Reboot via RST_CNT register"
+	help
+	Reboot via the RST_CNT register, going back to BIOS.
+
+endchoice
+
 endmenu
+
 config ISA_IA32
 	bool
 	default y
diff --git a/arch/x86/core/Makefile b/arch/x86/core/Makefile
index 13aa5b7..a427fae 100644
--- a/arch/x86/core/Makefile
+++ b/arch/x86/core/Makefile
@@ -29,3 +29,4 @@ obj-$(CONFIG_ERRNO) += errno.o
 obj-$(CONFIG_GDT_DYNAMIC) += gdt.o
 
 obj-$(CONFIG_DEBUG_INFO) += debug/
+obj-$(CONFIG_REBOOT_RST_CNT) += reboot_rst_cnt.o
diff --git a/arch/x86/core/reboot_rst_cnt.c b/arch/x86/core/reboot_rst_cnt.c
new file mode 100644
index 0000000..0a8b611
--- /dev/null
+++ b/arch/x86/core/reboot_rst_cnt.c
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file x86-specific reboot functionalities
+ *
+ * @details Implements the required 'arch' sub-APIs.
+ */
+
+#include <nanokernel.h>
+#include <misc/reboot.h>
+
+static inline void cold_reboot(void)
+{
+	uint8_t reset_value = SYS_X86_RST_CNT_CPU_RST | SYS_X86_RST_CNT_SYS_RST |
+							SYS_X86_RST_CNT_FULL_RST;
+	sys_out8(reset_value, SYS_X86_RST_CNT_REG);
+}
+
+void sys_arch_reboot(int type)
+{
+	switch (type) {
+	case SYS_REBOOT_COLD:
+		cold_reboot();
+		break;
+	default:
+		/* do nothing */
+		break;
+	}
+}
diff --git a/boards/galileo/Makefile b/boards/galileo/Makefile
index b1a9b55..768d1b9 100644
--- a/boards/galileo/Makefile
+++ b/boards/galileo/Makefile
@@ -4,4 +4,3 @@ asflags-y := ${ccflags-y}
 
 obj-y += board.o
 obj-$(CONFIG_PINMUX) += galileo_pinmux.o
-obj-$(CONFIG_REBOOT) += galileo_reboot.o
diff --git a/boards/galileo/galileo_reboot.c b/boards/galileo/galileo_reboot.c
deleted file mode 100644
index 0a8b611..0000000
--- a/boards/galileo/galileo_reboot.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2015 Wind River Systems, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file x86-specific reboot functionalities
- *
- * @details Implements the required 'arch' sub-APIs.
- */
-
-#include <nanokernel.h>
-#include <misc/reboot.h>
-
-static inline void cold_reboot(void)
-{
-	uint8_t reset_value = SYS_X86_RST_CNT_CPU_RST | SYS_X86_RST_CNT_SYS_RST |
-							SYS_X86_RST_CNT_FULL_RST;
-	sys_out8(reset_value, SYS_X86_RST_CNT_REG);
-}
-
-void sys_arch_reboot(int type)
-{
-	switch (type) {
-	case SYS_REBOOT_COLD:
-		cold_reboot();
-		break;
-	default:
-		/* do nothing */
-		break;
-	}
-}
-- 
1.9.1


From 4b75e96939ea2a44886591da100362e27fc54e13 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 26 Jan 2016 11:16:39 -0500
Subject: [PATCH 65/82] gdb: fix default number of EXC_NOERR stubs when
 GDB_SERVER


diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 85ef5b4..27324a6 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -255,8 +255,8 @@ config NUM_DYNAMIC_EXC_STUBS
 
 config NUM_DYNAMIC_EXC_NOERR_STUBS
 	int "Number of dynamic no-error exception stubs"
-	default 0
 	default 3 if GDB_SERVER
+	default 0
 	help
 	This option specifies the maximum number of dynamically allocated
 	exception stubs that are to be used with exceptions that do not push
-- 
1.9.1


From 4b93530d71bc95a87c2ca3195923f972ca782beb Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Fri, 29 Jan 2016 16:12:24 -0500
Subject: [PATCH 66/82] gdb: replace obsolete device APIs by SYS_INIT


diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index d000dd8..25bf7aa 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -2633,5 +2633,4 @@ static int init_gdb_server(struct device *unused) {
     return 0;
 }
 
-DECLARE_DEVICE_INIT_CONFIG(gdb_server, "", init_gdb_server, NULL);
-SYS_DEFINE_DEVICE(gdb_server, NULL, NANOKERNEL, 1);
+SYS_INIT(init_gdb_server, NANOKERNEL, 1);
-- 
1.9.1


From d347b77b86ed6bc1662679c299dff53c0cd5bace Mon Sep 17 00:00:00 2001
From: Jeff Blais <jblais@windriver.com>
Date: Fri, 29 Jan 2016 16:23:38 -0500
Subject: [PATCH 67/82] arm: add generic memory-mapped I/O routines for
 Cortex-M

Add sys_read32(), sys_write32 and sys_set_bit().

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/include/arch/arm/arch.h b/include/arch/arm/arch.h
index a329c65..ed83037 100644
--- a/include/arch/arm/arch.h
+++ b/include/arch/arm/arch.h
@@ -50,6 +50,7 @@ extern "C" {
 #include <arch/arm/cortex_m/gdb_stub.h>
 #include <arch/arm/cortex_m/asm_inline.h>
 #include <arch/arm/cortex_m/addr_types.h>
+#include <arch/arm/cortex_m/sys_io.h>
 #endif
 
 #define STACK_ALIGN  4
diff --git a/include/arch/arm/cortex_m/sys_io.h b/include/arch/arm/cortex_m/sys_io.h
new file mode 100644
index 0000000..6834189
--- /dev/null
+++ b/include/arch/arm/cortex_m/sys_io.h
@@ -0,0 +1,108 @@
+/* sys_io.c - ARM CORTEX-M Series memory mapped register I/O operations  */
+
+/*
+ * Copyright (c) 2015 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _CORTEX_M_SYS_IO_H_
+#define _CORTEX_M_SYS_IO_H_
+
+#if !defined(_ASMLANGUAGE)
+
+#include <sys_io.h>
+
+/* Memory mapped registers I/O functions */
+
+/**
+ * @fn static inline uint32_t sys_read32(mem_addr_t addr);
+ * @brief Read 32 bits from a memory mapped register
+ *
+ * This function reads 32 bits from the given memory mapped register.
+ *
+ * @param addr the memory mapped register address from where to read
+ *        the 32 bits
+ *
+ * @return the 32 bits read
+ */
+
+static inline uint32_t sys_read32(mem_addr_t addr)
+{
+	return *(volatile uint32_t *)addr;
+}
+
+
+/**
+ * @fn static inline void sys_write32(uint32_t data, mem_addr_t addr);
+ * @brief Write 32 bits to a memory mapped register
+ *
+ * This function writes 32 bits to the given memory mapped register.
+ *
+ * @param data the 32 bits to write
+ * @param addr the memory mapped register address where to write the 32 bits
+ */
+
+static inline void sys_write32(uint32_t data, mem_addr_t addr)
+{
+	*(volatile uint32_t *)addr = data;
+}
+
+
+/* Memory bit manipulation functions */
+
+/**
+ * @fn static inline void sys_set_bit(uint32_t addr, uint32_t bit)
+ * @brief Set the designated bit to 1
+ *
+ * This functions takes the designated bit starting from addr and sets it to 1.
+ *
+ * @param addr the memory address from where to look for the bit
+ * @param bit the designated bit to set (from 0 to 31)
+ */
+
+static inline void sys_set_bit(mem_addr_t addr, uint32_t bit)
+{
+    uint32_t temp = *(volatile uint32_t *)addr;
+
+    /* prevent out of range writes */
+
+    if (bit < 32) {
+        *(volatile uint32_t *)addr = temp | (1 << bit);
+    }
+}
+
+/**
+ * @fn static inline void sys_clear_bit(mem_addr_t addr, int bit)
+ * @brief Clear the designated bit from addr to 0
+ *
+ * This functions takes the designated bit starting from addr and sets it to 0.
+ *
+ * @param addr the memory address from where to look for the bit
+ * @param bit the designated bit to clear (from 0 to 31)
+ */
+
+static inline void sys_clear_bit(mem_addr_t addr, uint32_t bit)
+{
+    uint32_t temp = *(volatile uint32_t *)addr;
+
+    /* prevent out of range writes */
+
+    if (bit < 32) {
+       *(volatile uint32_t *)addr = temp & ~(1 << bit);
+    }
+}
+
+#endif /* !_ASMLANGUAGE */
+
+#endif /* _CORTEX_M_SYS_IO_H_ */
-- 
1.9.1


From e050da7ae1e7631e0bc3a4621745813f30a50677 Mon Sep 17 00:00:00 2001
From: Jeff Blais <jblais@windriver.com>
Date: Tue, 3 Nov 2015 08:52:12 -0500
Subject: [PATCH 68/82] arm: Freescale K64 GPIO driver

Basic driver support for the Freescale K64 GPIO module.
Note that only pin direction, read and write are supported.

diff --git a/arch/arm/soc/fsl_frdm_k64f/Kconfig b/arch/arm/soc/fsl_frdm_k64f/Kconfig
index 7ffec5e..af6461e 100644
--- a/arch/arm/soc/fsl_frdm_k64f/Kconfig
+++ b/arch/arm/soc/fsl_frdm_k64f/Kconfig
@@ -159,4 +159,58 @@ config BLUETOOTH_UART_IRQ_PRI
 
 endif
 
+config GPIO
+	def_bool y
+
+if GPIO
+
+config GPIO_K64
+	def_bool y
+
+config GPIO_K64_A
+	def_bool y
+
+config GPIO_K64_B
+	def_bool y
+
+config GPIO_K64_C
+	def_bool y
+
+config GPIO_K64_D
+	def_bool y
+
+config GPIO_K64_E
+	def_bool y
+
+if GPIO_K64
+config PORT_K64_BASE_ADDR
+    default 0x40049000
+endif
+
+if GPIO_K64_A
+config GPIO_K64_A_BASE_ADDR
+    default 0x400FF000
+endif
+
+if GPIO_K64_B
+config GPIO_K64_B_BASE_ADDR
+    default 0x400FF040
+endif
+
+if GPIO_K64_C
+config GPIO_K64_C_BASE_ADDR
+    default 0x400FF080
+endif
+
+if GPIO_K64_D
+config GPIO_K64_D_BASE_ADDR
+    default 0x400FF0C0
+endif
+
+if GPIO_K64_E
+config GPIO_K64_E_BASE_ADDR
+    default 0x400FF100
+endif
+endif
+
 endif
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index f7f24de..9ed4f9c 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -703,4 +703,111 @@ config GPIO_SCH_1_BITS
 	help
 	  The total of pins the controller can manage (CPU dependent)
 
+config GPIO_K64
+	bool "Freescale K64-based GPIO driver"
+	depends on GPIO
+	default n
+	help
+	  Enable driver for MMIO-based GPIOs.
+
+config PORT_K64_BASE_ADDR
+       hex "Freescale K64-based Port Control base address"
+       depends on GPIO_K64
+       default 0x00000000
+
+config GPIO_K64_A
+	bool "Freescale K64-based GPIO Port A"
+	depends on GPIO_K64
+	default n
+	help
+	  Enable config options for Freescale K64-based GPIO port A.
+
+config GPIO_K64_A_DEV_NAME
+	string "Freescale K64-based GPIO Port A Device Name"
+	depends on GPIO_K64_A
+	default "GPIO_K64_A"
+	help
+	  Specify the device name.
+
+config GPIO_K64_A_BASE_ADDR
+       hex "Freescale K64-based GPIO Port A base address"
+       depends on GPIO_K64_A
+       default 0x00000000
+
+config GPIO_K64_B
+	bool "Freescale K64-based GPIO Port B"
+	depends on GPIO_K64
+	default n
+	help
+	  Enable config options for Freescale K64-based GPIO port A.
+
+config GPIO_K64_B_DEV_NAME
+	string "Freescale K64-based GPIO Port B Device Name"
+	depends on GPIO_K64_B
+	default "GPIO_K64_B"
+	help
+	  Specify the device name.
+
+config GPIO_K64_B_BASE_ADDR
+       hex "Freescale K64-based GPIO Port B base address"
+       depends on GPIO_K64_B
+       default 0x00000000
+
+config GPIO_K64_C
+	bool "Freescale K64-based GPIO Port B"
+	depends on GPIO_K64
+	default n
+	help
+	  Enable config options for Freescale K64-based GPIO port A.
+
+config GPIO_K64_C_DEV_NAME
+	string "Freescale K64-based GPIO Port B Device Name"
+	depends on GPIO_K64_C
+	default "GPIO_K64_C"
+	help
+	  Specify the device name.
+
+config GPIO_K64_C_BASE_ADDR
+       hex "Freescale K64-based GPIO Port C base address"
+       depends on GPIO_K64_C
+       default 0x00000000
+
+config GPIO_K64_D
+	bool "Freescale K64-based GPIO Port D"
+	depends on GPIO_K64
+	default n
+	help
+	  Enable config options for Freescale K64-based GPIO port A.
+
+config GPIO_K64_D_DEV_NAME
+	string "Freescale K64-based GPIO Port D Device Name"
+	depends on GPIO_K64_D
+	default "GPIO_K64_D"
+	help
+	  Specify the device name.
+
+config GPIO_K64_D_BASE_ADDR
+       hex "Freescale K64-based GPIO Port D base address"
+       depends on GPIO_K64_D
+       default 0x00000000
+
+config GPIO_K64_E
+	bool "Freescale K64-based GPIO Port E"
+	depends on GPIO_K64
+	default n
+	help
+	  Enable config options for Freescale K64-based GPIO port A.
+
+config GPIO_K64_E_DEV_NAME
+	string "Freescale K64-based GPIO Port E Device Name"
+	depends on GPIO_K64_E
+	default "GPIO_K64_E"
+	help
+	  Specify the device name.
+
+config GPIO_K64_E_BASE_ADDR
+       hex "Freescale K64-based GPIO Port E base address"
+       depends on GPIO_K64_E
+       default 0x00000000
+
 endif # GPIO
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 5dbb626..d5fe144 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -6,3 +6,5 @@ obj-$(CONFIG_GPIO_PCAL9535A) += gpio_pcal9535a.o
 obj-$(CONFIG_GPIO_MMIO) += gpio_mmio.o
 obj-$(CONFIG_GPIO_SCH) += gpio_sch.o
 obj-$(CONFIG_GPIO_QMSI) += gpio_qmsi.o
+
+obj-$(CONFIG_GPIO_K64) += gpio_k64.o
diff --git a/drivers/gpio/gpio_k64.c b/drivers/gpio/gpio_k64.c
new file mode 100644
index 0000000..c924499
--- /dev/null
+++ b/drivers/gpio/gpio_k64.c
@@ -0,0 +1,280 @@
+/*
+ * Copyright (c) 2015, Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file Driver for the Freescale K64 GPIO module.
+ */
+
+#include <nanokernel.h>
+#include <device.h>
+#include <init.h>
+#include <gpio.h>
+
+#include "gpio_k64.h"
+
+
+/**
+ * @brief Configure pin or port
+ *
+ * @param dev Device struct
+ * @param access_op Access operation (pin or port)
+ * @param pin The pin number
+ * @param flags Flags of pin or port
+ *
+ * @return DEV_OK if successful, failed otherwise
+ */
+static int gpio_k64_config(struct device *dev, int access_op,
+					       uint32_t pin, int flags)
+{
+	const struct gpio_k64_config * const cfg = dev->config->config_info;
+	uint32_t value = 0;
+
+	/*
+     * Setup direction register:
+	 * 0 - pin is input, 1 - pin is output
+	 */
+
+	switch (access_op) {
+		case GPIO_ACCESS_BY_PIN:
+            if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
+                sys_clear_bit((cfg->base_addr + GPIO_K64_DIR_OFFSET), pin);
+            } else {
+                sys_set_bit((cfg->base_addr + GPIO_K64_DIR_OFFSET), pin);
+            }
+			break;
+		case GPIO_ACCESS_BY_PORT:
+            if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
+                value = 0x0;
+            } else {
+		        value = 0xFFFFFFFF;
+            }
+			sys_write32(value, (cfg->base_addr + GPIO_K64_DIR_OFFSET));
+			break;
+		default:
+			return DEV_INVALID_OP;
+	}
+
+	return DEV_OK;
+}
+
+/**
+ * @brief Set the pin or port output
+ *
+ * @param dev Device struct
+ * @param access_op Access operation (pin or port)
+ * @param pin The pin number
+ * @param value Value to set (0 or 1)
+ *
+ * @return DEV_OK if successful, failed otherwise
+ */
+static int gpio_k64_write(struct device *dev, int access_op,
+			              uint32_t pin, uint32_t value)
+{
+	const struct gpio_k64_config * const cfg = dev->config->config_info;
+
+	switch (access_op) {
+		case GPIO_ACCESS_BY_PIN:
+            if (value) {
+                sys_set_bit((cfg->base_addr + GPIO_K64_DATA_OUT_OFFSET), pin);
+            } else {
+                sys_clear_bit((cfg->base_addr + GPIO_K64_DATA_OUT_OFFSET), pin);
+            }
+			break;
+		case GPIO_ACCESS_BY_PORT:
+			sys_write32(value, (cfg->base_addr + GPIO_K64_DATA_OUT_OFFSET));
+			break;
+		default:
+			return DEV_INVALID_OP;
+	}
+
+	return DEV_OK;
+}
+
+/**
+ * @brief Read the input pin or port status
+ *
+ * @param dev Device struct
+ * @param access_op Access operation (pin or port)
+ * @param pin The pin number
+ * @param value Value of input pin(s)
+ *
+ * @return DEV_OK if successful, failed otherwise
+ */
+static int gpio_k64_read(struct device *dev, int access_op,
+				         uint32_t pin, uint32_t *value)
+{
+	const struct gpio_k64_config * const cfg = dev->config->config_info;
+
+	*value = sys_read32((cfg->base_addr + GPIO_K64_DATA_IN_OFFSET));
+
+	switch (access_op) {
+		case GPIO_ACCESS_BY_PIN:
+			*value = (*value & (1 << pin)) >> pin;
+			break;
+		case GPIO_ACCESS_BY_PORT:
+			break;
+		default:
+			return DEV_INVALID_OP;
+	}
+
+	return DEV_OK;
+}
+
+static int gpio_k64_set_callback(struct device *dev, gpio_callback_t callback)
+{
+	ARG_UNUSED(dev);
+	ARG_UNUSED(callback);
+
+	return DEV_INVALID_OP;
+}
+
+static int gpio_k64_enable_callback(struct device *dev, int access_op,
+                                    uint32_t pin)
+{
+	ARG_UNUSED(dev);
+	ARG_UNUSED(access_op);
+	ARG_UNUSED(pin);
+
+	return DEV_INVALID_OP;
+}
+
+static int gpio_k64_disable_callback(struct device *dev, int access_op,
+                                     uint32_t pin)
+{
+	ARG_UNUSED(dev);
+	ARG_UNUSED(access_op);
+	ARG_UNUSED(pin);
+
+	return DEV_INVALID_OP;
+}
+
+static int gpio_k64_suspend_port(struct device *dev)
+{
+	ARG_UNUSED(dev);
+
+	return DEV_INVALID_OP;
+}
+
+static int gpio_k64_resume_port(struct device *dev)
+{
+	ARG_UNUSED(dev);
+
+	return DEV_INVALID_OP;
+}
+
+static struct gpio_driver_api gpio_k64_drv_api_funcs = {
+	.config = gpio_k64_config,
+	.write = gpio_k64_write,
+	.read = gpio_k64_read,
+	.set_callback = gpio_k64_set_callback,
+	.enable_callback = gpio_k64_enable_callback,
+	.disable_callback = gpio_k64_disable_callback,
+	.suspend = gpio_k64_suspend_port,
+	.resume = gpio_k64_resume_port,
+};
+
+/**
+ * @brief Initialization function of Freescale K64-based GPIO port
+ *
+ * @param dev Device struct
+ * @return DEV_OK if successful, failed otherwise.
+ */
+int gpio_k64_init(struct device *dev)
+{
+	dev->driver_api = &gpio_k64_drv_api_funcs;
+
+	return DEV_OK;
+}
+
+/* Initialization for Port A */
+#ifdef CONFIG_GPIO_K64_A
+
+static struct gpio_k64_config gpio_k64_A_cfg = {
+    .base_addr = CONFIG_GPIO_K64_A_BASE_ADDR,
+};
+
+DECLARE_DEVICE_INIT_CONFIG(gpio_k64_A,
+			               CONFIG_GPIO_K64_A_DEV_NAME,
+			               gpio_k64_init,
+			               &gpio_k64_A_cfg);
+
+pre_kernel_late_init(gpio_k64_A, (void *)0);
+
+#endif /* CONFIG_GPIO_K64_A */
+
+/* Initialization for Port B */
+#ifdef CONFIG_GPIO_K64_B
+
+static struct gpio_k64_config gpio_k64_B_cfg = {
+    .base_addr = CONFIG_GPIO_K64_B_BASE_ADDR,
+};
+
+DECLARE_DEVICE_INIT_CONFIG(gpio_k64_B,
+			               CONFIG_GPIO_K64_B_DEV_NAME,
+			               gpio_k64_init,
+			               &gpio_k64_B_cfg);
+
+pre_kernel_late_init(gpio_k64_B, (void *)0);
+
+#endif /* CONFIG_GPIO_K64_B */
+
+/* Initialization for Port C */
+#ifdef CONFIG_GPIO_K64_C
+
+static struct gpio_k64_config gpio_k64_C_cfg = {
+    .base_addr = CONFIG_GPIO_K64_C_BASE_ADDR,
+};
+
+DECLARE_DEVICE_INIT_CONFIG(gpio_k64_C,
+			               CONFIG_GPIO_K64_C_DEV_NAME,
+			               gpio_k64_init,
+			               &gpio_k64_C_cfg);
+
+pre_kernel_late_init(gpio_k64_C, (void *)0);
+
+#endif /* CONFIG_GPIO_K64_C */
+
+/* Initialization for Port D */
+#ifdef CONFIG_GPIO_K64_D
+
+static struct gpio_k64_config gpio_k64_D_cfg = {
+    .base_addr = CONFIG_GPIO_K64_D_BASE_ADDR,
+};
+
+DECLARE_DEVICE_INIT_CONFIG(gpio_k64_D,
+			               CONFIG_GPIO_K64_D_DEV_NAME,
+			               gpio_k64_init,
+			               &gpio_k64_D_cfg);
+
+pre_kernel_late_init(gpio_k64_D, (void *)0);
+
+#endif /* CONFIG_GPIO_K64_D */
+
+/* Initialization for Port E */
+#ifdef CONFIG_GPIO_K64_E
+
+static struct gpio_k64_config gpio_k64_E_cfg = {
+    .base_addr = CONFIG_GPIO_K64_E_BASE_ADDR,
+};
+
+DECLARE_DEVICE_INIT_CONFIG(gpio_k64_E,
+			               CONFIG_GPIO_K64_E_DEV_NAME,
+			               gpio_k64_init,
+			               &gpio_k64_E_cfg);
+
+pre_kernel_late_init(gpio_k64_E, (void *)0);
+
+#endif /* CONFIG_GPIO_K64_E */
diff --git a/drivers/gpio/gpio_k64.h b/drivers/gpio/gpio_k64.h
new file mode 100644
index 0000000..c889368
--- /dev/null
+++ b/drivers/gpio/gpio_k64.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2015, Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file Header file for the Freescale K64 GPIO module.
+ */
+
+#ifndef _GPIO_K64_H_
+#define _GPIO_K64_H_
+
+#include <nanokernel.h>
+
+#include <gpio.h>
+
+/* GPIO Port Register offsets */
+
+#define GPIO_K64_DATA_OUT_OFFSET    0x00  /* Port Data Output Reg. offset */
+#define GPIO_K64_SET_OUT_OFFSET     0x04  /* Port Set Output Reg. offset */
+#define GPIO_K64_CLR_OUT_OFFSET     0x08  /* Port Clear Output Reg. offset */
+#define GPIO_K64_TOGGLE_OUT_OFFSET  0x0C  /* Port Toggle Output  Reg. offset */
+#define GPIO_K64_DATA_IN_OFFSET     0x10  /* Port Data Input Reg. offset */
+#define GPIO_K64_DIR_OFFSET         0x14  /* Port Data Direction Reg. offset */
+
+/**
+ * @brief Initialization function for GPIO driver
+ *
+ * @param dev Device struct
+ * @return DEV_OK if successful, failed otherwise
+ */
+extern int gpio_k64_init(struct device *dev);
+
+/* internal use only for register access function */
+typedef uint32_t (*__gpio_k64_access_t)(uint32_t addr, uint32_t bit,
+					 uint32_t value);
+
+/** Configuration data */
+struct gpio_k64_config {
+	/* base address */
+	uint32_t base_addr;
+};
+
+#endif /* _GPIO_K64_H_ */
-- 
1.9.1


From 4006c3e7e56e5e54c06161709fefb74029384663 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 2 Feb 2016 13:22:37 -0500
Subject: [PATCH 69/82] k64f/gpio: use new DEVICE_INIT


diff --git a/drivers/gpio/gpio_k64.c b/drivers/gpio/gpio_k64.c
index c924499..0e8e60d 100644
--- a/drivers/gpio/gpio_k64.c
+++ b/drivers/gpio/gpio_k64.c
@@ -206,12 +206,9 @@ static struct gpio_k64_config gpio_k64_A_cfg = {
     .base_addr = CONFIG_GPIO_K64_A_BASE_ADDR,
 };
 
-DECLARE_DEVICE_INIT_CONFIG(gpio_k64_A,
-			               CONFIG_GPIO_K64_A_DEV_NAME,
-			               gpio_k64_init,
-			               &gpio_k64_A_cfg);
-
-pre_kernel_late_init(gpio_k64_A, (void *)0);
+DEVICE_INIT(gpio_k64_A, CONFIG_GPIO_K64_A_DEV_NAME, gpio_k64_init,
+			(void *)0, &gpio_k64_A_cfg,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
 #endif /* CONFIG_GPIO_K64_A */
 
@@ -222,12 +219,9 @@ static struct gpio_k64_config gpio_k64_B_cfg = {
     .base_addr = CONFIG_GPIO_K64_B_BASE_ADDR,
 };
 
-DECLARE_DEVICE_INIT_CONFIG(gpio_k64_B,
-			               CONFIG_GPIO_K64_B_DEV_NAME,
-			               gpio_k64_init,
-			               &gpio_k64_B_cfg);
-
-pre_kernel_late_init(gpio_k64_B, (void *)0);
+DEVICE_INIT(gpio_k64_B, CONFIG_GPIO_K64_B_DEV_NAME, gpio_k64_init,
+			(void *)0, &gpio_k64_B_cfg,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
 #endif /* CONFIG_GPIO_K64_B */
 
@@ -238,12 +232,9 @@ static struct gpio_k64_config gpio_k64_C_cfg = {
     .base_addr = CONFIG_GPIO_K64_C_BASE_ADDR,
 };
 
-DECLARE_DEVICE_INIT_CONFIG(gpio_k64_C,
-			               CONFIG_GPIO_K64_C_DEV_NAME,
-			               gpio_k64_init,
-			               &gpio_k64_C_cfg);
-
-pre_kernel_late_init(gpio_k64_C, (void *)0);
+DEVICE_INIT(gpio_k64_C, CONFIG_GPIO_K64_C_DEV_NAME, gpio_k64_init,
+			(void *)0, &gpio_k64_C_cfg,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
 #endif /* CONFIG_GPIO_K64_C */
 
@@ -254,12 +245,9 @@ static struct gpio_k64_config gpio_k64_D_cfg = {
     .base_addr = CONFIG_GPIO_K64_D_BASE_ADDR,
 };
 
-DECLARE_DEVICE_INIT_CONFIG(gpio_k64_D,
-			               CONFIG_GPIO_K64_D_DEV_NAME,
-			               gpio_k64_init,
-			               &gpio_k64_D_cfg);
-
-pre_kernel_late_init(gpio_k64_D, (void *)0);
+DEVICE_INIT(gpio_k64_D, CONFIG_GPIO_K64_D_DEV_NAME, gpio_k64_init,
+			(void *)0, &gpio_k64_D_cfg,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
 #endif /* CONFIG_GPIO_K64_D */
 
@@ -270,11 +258,8 @@ static struct gpio_k64_config gpio_k64_E_cfg = {
     .base_addr = CONFIG_GPIO_K64_E_BASE_ADDR,
 };
 
-DECLARE_DEVICE_INIT_CONFIG(gpio_k64_E,
-			               CONFIG_GPIO_K64_E_DEV_NAME,
-			               gpio_k64_init,
-			               &gpio_k64_E_cfg);
-
-pre_kernel_late_init(gpio_k64_E, (void *)0);
+DEVICE_INIT(gpio_k64_E, CONFIG_GPIO_K64_E_DEV_NAME, gpio_k64_init,
+			(void *)0, &gpio_k64_E_cfg,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
 #endif /* CONFIG_GPIO_K64_E */
-- 
1.9.1


From 86604eb45bbef1dd3fd404f7d9f0e33379f4b751 Mon Sep 17 00:00:00 2001
From: Jeff Blais <jblais@windriver.com>
Date: Fri, 20 Nov 2015 13:17:55 -0500
Subject: [PATCH 70/82] pinmux: Expand the pin function/mode parameter size

The pinmux API was modified to expand the meaning of the 'func' argument
to allow it to represent more than a pre-configured function.  This was done
to reasonably accommodate a larger range of pin configuration options
offered by other MCUs, such as the Freescale K64 (up to 8 pin functions,
plus interrupt, pullup/down, drive strength, open-drain, slew rate, etc.).
This allows bit fields to be used to define various settings.

diff --git a/boards/galileo/galileo_pinmux.c b/boards/galileo/galileo_pinmux.c
index 125e442..623365e 100644
--- a/boards/galileo/galileo_pinmux.c
+++ b/boards/galileo/galileo_pinmux.c
@@ -630,7 +630,7 @@ uint8_t _galileo_set_pin(struct device *port, uint8_t pin, uint8_t func)
 #ifdef CONFIG_PINMUX_DEV
 static uint32_t galileo_dev_set(struct device *dev,
 				uint32_t pin,
-				uint8_t func)
+				uint32_t func)
 {
 	if (pin > CONFIG_PINMUX_NUM_PINS) {
 		return DEV_INVALID_CONF;
@@ -638,12 +638,12 @@ static uint32_t galileo_dev_set(struct device *dev,
 
 	mux_config[pin].mode = func;
 
-	return _galileo_set_pin(dev, pin, func);
+	return _galileo_set_pin(dev, pin, (uint8_t)func);
 }
 
 static uint32_t galileo_dev_get(struct device *dev,
 				uint32_t pin,
-				uint8_t *func)
+				uint32_t *func)
 {
 	if (pin > CONFIG_PINMUX_NUM_PINS) {
 		return DEV_INVALID_CONF;
@@ -656,7 +656,7 @@ static uint32_t galileo_dev_get(struct device *dev,
 #else
 static uint32_t galileo_dev_set(struct device *dev,
 				uint32_t pin,
-				uint8_t func)
+				uint32_t func)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(pin);
@@ -667,7 +667,7 @@ static uint32_t galileo_dev_set(struct device *dev,
 
 static uint32_t galileo_dev_get(struct device *dev,
 				uint32_t pin,
-				uint8_t *func)
+				uint32_t *func)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(pin);
diff --git a/drivers/pinmux/pinmux.h b/drivers/pinmux/pinmux.h
index c73dd07..a4117a7 100644
--- a/drivers/pinmux/pinmux.h
+++ b/drivers/pinmux/pinmux.h
@@ -27,7 +27,7 @@ extern "C" {
 
 struct pin_config {
 	uint8_t pin_num;
-	uint8_t mode;
+	uint32_t mode;
 };
 
 struct pinmux_config {
diff --git a/include/pinmux.h b/include/pinmux.h
index b9687ed..74da6aa 100644
--- a/include/pinmux.h
+++ b/include/pinmux.h
@@ -45,8 +45,8 @@ extern "C" {
 #define PINMUX_INPUT_ENABLED	(0x1)
 #define PINMUX_OUTPUT_ENABLED	(0x0)
 
-typedef uint32_t (*pmux_set)(struct device *dev, uint32_t pin, uint8_t func);
-typedef uint32_t (*pmux_get)(struct device *dev, uint32_t pin, uint8_t *func);
+typedef uint32_t (*pmux_set)(struct device *dev, uint32_t pin, uint32_t func);
+typedef uint32_t (*pmux_get)(struct device *dev, uint32_t pin, uint32_t *func);
 typedef uint32_t (*pmux_pullup)(struct device *dev, uint32_t pin, uint8_t func);
 typedef uint32_t (*pmux_input)(struct device *dev, uint32_t pin, uint8_t func);
 
@@ -58,9 +58,17 @@ struct pinmux_driver_api {
 };
 
 
+/**
+ * @brief Set the functionality of a pin
+ * @param dev Pointer to the device structure for the driver instance
+ * @param pin Pin identifier
+ * @param func Platform-specific 32-bit value describing the pin configuration.
+ *
+ * @return DEV_OK if successful, another DEV_* code otherwise.
+ */
 static inline uint32_t pinmux_pin_set(struct device *dev,
 				      uint32_t pin,
-				      uint8_t func)
+				      uint32_t func)
 {
 	struct pinmux_driver_api *api;
 
@@ -68,9 +76,18 @@ static inline uint32_t pinmux_pin_set(struct device *dev,
 	return api->set(dev, pin, func);
 }
 
+/**
+ * @brief Get the functionality of a pin
+ * @param dev Pointer to the device structure for the driver instance
+ * @param pin Pin identifier
+ * @param func Pointer to a platform-specific 32-bit value describing the
+ *             pin configuration.
+ *
+ * @return DEV_OK if successful, another DEV_* code otherwise.
+ */
 static inline uint32_t pinmux_pin_get(struct device *dev,
 				      uint32_t pin,
-				      uint8_t *func)
+				      uint32_t *func)
 {
 	struct pinmux_driver_api *api;
 
-- 
1.9.1


From ee84264802a1dcf34de735d00e203c9bc486e1fb Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Mon, 1 Feb 2016 17:30:48 -0500
Subject: [PATCH 71/82] k64f: GPIO changes pre-pinmux support

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 9ed4f9c..e56ce43 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -708,12 +708,7 @@ config GPIO_K64
 	depends on GPIO
 	default n
 	help
-	  Enable driver for MMIO-based GPIOs.
-
-config PORT_K64_BASE_ADDR
-       hex "Freescale K64-based Port Control base address"
-       depends on GPIO_K64
-       default 0x00000000
+	  Enable driver for Freescale K64-based GPIOs.
 
 config GPIO_K64_A
 	bool "Freescale K64-based GPIO Port A"
@@ -730,9 +725,14 @@ config GPIO_K64_A_DEV_NAME
 	  Specify the device name.
 
 config GPIO_K64_A_BASE_ADDR
-       hex "Freescale K64-based GPIO Port A base address"
-       depends on GPIO_K64_A
-       default 0x00000000
+   hex "Freescale K64-based GPIO Port A base address"
+   depends on GPIO_K64_A
+   default 0x400FF000
+
+config PORT_K64_A_BASE_ADDR
+   hex "Freescale K64-based Port Control Port A base address"
+   depends on GPIO_K64_A
+   default 0x40049000
 
 config GPIO_K64_B
 	bool "Freescale K64-based GPIO Port B"
@@ -749,9 +749,14 @@ config GPIO_K64_B_DEV_NAME
 	  Specify the device name.
 
 config GPIO_K64_B_BASE_ADDR
-       hex "Freescale K64-based GPIO Port B base address"
-       depends on GPIO_K64_B
-       default 0x00000000
+   hex "Freescale K64-based GPIO Port B base address"
+   depends on GPIO_K64_B
+   default 0x400FF040
+
+config PORT_K64_B_BASE_ADDR
+   hex "Freescale K64-based Port Control Port B base address"
+   depends on GPIO_K64_B
+   default 0x4004A000
 
 config GPIO_K64_C
 	bool "Freescale K64-based GPIO Port B"
@@ -768,9 +773,14 @@ config GPIO_K64_C_DEV_NAME
 	  Specify the device name.
 
 config GPIO_K64_C_BASE_ADDR
-       hex "Freescale K64-based GPIO Port C base address"
-       depends on GPIO_K64_C
-       default 0x00000000
+   hex "Freescale K64-based GPIO Port C base address"
+   depends on GPIO_K64_C
+   default 0x400FF080
+
+config PORT_K64_C_BASE_ADDR
+   hex "Freescale K64-based Port Control Port C base address"
+   depends on GPIO_K64_C
+   default 0x4004B000
 
 config GPIO_K64_D
 	bool "Freescale K64-based GPIO Port D"
@@ -787,9 +797,14 @@ config GPIO_K64_D_DEV_NAME
 	  Specify the device name.
 
 config GPIO_K64_D_BASE_ADDR
-       hex "Freescale K64-based GPIO Port D base address"
-       depends on GPIO_K64_D
-       default 0x00000000
+   hex "Freescale K64-based GPIO Port D base address"
+   depends on GPIO_K64_D
+   default 0x400FF0C0
+
+config PORT_K64_D_BASE_ADDR
+   hex "Freescale K64-based Port Control Port D base address"
+   depends on GPIO_K64_D
+   default 0x4004C000
 
 config GPIO_K64_E
 	bool "Freescale K64-based GPIO Port E"
@@ -806,8 +821,13 @@ config GPIO_K64_E_DEV_NAME
 	  Specify the device name.
 
 config GPIO_K64_E_BASE_ADDR
-       hex "Freescale K64-based GPIO Port E base address"
-       depends on GPIO_K64_E
-       default 0x00000000
+   hex "Freescale K64-based GPIO Port E base address"
+   depends on GPIO_K64_E
+   default 0x400FF100
+
+config PORT_K64_E_BASE_ADDR
+   hex "Freescale K64-based Port Control Port E base address"
+   depends on GPIO_K64_E
+   default 0x4004D000
 
 endif # GPIO
diff --git a/drivers/gpio/gpio_k64.c b/drivers/gpio/gpio_k64.c
index 0e8e60d..123d7c5 100644
--- a/drivers/gpio/gpio_k64.c
+++ b/drivers/gpio/gpio_k64.c
@@ -22,6 +22,9 @@
 #include <device.h>
 #include <init.h>
 #include <gpio.h>
+#include <sys_io.h>
+
+#include <pinmux/pinmux_k64.h>
 
 #include "gpio_k64.h"
 
@@ -37,36 +40,90 @@
  * @return DEV_OK if successful, failed otherwise
  */
 static int gpio_k64_config(struct device *dev, int access_op,
-					       uint32_t pin, int flags)
+						   uint32_t pin, int flags)
 {
 	const struct gpio_k64_config * const cfg = dev->config->config_info;
-	uint32_t value = 0;
+	uint32_t value;
+	uint32_t setting;
+	uint8_t i;
+
+	/* check for an invalid pin configuration */
+
+	if (flags & GPIO_INT) {
+		/* interrupts not supported */
+		return DEV_INVALID_OP;
+	}
 
 	/*
-     * Setup direction register:
+	 * Set up direction register:
 	 * 0 - pin is input, 1 - pin is output
 	 */
 
 	switch (access_op) {
 		case GPIO_ACCESS_BY_PIN:
-            if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
-                sys_clear_bit((cfg->base_addr + GPIO_K64_DIR_OFFSET), pin);
-            } else {
-                sys_set_bit((cfg->base_addr + GPIO_K64_DIR_OFFSET), pin);
-            }
+			if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
+				sys_clear_bit((cfg->gpio_base_addr + GPIO_K64_DIR_OFFSET), pin);
+			} else {  /* GPIO_DIR_OUT */
+				sys_set_bit((cfg->gpio_base_addr + GPIO_K64_DIR_OFFSET), pin);
+			}
 			break;
 		case GPIO_ACCESS_BY_PORT:
-            if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
-                value = 0x0;
-            } else {
-		        value = 0xFFFFFFFF;
-            }
-			sys_write32(value, (cfg->base_addr + GPIO_K64_DIR_OFFSET));
+			if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
+				value = 0x0;
+			} else {  /* GPIO_DIR_OUT */
+				value = 0xFFFFFFFF;
+			}
+			sys_write32(value, (cfg->gpio_base_addr + GPIO_K64_DIR_OFFSET));
 			break;
 		default:
 			return DEV_INVALID_OP;
 	}
 
+	/*
+	 * Set up pullup/pulldown configuration, in Port Control module:
+	 */
+
+	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
+		setting = (PINMUX_PULL_ENABLE | PINMUX_PULL_UP);
+	} else if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_DOWN) {
+		setting = (PINMUX_PULL_ENABLE | PINMUX_PULL_DN);
+	} else if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
+		setting = PINMUX_PULL_DISABLE;
+	}
+
+	/* write pull-up/-down configuration settings */
+
+	if (access_op == GPIO_ACCESS_BY_PIN) {
+
+		value = sys_read32((cfg->port_base_addr + PINMUX_CTRL_OFFSET(pin)));
+
+		/* clear, then set configuration values */
+
+		value &= ~(PINMUX_PULL_EN_MASK | PINMUX_PULL_SEL_MASK);
+
+		value |= setting;
+
+		sys_write32(value,
+					(cfg->port_base_addr + PINMUX_CTRL_OFFSET(pin)));
+
+	} else {  /* GPIO_ACCESS_BY_PORT */
+
+		for (i = 0; i < PINMUX_NUM_PINMUXS; i++) {
+
+			/* clear, then set configuration values */
+
+			value = sys_read32((cfg->port_base_addr + PINMUX_CTRL_OFFSET(i)));
+
+			value &= ~(PINMUX_PULL_EN_MASK | PINMUX_PULL_SEL_MASK);
+
+			value |= setting;
+
+			sys_write32(value,
+						(cfg->port_base_addr + PINMUX_CTRL_OFFSET(i)));
+
+		}
+	}
+
 	return DEV_OK;
 }
 
@@ -81,20 +138,23 @@ static int gpio_k64_config(struct device *dev, int access_op,
  * @return DEV_OK if successful, failed otherwise
  */
 static int gpio_k64_write(struct device *dev, int access_op,
-			              uint32_t pin, uint32_t value)
+						  uint32_t pin, uint32_t value)
 {
 	const struct gpio_k64_config * const cfg = dev->config->config_info;
 
 	switch (access_op) {
 		case GPIO_ACCESS_BY_PIN:
-            if (value) {
-                sys_set_bit((cfg->base_addr + GPIO_K64_DATA_OUT_OFFSET), pin);
-            } else {
-                sys_clear_bit((cfg->base_addr + GPIO_K64_DATA_OUT_OFFSET), pin);
-            }
+			if (value) {
+				sys_set_bit((cfg->gpio_base_addr + GPIO_K64_DATA_OUT_OFFSET),
+							pin);
+			} else {
+				sys_clear_bit((cfg->gpio_base_addr + GPIO_K64_DATA_OUT_OFFSET),
+							  pin);
+			}
 			break;
 		case GPIO_ACCESS_BY_PORT:
-			sys_write32(value, (cfg->base_addr + GPIO_K64_DATA_OUT_OFFSET));
+			sys_write32(value,
+						(cfg->gpio_base_addr + GPIO_K64_DATA_OUT_OFFSET));
 			break;
 		default:
 			return DEV_INVALID_OP;
@@ -114,11 +174,11 @@ static int gpio_k64_write(struct device *dev, int access_op,
  * @return DEV_OK if successful, failed otherwise
  */
 static int gpio_k64_read(struct device *dev, int access_op,
-				         uint32_t pin, uint32_t *value)
+						 uint32_t pin, uint32_t *value)
 {
 	const struct gpio_k64_config * const cfg = dev->config->config_info;
 
-	*value = sys_read32((cfg->base_addr + GPIO_K64_DATA_IN_OFFSET));
+	*value = sys_read32((cfg->gpio_base_addr + GPIO_K64_DATA_IN_OFFSET));
 
 	switch (access_op) {
 		case GPIO_ACCESS_BY_PIN:
@@ -142,7 +202,7 @@ static int gpio_k64_set_callback(struct device *dev, gpio_callback_t callback)
 }
 
 static int gpio_k64_enable_callback(struct device *dev, int access_op,
-                                    uint32_t pin)
+									uint32_t pin)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(access_op);
@@ -152,7 +212,7 @@ static int gpio_k64_enable_callback(struct device *dev, int access_op,
 }
 
 static int gpio_k64_disable_callback(struct device *dev, int access_op,
-                                     uint32_t pin)
+									 uint32_t pin)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(access_op);
@@ -203,7 +263,8 @@ int gpio_k64_init(struct device *dev)
 #ifdef CONFIG_GPIO_K64_A
 
 static struct gpio_k64_config gpio_k64_A_cfg = {
-    .base_addr = CONFIG_GPIO_K64_A_BASE_ADDR,
+	.gpio_base_addr = CONFIG_GPIO_K64_A_BASE_ADDR,
+	.port_base_addr = CONFIG_PORT_K64_A_BASE_ADDR,
 };
 
 DEVICE_INIT(gpio_k64_A, CONFIG_GPIO_K64_A_DEV_NAME, gpio_k64_init,
@@ -216,7 +277,8 @@ DEVICE_INIT(gpio_k64_A, CONFIG_GPIO_K64_A_DEV_NAME, gpio_k64_init,
 #ifdef CONFIG_GPIO_K64_B
 
 static struct gpio_k64_config gpio_k64_B_cfg = {
-    .base_addr = CONFIG_GPIO_K64_B_BASE_ADDR,
+	.gpio_base_addr = CONFIG_GPIO_K64_B_BASE_ADDR,
+	.port_base_addr = CONFIG_PORT_K64_B_BASE_ADDR,
 };
 
 DEVICE_INIT(gpio_k64_B, CONFIG_GPIO_K64_B_DEV_NAME, gpio_k64_init,
@@ -229,7 +291,8 @@ DEVICE_INIT(gpio_k64_B, CONFIG_GPIO_K64_B_DEV_NAME, gpio_k64_init,
 #ifdef CONFIG_GPIO_K64_C
 
 static struct gpio_k64_config gpio_k64_C_cfg = {
-    .base_addr = CONFIG_GPIO_K64_C_BASE_ADDR,
+	.gpio_base_addr = CONFIG_GPIO_K64_C_BASE_ADDR,
+	.port_base_addr = CONFIG_PORT_K64_C_BASE_ADDR,
 };
 
 DEVICE_INIT(gpio_k64_C, CONFIG_GPIO_K64_C_DEV_NAME, gpio_k64_init,
@@ -242,7 +305,8 @@ DEVICE_INIT(gpio_k64_C, CONFIG_GPIO_K64_C_DEV_NAME, gpio_k64_init,
 #ifdef CONFIG_GPIO_K64_D
 
 static struct gpio_k64_config gpio_k64_D_cfg = {
-    .base_addr = CONFIG_GPIO_K64_D_BASE_ADDR,
+	.gpio_base_addr = CONFIG_GPIO_K64_D_BASE_ADDR,
+	.port_base_addr = CONFIG_PORT_K64_D_BASE_ADDR,
 };
 
 DEVICE_INIT(gpio_k64_D, CONFIG_GPIO_K64_D_DEV_NAME, gpio_k64_init,
@@ -255,7 +319,8 @@ DEVICE_INIT(gpio_k64_D, CONFIG_GPIO_K64_D_DEV_NAME, gpio_k64_init,
 #ifdef CONFIG_GPIO_K64_E
 
 static struct gpio_k64_config gpio_k64_E_cfg = {
-    .base_addr = CONFIG_GPIO_K64_E_BASE_ADDR,
+	.gpio_base_addr = CONFIG_GPIO_K64_E_BASE_ADDR,
+	.port_base_addr = CONFIG_PORT_K64_E_BASE_ADDR,
 };
 
 DEVICE_INIT(gpio_k64_E, CONFIG_GPIO_K64_E_DEV_NAME, gpio_k64_init,
diff --git a/drivers/gpio/gpio_k64.h b/drivers/gpio/gpio_k64.h
index c889368..c7dac66 100644
--- a/drivers/gpio/gpio_k64.h
+++ b/drivers/gpio/gpio_k64.h
@@ -27,12 +27,12 @@
 
 /* GPIO Port Register offsets */
 
-#define GPIO_K64_DATA_OUT_OFFSET    0x00  /* Port Data Output Reg. offset */
-#define GPIO_K64_SET_OUT_OFFSET     0x04  /* Port Set Output Reg. offset */
-#define GPIO_K64_CLR_OUT_OFFSET     0x08  /* Port Clear Output Reg. offset */
-#define GPIO_K64_TOGGLE_OUT_OFFSET  0x0C  /* Port Toggle Output  Reg. offset */
-#define GPIO_K64_DATA_IN_OFFSET     0x10  /* Port Data Input Reg. offset */
-#define GPIO_K64_DIR_OFFSET         0x14  /* Port Data Direction Reg. offset */
+#define GPIO_K64_DATA_OUT_OFFSET	0x00  /* Port Data Output Reg. offset */
+#define GPIO_K64_SET_OUT_OFFSET		0x04  /* Port Set Output Reg. offset */
+#define GPIO_K64_CLR_OUT_OFFSET		0x08  /* Port Clear Output Reg. offset */
+#define GPIO_K64_TOGGLE_OUT_OFFSET	0x0C  /* Port Toggle Output  Reg. offset */
+#define GPIO_K64_DATA_IN_OFFSET		0x10  /* Port Data Input Reg. offset */
+#define GPIO_K64_DIR_OFFSET			0x14  /* Port Data Direction Reg. offset */
 
 /**
  * @brief Initialization function for GPIO driver
@@ -44,12 +44,14 @@ extern int gpio_k64_init(struct device *dev);
 
 /* internal use only for register access function */
 typedef uint32_t (*__gpio_k64_access_t)(uint32_t addr, uint32_t bit,
-					 uint32_t value);
+					uint32_t value);
 
-/** Configuration data */
+/* configuration data */
 struct gpio_k64_config {
-	/* base address */
-	uint32_t base_addr;
+	/* GPIO module base address */
+	uint32_t gpio_base_addr;
+	/* Port Control module base address */
+	uint32_t port_base_addr;
 };
 
 #endif /* _GPIO_K64_H_ */
-- 
1.9.1


From 21210575c31a2a75b02c4c6907c49299ec3c54fe Mon Sep 17 00:00:00 2001
From: Jeff Blais <jblais@windriver.com>
Date: Fri, 20 Nov 2015 13:25:23 -0500
Subject: [PATCH 72/82] Freescale K64/FRDM-K64F Pinmux support

K64 pinmux support is created as a normal driver.
As opposed to the Galileo board, the pin configuration options are
defined by the MCU and are not board-specific.
Separate platform/board-specific configuration code uses the pinmux driver
for the default pin settings. For FRDM-K64F, only the Arduino pins
(22 of a possible 160) are set up.

Some of the I/O pins routed to the Arduino header are also configured as
JTAG/SWD signals by default and are used by the OpenSDAv2 debug interface.
Therefore, a PRESERVE_JTAG_IO_PINS config option was created for the
FRDM-K64 platform to prevent the default pin settings from re-configuring
these pins.

The K64 MCU separates pin configuration and control, implemented in the
pinmux driver, from GPIO.
This results in some cross referencing between the K64 GPIO driver and
the K64 pinmux driver due to the dependencies of one on the other.

This pinmux driver also uses the expanded pinmux function/mode parameter
size to describe pin configuration options with bit fields for the K64,
including up to 8 pin functions, plus interrupt, pullup/down, drive
strength, open-drain and slew rate.

diff --git a/arch/arm/soc/fsl_frdm_k64f/Kconfig b/arch/arm/soc/fsl_frdm_k64f/Kconfig
index af6461e..0fd6785 100644
--- a/arch/arm/soc/fsl_frdm_k64f/Kconfig
+++ b/arch/arm/soc/fsl_frdm_k64f/Kconfig
@@ -162,6 +162,9 @@ endif
 config GPIO
 	def_bool y
 
+config PINMUX
+	def_bool y
+
 if GPIO
 
 config GPIO_K64
@@ -182,35 +185,39 @@ config GPIO_K64_D
 config GPIO_K64_E
 	def_bool y
 
-if GPIO_K64
-config PORT_K64_BASE_ADDR
-    default 0x40049000
-endif
-
-if GPIO_K64_A
-config GPIO_K64_A_BASE_ADDR
-    default 0x400FF000
 endif
 
-if GPIO_K64_B
-config GPIO_K64_B_BASE_ADDR
-    default 0x400FF040
-endif
-
-if GPIO_K64_C
-config GPIO_K64_C_BASE_ADDR
-    default 0x400FF080
-endif
+if PINMUX
 
-if GPIO_K64_D
-config GPIO_K64_D_BASE_ADDR
-    default 0x400FF0C0
-endif
+config PINMUX_K64
+	def_bool y
+config PINMUX_BASE
+	default 0x00000000
+config PINMUX_NUM_PINS
+	default 160
+config PINMUX_BASE
+	default 0x00000000
+config PINMUX_K64_GPIO_A_NAME
+	default GPIO_K64_A_DEV_NAME
+config PINMUX_K64_GPIO_B_NAME
+	default GPIO_K64_B_DEV_NAME
+config PINMUX_K64_GPIO_C_NAME
+	default GPIO_K64_C_DEV_NAME
+config PINMUX_K64_GPIO_D_NAME
+	default GPIO_K64_D_DEV_NAME
+config PINMUX_K64_GPIO_E_NAME
+	default GPIO_K64_E_DEV_NAME
+
+config PRESERVE_JTAG_IO_PINS
+	bool "Freescale FRDM-K64F JTAG pin usage"
+	depends on PINMUX
+	default y
+	help
+	The FRDM-K64F board routes the PTA0/1/2 pins as JTAG/SWD signals that
+	are used for the OpenSDAv2 debug interface.  These pins are also routed to
+	the Arduino header as D8, D3 and D5, respectively.
+	Enable this option to preserve these pins for the debug interface.
 
-if GPIO_K64_E
-config GPIO_K64_E_BASE_ADDR
-    default 0x400FF100
-endif
-endif
+endif #PINMUX
 
 endif
diff --git a/arch/arm/soc/fsl_frdm_k64f/soc_config.c b/arch/arm/soc/fsl_frdm_k64f/soc_config.c
index e2fde61..51e95f4 100644
--- a/arch/arm/soc/fsl_frdm_k64f/soc_config.c
+++ b/arch/arm/soc/fsl_frdm_k64f/soc_config.c
@@ -30,9 +30,21 @@
 #include <drivers/k20_pcr.h>
 #include <drivers/k20_sim.h>
 #include <console/uart_console.h>
-
 #include <serial/uart_k20_priv.h>
+#endif /* CONFIG_K20_UART */
+
+#ifdef CONFIG_PINMUX
+#include <pinmux.h>
+#include <pinmux/pinmux.h>
+#include <pinmux/pinmux_k64.h>
+#endif /* CONFIG_PINMUX */
+
+
+/*
+ * UART configuration
+ */
 
+#ifdef CONFIG_K20_UART
 
 #if defined(CONFIG_UART_CONSOLE)
 #if defined(CONFIG_PRINTK) || defined(CONFIG_STDOUT_CONSOLE)
@@ -120,3 +132,90 @@ DEVICE_INIT(_uart_k20_init, "", uart_k20_init,
 				PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
 #endif /* CONFIG_UART_K20 */
+
+/*
+ * I/O pin configuration
+ */
+
+#ifdef CONFIG_PINMUX
+
+/*
+ * Number of default pin settings, used for Arduino Rev 3 pinout.
+ *
+ * NOTE: The FRDM-K64F board routes the PTA0/1/2 pins for JTAG/SWD signals that
+ * are used for the OpenSDAv2 debug interface.  These pins are also routed to
+ * the Arduino header pins as D8, D3 and D5, respectively.
+ * Since the K64 MCU configures these pins for JTAG/SWD signaling at reset,
+ * they should only be re-configured if the debug interface is not used.
+ */
+
+#ifndef CONFIG_PRESERVE_JTAG_IO_PINS
+#define NUM_DFLT_PINS_SET   22
+#else
+#define NUM_DFLT_PINS_SET   (22 - 3)
+#endif
+
+/*
+ * Alter this table to change the default Arduino pin settings on the Freescale
+ * FRDM-K64F boards.  Specifically, change the PINMUX_* values to represent
+ * the functionality desired.
+ */
+struct pin_config mux_config[NUM_DFLT_PINS_SET] = {
+	/* pin,      selected mode                                  description   */
+	{ PIN_PTC16, (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+	{ PIN_PTC17, (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+	{ PIN_PTB9,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+#ifndef CONFIG_PRESERVE_JTAG_IO_PINS
+	{ PIN_PTA1,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+#endif
+	{ PIN_PTB23, (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+#ifndef CONFIG_PRESERVE_JTAG_IO_PINS
+	{ PIN_PTA2,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+#endif
+	{ PIN_PTC2,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+	{ PIN_PTC3,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+#ifndef CONFIG_PRESERVE_JTAG_IO_PINS
+	{ PIN_PTA0,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+#endif
+	{ PIN_PTC4,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+	{ PIN_PTD0,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+	{ PIN_PTD2,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+	{ PIN_PTD3,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+	{ PIN_PTD1,  (PINMUX_FUNC_GPIO | PINMUX_GPIO_DIR_INPUT) },  /* GPIO in */
+	{ PIN_PTE25, (PINMUX_ALT_5 | PINMUX_OPEN_DRN_ENABLE) },  /* I2C0_SDA */
+	{ PIN_PTE24, (PINMUX_ALT_5 | PINMUX_OPEN_DRN_ENABLE) },  /* I2C0_SCL */
+	{ PIN_PTB2,  PINMUX_FUNC_ANALOG },  /* ADC0_SE12/Analog In 0 */
+	{ PIN_PTB3,  PINMUX_FUNC_ANALOG },  /* ADC0_SE13/Analog In 1 */
+	{ PIN_PTB10, PINMUX_FUNC_ANALOG },  /* ADC1_SE14/Analog In 2 */
+	{ PIN_PTB11, PINMUX_FUNC_ANALOG },  /* ADC1_SE15/Analog In 3 */
+	{ PIN_PTC11, PINMUX_FUNC_ANALOG },  /* ADC1_SE7b/Analog In 4 */
+	{ PIN_PTC10, PINMUX_FUNC_ANALOG },  /* ADC1_SE6b/Analog In 5 */
+};
+
+
+int fsl_frdm_k64f_pin_init(struct device *arg)
+{
+	ARG_UNUSED(arg);
+	struct device * pmux;
+	int i;
+
+	pmux = device_get_binding(PINMUX_NAME);
+
+	if (!pmux) {
+		return DEV_INVALID_CONF;
+	}
+
+	/* configure the pins from the default mapping above */
+
+	for (i = 0; i < NUM_DFLT_PINS_SET; i++) {
+		pinmux_set_pin(pmux, mux_config[i].pin_num, mux_config[i].mode);
+	}
+
+	return DEV_OK;
+}
+
+/* This needs to be initialized after GPIO. */
+DEVICE_INIT(frdm_k64f_pmux, "", fsl_frdm_k64f_pin_init, NULL, NULL, PRIMARY,
+				KERNEL_INIT_PRIORITY_DEVICE);
+
+#endif /* CONFIG_PINMUX */
diff --git a/drivers/Makefile b/drivers/Makefile
index 03b0f49..80efe96 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -22,3 +22,4 @@ obj-$(CONFIG_CLOCK_CONTROL) += clock_control/
 obj-$(CONFIG_IPM) += ipm/
 obj-$(CONFIG_NBLE) += nble/
 obj-y += aio/
+obj-$(CONFIG_PINMUX) += pinmux/
diff --git a/drivers/pinmux/Kconfig b/drivers/pinmux/Kconfig
index b37dd9f..fd4efaa 100644
--- a/drivers/pinmux/Kconfig
+++ b/drivers/pinmux/Kconfig
@@ -21,6 +21,7 @@
 #
 menuconfig PINMUX
         bool "Enable platform pinmux driver"
+        depends on GPIO
         default n
 
 config PINMUX_BASE
@@ -106,3 +107,46 @@ config PINMUX_GALILEO_GPIO_INTEL_RW_NAME
         help
         The name of the Legacy Bridge Resume Well GPIO with
         GPIO_SUS<0>..GPIO_SUS<5> in the schematic.
+
+config PINMUX_K64
+        bool "Freescale K64-based Pin multiplexer driver"
+        depends on PINMUX
+        default n
+        help
+        Enable driver for Freescale K64-based Pin multiplexer.
+
+config PINMUX_K64_GPIO_A_NAME
+        string "Name of the Port A GPIO"
+        depends on PINMUX && GPIO_K64
+        default "GPIO_A"
+        help
+        The name of the Port A GPIO referred to as PTA0..PTA31.
+
+config PINMUX_K64_GPIO_B_NAME
+        string "Name of the Port B GPIO"
+        depends on PINMUX && GPIO_K64
+        default "GPIO_B"
+        help
+        The name of the Port B GPIO referred to as PTB0..PTB31.
+
+config PINMUX_K64_GPIO_C_NAME
+        string "Name of the Port C GPIO"
+        depends on PINMUX && GPIO_K64
+        default "GPIO_C"
+        help
+        The name of the Port C GPIO referred to as PTC0..PTC31.
+
+config PINMUX_K64_GPIO_D_NAME
+        string "Name of the Port D GPIO"
+        depends on PINMUX && GPIO_K64
+        default "GPIO_D"
+        help
+        The name of the Port D GPIO referred to as PTD0..PTD31.
+
+config PINMUX_K64_GPIO_E_NAME
+        string "Name of the Port E GPIO"
+        depends on PINMUX && GPIO_K64
+        default "GPIO_E"
+        help
+        The name of the Port E GPIO referred to as PTE0..PTE31.
+
diff --git a/drivers/pinmux/Makefile b/drivers/pinmux/Makefile
new file mode 100644
index 0000000..2df7f0a
--- /dev/null
+++ b/drivers/pinmux/Makefile
@@ -0,0 +1,3 @@
+ccflags-y +=-I$(srctree)/drivers
+
+obj-$(CONFIG_PINMUX_K64) += pinmux_k64.o
diff --git a/drivers/pinmux/pinmux.h b/drivers/pinmux/pinmux.h
index a4117a7..df3cfa8 100644
--- a/drivers/pinmux/pinmux.h
+++ b/drivers/pinmux/pinmux.h
@@ -35,6 +35,7 @@ struct pinmux_config {
 };
 
 extern int pinmux_initialize(struct device *port);
+extern int pinmux_frdm_k64_initialize(struct device *port);
 
 #ifdef __cplusplus
 }
diff --git a/drivers/pinmux/pinmux_k64.c b/drivers/pinmux/pinmux_k64.c
new file mode 100644
index 0000000..043429a
--- /dev/null
+++ b/drivers/pinmux/pinmux_k64.c
@@ -0,0 +1,369 @@
+/* fsl_fsl_k64_pinmux.c - pin out mapping for the Freescale FRDM-K64F board */
+
+/*
+ * Copyright (c) 2015, Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdbool.h>
+#include <nanokernel.h>
+#include <device.h>
+#include <init.h>
+#include <sys_io.h>
+
+#include <pinmux.h>
+#include <i2c.h>
+#include <gpio.h>
+#include <pwm.h>
+
+#include <gpio/gpio_k64.h>
+#include <pinmux/pinmux.h>
+#include <pinmux/pinmux_k64.h>
+
+/* port pin number conversion from pin ID */
+#define PINMUX_FROM_ID(pin_id)	(pin_id % PINMUX_NUM_PINMUXS)
+
+struct fsl_k64_data {
+	struct device *gpio_a;  /* port A */
+	struct device *gpio_b;  /* port B */
+	struct device *gpio_c;  /* port C */
+	struct device *gpio_d;  /* port D */
+	struct device *gpio_e;  /* port E */
+};
+
+
+#ifdef CONFIG_GPIO_K64_A
+static inline int config_port_a(mem_addr_t *addr)
+{
+  *addr = CONFIG_PORT_K64_A_BASE_ADDR;
+  return DEV_OK;
+}
+#else
+#define config_port_a(addr) DEV_NO_ACCESS
+#endif
+
+#ifdef CONFIG_GPIO_K64_B
+static inline int config_port_b(mem_addr_t *addr)
+{
+  *addr = CONFIG_PORT_K64_B_BASE_ADDR;
+  return DEV_OK;
+}
+#else
+#define config_port_b(addr) DEV_NO_ACCESS
+#endif
+
+#ifdef CONFIG_GPIO_K64_C
+static inline int config_port_c(mem_addr_t *addr)
+{
+  *addr = CONFIG_PORT_K64_C_BASE_ADDR;
+  return DEV_OK;
+}
+#else
+#define config_port_c(addr) DEV_NO_ACCESS
+#endif
+
+#ifdef CONFIG_GPIO_K64_D
+static inline int config_port_d(mem_addr_t *addr)
+{
+  *addr = CONFIG_PORT_K64_D_BASE_ADDR;
+  return DEV_OK;
+}
+#else
+#define config_port_d(addr) DEV_NO_ACCESS
+#endif
+
+#ifdef CONFIG_GPIO_K64_E
+static inline int config_port_e(mem_addr_t *addr)
+{
+  *addr = CONFIG_PORT_K64_E_BASE_ADDR;
+  return DEV_OK;
+}
+#else
+#define config_port_e(addr) DEV_NO_ACCESS
+#endif
+
+static int _fsl_k64_get_port_addr(uint8_t pin_id, mem_addr_t* port_addr_ptr)
+{
+
+	/* determine the port base address associated with the pin identifier */
+
+	if (pin_id < PIN_PTB0) {		   /* Port A pin */
+
+		return (config_port_a(port_addr_ptr));
+
+	} else if (pin_id < PIN_PTC0) {	/* Port B pin */
+
+		return (config_port_b(port_addr_ptr));
+
+	} else if (pin_id < PIN_PTD0) {	/* Port C pin */
+
+		return (config_port_c(port_addr_ptr));
+
+	} else if (pin_id < PIN_PTE0) {	/* Port D pin */
+
+		return (config_port_d(port_addr_ptr));
+
+	} else {						/* Port E pin */
+
+		return (config_port_e(port_addr_ptr));
+
+	}
+
+}
+
+
+static int _fsl_k64_get_gpio_dev(struct device *dev,
+								   mem_addr_t port_base_addr,
+								   struct device **gpio_dev_ptr)
+{
+	struct fsl_k64_data * const data = dev->driver_data;
+
+	/* determine the gpio device associated with the port base address */
+
+	switch (port_base_addr) {
+		case CONFIG_PORT_K64_A_BASE_ADDR:
+			*gpio_dev_ptr = data->gpio_a;
+			break;
+		case CONFIG_PORT_K64_B_BASE_ADDR:
+			*gpio_dev_ptr = data->gpio_b;
+			break;
+		case CONFIG_PORT_K64_C_BASE_ADDR:
+			*gpio_dev_ptr = data->gpio_c;
+			break;
+		case CONFIG_PORT_K64_D_BASE_ADDR:
+			*gpio_dev_ptr = data->gpio_d;
+			break;
+		case CONFIG_PORT_K64_E_BASE_ADDR:
+			*gpio_dev_ptr = data->gpio_e;
+			break;
+		default:
+			return DEV_NO_ACCESS;
+	}
+
+	return DEV_OK;
+}
+
+
+static uint32_t _fsl_k64_set_pin(struct device *dev,
+								   uint32_t pin_id,
+								   uint32_t func)
+{
+	mem_addr_t port_base_addr;
+	uint8_t port_pin;
+	uint32_t status;
+	struct device *gpio_dev;
+	bool is_gpio = false;
+	int gpio_setting;
+
+	if ((pin_id >= CONFIG_PINMUX_NUM_PINS) ||
+		(func & PINMUX_INT_MASK)) {  /* interrupts not supported */
+
+		return DEV_INVALID_OP;
+	}
+
+	if ((func & PINMUX_ALT_MASK) == PINMUX_FUNC_GPIO) {
+		is_gpio = true;
+	}
+
+	/* determine the pin's port register base address */
+
+	status = _fsl_k64_get_port_addr(pin_id, &port_base_addr);
+	
+	if (status != DEV_OK) {
+		return (status);
+	}
+
+	/* extract the pin number within its port */
+
+	port_pin = PINMUX_FROM_ID(pin_id);
+
+	if (is_gpio) {
+
+		/* set GPIO direction */
+
+		status = _fsl_k64_get_gpio_dev(dev, port_base_addr, &gpio_dev);
+
+		if (status != DEV_OK) {
+			return (status);
+		}
+
+		if (func & PINMUX_GPIO_DIR_OUTPUT) {
+			gpio_setting = GPIO_DIR_OUT;
+		} else {
+			gpio_setting = GPIO_DIR_IN;
+		}
+		
+		status = gpio_pin_configure(gpio_dev, port_pin, gpio_setting);
+
+		if (status != DEV_OK) {
+			return (status);
+		}
+
+		/* remove GPIO direction info from the pin configuration */
+
+		func &= ~PINMUX_GPIO_DIR_MASK;
+	}
+
+	/* set pin function and control settings */
+
+	sys_write32(func, port_base_addr + PINMUX_CTRL_OFFSET(port_pin));
+
+	return DEV_OK;
+}
+
+static uint32_t _fsl_k64_get_pin(struct device *dev,
+								   uint32_t pin_id,
+								   uint32_t *func)
+{
+	mem_addr_t port_base_addr;
+	uint8_t port_pin;
+	struct device *gpio_dev;
+	const struct gpio_k64_config *cfg;
+	uint32_t gpio_port_dir;
+	uint32_t status;
+
+	if (pin_id >= CONFIG_PINMUX_NUM_PINS) {
+		return DEV_INVALID_OP;
+	}
+
+	/* determine the pin's port register base address */
+
+	status = _fsl_k64_get_port_addr(pin_id, &port_base_addr);
+
+	if (status != DEV_OK) {
+		return (status);
+	}
+	
+	/* extract the pin number within its port */
+
+	port_pin = PINMUX_FROM_ID(pin_id);
+
+	/* get pin function and control settings */
+
+	*func = sys_read32(port_base_addr + PINMUX_CTRL_OFFSET(port_pin));
+
+	/* get pin direction, if GPIO */
+
+	if ((*func & PINMUX_ALT_MASK) == PINMUX_FUNC_GPIO) {
+
+		status = _fsl_k64_get_gpio_dev(dev, port_base_addr, &gpio_dev);
+
+		if (status != DEV_OK) {
+			return (status);
+		}
+
+		cfg = gpio_dev->config->config_info;
+
+		gpio_port_dir = sys_read32(cfg->gpio_base_addr + GPIO_K64_DIR_OFFSET);
+
+		if (gpio_port_dir & (1 << port_pin)) {
+			*func |= PINMUX_GPIO_DIR_OUTPUT;
+		}
+	}
+		
+	return DEV_OK;
+}
+
+static uint32_t fsl_k64_dev_set(struct device *dev,
+								  uint32_t pin,
+								  uint32_t func)
+{
+	return _fsl_k64_set_pin(dev, pin, func);
+}
+
+static uint32_t fsl_k64_dev_get(struct device *dev,
+								  uint32_t pin,
+								  uint32_t *func)
+{
+	return _fsl_k64_get_pin(dev, pin, func);
+}
+
+static struct pinmux_driver_api api_funcs = {
+	.set = fsl_k64_dev_set,
+	.get = fsl_k64_dev_get
+};
+
+int pinmux_fsl_k64_initialize(struct device *port)
+{
+	struct fsl_k64_data *data = port->driver_data;
+
+	port->driver_api = &api_funcs;
+
+	/* get the GPIO ports, by name */
+
+#ifdef CONFIG_GPIO_K64_A
+	data->gpio_a = device_get_binding(CONFIG_PINMUX_K64_GPIO_A_NAME);
+	if (!data->gpio_a) {
+		return DEV_INVALID_CONF;
+	}
+#endif
+
+#ifdef CONFIG_GPIO_K64_B
+	data->gpio_b = device_get_binding(CONFIG_PINMUX_K64_GPIO_B_NAME);
+	if (!data->gpio_b) {
+		return DEV_INVALID_CONF;
+	}
+#endif
+
+#ifdef CONFIG_GPIO_K64_C
+	data->gpio_c = device_get_binding(CONFIG_PINMUX_K64_GPIO_C_NAME);
+	if (!data->gpio_c) {
+		return DEV_INVALID_CONF;
+	}
+#endif
+
+#ifdef CONFIG_GPIO_K64_D
+	data->gpio_d = device_get_binding(CONFIG_PINMUX_K64_GPIO_D_NAME);
+	if (!data->gpio_d) {
+		return DEV_INVALID_CONF;
+	}
+#endif
+
+#ifdef CONFIG_GPIO_K64_E
+	data->gpio_e = device_get_binding(CONFIG_PINMUX_K64_GPIO_E_NAME);
+	if (!data->gpio_e) {
+		return DEV_INVALID_CONF;
+	}
+#endif
+
+	return DEV_OK;
+}
+
+
+struct pinmux_config fsl_k64_pmux = {
+	.base_address = 0x00000000,
+};
+
+DECLARE_DEVICE_INIT_CONFIG(pmux,
+			  PINMUX_NAME,
+			  &pinmux_fsl_k64_initialize,
+			  &fsl_k64_pmux);
+
+struct fsl_k64_data fsl_k64_pinmux_driver = {
+	.gpio_a = NULL,
+	.gpio_b = NULL,
+	.gpio_c = NULL,
+	.gpio_d = NULL,
+	.gpio_e = NULL
+};
+
+/*
+ * This needs to be a level 2 or later init process due to the following
+ * dependency chain:
+ * 0 - I2C
+ * 1 - GPIO
+ * 2 - pinmux
+ */
+nano_late_init(pmux, &fsl_k64_pinmux_driver);
+
diff --git a/drivers/pinmux/pinmux_k64.h b/drivers/pinmux/pinmux_k64.h
new file mode 100644
index 0000000..dea92bd
--- /dev/null
+++ b/drivers/pinmux/pinmux_k64.h
@@ -0,0 +1,296 @@
+/* pinmux_k64.h - Freescale K64 pinmux header */
+
+/*
+ * Copyright (c) 2015, Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file Header file for Freescale K64 pin multiplexing.
+ */
+
+#ifndef __INCLUDE_PINMUX_K64_H
+#define __INCLUDE_PINMUX_K64_H
+
+
+#define PINMUX_NUM_PINMUXS		32		/* # of I/O pins per port */
+
+/* Port Control Register offsets */
+
+#define PINMUX_CTRL_OFFSET(pin)	(pin * 4)
+
+
+/*
+ * Pin direction configuration, for GPIO function (PINMUX_FUNC_GPIO):
+ * At reset, all GPIO pins are set as input.
+ *
+ * NOTE: This bit field is a software-defined construct and does not
+ * intentionally match any hardware register bit field.
+ */
+
+#define PINMUX_GPIO_DIR_MASK	(0x1 << 20)		/* GPIO pin direction */
+#define PINMUX_GPIO_DIR_INPUT	(0x0 << 20)		/* input GPIO pin */
+#define PINMUX_GPIO_DIR_OUTPUT  (0x1 << 20)		/* output GPIO pin */
+
+/* 
+ * The following pin settings match the K64 PORT module's
+ * Pin Control Register bit fields.
+ */
+
+/*
+ * Pin interrupt configuration:
+ * At reset, interrupts are disabled for all pins.
+ */
+
+#define PINMUX_INT_MASK			(0xF << 16)		/* interrupt configuration */
+#define PINMUX_INT_DISABLE		(0x0 << 16)		/* disable interrupt */
+#define PINMUX_INT_LOW			(0x8 << 16)		/* active-low interrupt */
+#define PINMUX_INT_RISING		(0x9 << 16)		/* rising-edge interrupt */
+#define PINMUX_INT_FALLING		(0xA << 16)		/* falling-edge interrupt */
+#define PINMUX_INT_BOTH_EDGE	(0xB << 16)		/* either edge interrupt */
+#define PINMUX_INT_HIGH			(0xC << 16)		/* active-high interrupt */
+
+/*
+ * Pin function identification:
+ * At reset, the setting for PTA0/1/2/3/4 is function 7;
+ * the remaining pins are set to function 0.
+ */
+
+#define PINMUX_ALT_MASK			(0x7 << 8)
+#define PINMUX_ALT_0			(0x0 << 8)
+#define PINMUX_ALT_1			(0x1 << 8)
+#define PINMUX_ALT_2			(0x2 << 8)
+#define PINMUX_ALT_3			(0x3 << 8)
+#define PINMUX_ALT_4			(0x4 << 8)
+#define PINMUX_ALT_5			(0x5 << 8)
+#define PINMUX_ALT_6			(0x6 << 8)
+#define PINMUX_ALT_7			PINMUX_ALT_MASK
+
+#define PINMUX_FUNC_GPIO		PINMUX_ALT_1
+#define PINMUX_FUNC_DISABLED	PINMUX_ALT_0
+#define PINMUX_FUNC_ANALOG		PINMUX_ALT_0
+
+/*
+ * Pin drive strength configuration, for output:
+ * At reset, the setting for PTA0/1/2/3/4/5 is high drive strength;
+ * the remaining pins are set to low drive strength.
+ */
+
+#define PINMUX_DRV_STRN_MASK	(0x1 << 6)		/* drive strength select */
+#define PINMUX_DRV_STRN_LOW		(0x0 << 6)		/* low drive strength */
+#define PINMUX_DRV_STRN_HIGH	(0x1 << 6)		/* high drive strength */
+
+/*
+ * Pin open drain configuration, for output:
+ * At reset, open drain is disabled for all pins.
+ */
+
+#define PINMUX_OPEN_DRN_MASK	(0x1 << 5)		/* open drain enable */
+#define PINMUX_OPEN_DRN_DISABLE	(0x0 << 5)		/* disable open drain */
+#define PINMUX_OPEN_DRN_ENABLE	(0x1 << 5)		/* enable open drain */
+
+/*
+ * Pin slew rate configuration, for output:
+ * At reset, fast slew rate is set for all pins.
+ */
+
+#define PINMUX_SLEW_RATE_MASK	(0x1 << 2)	/* slew rate select */
+#define PINMUX_SLEW_RATE_FAST	(0x0 << 2)	/* fast slew rate */
+#define PINMUX_SLEW_RATE_SLOW	(0x1 << 2)	/* slow slew rate */
+
+/*
+ * Pin pull-up/pull-down configuration, for input:
+ * At reset, the setting for PTA1/2/3/4/5 is pull-up; PTA0 is pull-down;
+ * pull-up/pull-down is disabled for the remaining pins.
+ */
+
+#define PINMUX_PULL_EN_MASK		(0x1 << 1)		/* pullup/pulldown enable */
+#define PINMUX_PULL_DISABLE		(0x0 << 1)		/* disable pullup/pulldown */
+#define PINMUX_PULL_ENABLE		(0x1 << 1)		/* enable pullup/pulldown */
+
+#define PINMUX_PULL_SEL_MASK	(0x1 << 0)		/* pullup/pulldown select */
+#define PINMUX_PULL_DN			(0x0 << 0)		/* select pulldown */
+#define PINMUX_PULL_UP			(0x1 << 0)		/* select pullup */
+
+
+/*
+ * Pin identification, by port and pin
+ */
+
+#define PIN_PTA0	0
+#define PIN_PTA1	1
+#define PIN_PTA2	2
+#define PIN_PTA3	3
+#define PIN_PTA4	4
+#define PIN_PTA5	5
+#define PIN_PTA6	6
+#define PIN_PTA7	7
+#define PIN_PTA8	8
+#define PIN_PTA9	9
+#define PIN_PTA10	10
+#define PIN_PTA11	11
+#define PIN_PTA12	12
+#define PIN_PTA13	13
+#define PIN_PTA14	14
+#define PIN_PTA15	15
+#define PIN_PTA16	16
+#define PIN_PTA17	17
+#define PIN_PTA18	18
+#define PIN_PTA19	19
+#define PIN_PTA20	20
+#define PIN_PTA21	21
+#define PIN_PTA22	22
+#define PIN_PTA23	23
+#define PIN_PTA24	24
+#define PIN_PTA25	25
+#define PIN_PTA26	26
+#define PIN_PTA27	27
+#define PIN_PTA28	28
+#define PIN_PTA29	29
+#define PIN_PTA30	30
+#define PIN_PTA31	31
+
+#define PIN_PTB0	32
+#define PIN_PTB1	33
+#define PIN_PTB2	34
+#define PIN_PTB3	35
+#define PIN_PTB4	36
+#define PIN_PTB5	37
+#define PIN_PTB6	38
+#define PIN_PTB7	39
+#define PIN_PTB8	40
+#define PIN_PTB9	41
+#define PIN_PTB10	42
+#define PIN_PTB11	43
+#define PIN_PTB12	44
+#define PIN_PTB13	45
+#define PIN_PTB14	46
+#define PIN_PTB15	47
+#define PIN_PTB16	48
+#define PIN_PTB17	49
+#define PIN_PTB18	50
+#define PIN_PTB19	51
+#define PIN_PTB20	52
+#define PIN_PTB21	53
+#define PIN_PTB22	54
+#define PIN_PTB23	55
+#define PIN_PTB24	56
+#define PIN_PTB25	57
+#define PIN_PTB26	58
+#define PIN_PTB27	59
+#define PIN_PTB28	60
+#define PIN_PTB29	61
+#define PIN_PTB30	62
+#define PIN_PTB31	63
+
+#define PIN_PTC0	64
+#define PIN_PTC1	65
+#define PIN_PTC2	66
+#define PIN_PTC3	67
+#define PIN_PTC4	68
+#define PIN_PTC5	69
+#define PIN_PTC6	70
+#define PIN_PTC7	71
+#define PIN_PTC8	72
+#define PIN_PTC9	73
+#define PIN_PTC10	74
+#define PIN_PTC11	75
+#define PIN_PTC12	76
+#define PIN_PTC13	77
+#define PIN_PTC14	78
+#define PIN_PTC15	79
+#define PIN_PTC16	80
+#define PIN_PTC17	81
+#define PIN_PTC18	82
+#define PIN_PTC19	83
+#define PIN_PTC20	84
+#define PIN_PTC21	85
+#define PIN_PTC22	86
+#define PIN_PTC23	87
+#define PIN_PTC24	88
+#define PIN_PTC25	89
+#define PIN_PTC26	90
+#define PIN_PTC27	91
+#define PIN_PTC28	92
+#define PIN_PTC29	93
+#define PIN_PTC30	94
+#define PIN_PTC31	95
+
+#define PIN_PTD0	96
+#define PIN_PTD1	97
+#define PIN_PTD2	98
+#define PIN_PTD3	99
+#define PIN_PTD4	100
+#define PIN_PTD5	101
+#define PIN_PTD6	102
+#define PIN_PTD7	103
+#define PIN_PTD8	104
+#define PIN_PTD9	105
+#define PIN_PTD10	106
+#define PIN_PTD11	107
+#define PIN_PTD12	108
+#define PIN_PTD13	109
+#define PIN_PTD14	110
+#define PIN_PTD15	111
+#define PIN_PTD16	112
+#define PIN_PTD17	113
+#define PIN_PTD18	114
+#define PIN_PTD19	115
+#define PIN_PTD20	116
+#define PIN_PTD21	117
+#define PIN_PTD22	118
+#define PIN_PTD23	119
+#define PIN_PTD24	120
+#define PIN_PTD25	121
+#define PIN_PTD26	122
+#define PIN_PTD27	123
+#define PIN_PTD28	124
+#define PIN_PTD29	125
+#define PIN_PTD30	126
+#define PIN_PTD31	127
+
+#define PIN_PTE0	128
+#define PIN_PTE1	129
+#define PIN_PTE2	130
+#define PIN_PTE3	131
+#define PIN_PTE4	132
+#define PIN_PTE5	133
+#define PIN_PTE6	134
+#define PIN_PTE7	135
+#define PIN_PTE8	136
+#define PIN_PTE9	137
+#define PIN_PTE10	138
+#define PIN_PTE11	139
+#define PIN_PTE12	140
+#define PIN_PTE13	141
+#define PIN_PTE14	142
+#define PIN_PTE15	143
+#define PIN_PTE16	144
+#define PIN_PTE17	145
+#define PIN_PTE18	146
+#define PIN_PTE19	147
+#define PIN_PTE20	148
+#define PIN_PTE21	149
+#define PIN_PTE22	150
+#define PIN_PTE23	151
+#define PIN_PTE24	152
+#define PIN_PTE25	153
+#define PIN_PTE26	154
+#define PIN_PTE27	155
+#define PIN_PTE28	156
+#define PIN_PTE29	157
+#define PIN_PTE30	158
+#define PIN_PTE31	159
+
+#endif /* __INCLUDE_PINMUX_K64_H */
-- 
1.9.1


From 86aeab98d266be81867110b4fb8c819e0f72b846 Mon Sep 17 00:00:00 2001
From: Jeff Blais <jblais@windriver.com>
Date: Fri, 11 Dec 2015 13:23:10 -0500
Subject: [PATCH 73/82] ARM: Add GPIO interrupt/callback support for K64F

Interrupt and callback function support is added to the K64F GPIO driver.
The implementation is based on the Designware GPIO driver (gpio-dw.*).

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index e56ce43..32295ae 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -7,7 +7,7 @@
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
-#     http://www.apache.org/licenses/LICENSE-2.0
+#	 http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
@@ -17,11 +17,11 @@
 #
 
 menuconfig GPIO
-        bool
+		bool
 	prompt "GPIO Drivers"
-        default n
-        help
-          Include GPIO drivers in system config
+		default n
+		help
+		  Include GPIO drivers in system config
 
 if GPIO
 
@@ -101,21 +101,21 @@ config GPIO_DW_CLOCK_GATE_DRV_NAME
 	default ""
 
 config GPIO_DW_0
-       bool "Designware GPIO block 0"
-       depends on GPIO_DW
-       default n
-       help
-       Include Designware GPIO driver
+	   bool "Designware GPIO block 0"
+	   depends on GPIO_DW
+	   default n
+	   help
+	   Include Designware GPIO driver
 
 config GPIO_DW_0_NAME
-       string "Driver name"
-       depends on GPIO_DW_0
-       default "GPIO_0"
+	   string "Driver name"
+	   depends on GPIO_DW_0
+	   default "GPIO_0"
 
 config GPIO_DW_0_BASE_ADDR
-       hex "Controller base address"
-       depends on GPIO_DW_0
-       default 0x00000000
+	   hex "Controller base address"
+	   depends on GPIO_DW_0
+	   default 0x00000000
 
 config	GPIO_DW_0_BUS
 	int "Port 0 PCI Bus"
@@ -138,11 +138,11 @@ config  GPIO_DW_0_BAR
 	default 0
 
 config GPIO_DW_0_BITS
-       int "number of pins controlled"
-       depends on GPIO_DW_0
-       default 32
-       help
-       Number of pins controlled by controller
+	   int "number of pins controlled"
+	   depends on GPIO_DW_0
+	   default 32
+	   help
+	   Number of pins controlled by controller
 
 config GPIO_DW_0_CLOCK_GATE_SUBSYS
 	int "Clock controller's subsystem"
@@ -205,42 +205,42 @@ config GPIO_DW_0_IRQ_SHARED_NAME
 	  correctly.
 
 config GPIO_DW_0_IRQ
-       int "Controller interrupt number"
-       depends on GPIO_DW_0 && GPIO_DW_0_IRQ_DIRECT
-       default 0
-       help
-       IRQ number for the controller
+	   int "Controller interrupt number"
+	   depends on GPIO_DW_0 && GPIO_DW_0_IRQ_DIRECT
+	   default 0
+	   help
+	   IRQ number for the controller
 
 config GPIO_DW_0_PRI
-       int "Controller interrupt priority"
-       depends on GPIO_DW_0 && GPIO_DW_0_IRQ_DIRECT
-       default 2
-       help
-       IRQ priority
+	   int "Controller interrupt priority"
+	   depends on GPIO_DW_0 && GPIO_DW_0_IRQ_DIRECT
+	   default 2
+	   help
+	   IRQ priority
 
 config GPIO_DW_1
-       bool "Designware GPIO block 1"
-       depends on GPIO_DW
-       default n
-       help
-       Include Designware GPIO driver
+	   bool "Designware GPIO block 1"
+	   depends on GPIO_DW
+	   default n
+	   help
+	   Include Designware GPIO driver
 
 config GPIO_DW_1_NAME
-       string "Driver name"
-       depends on GPIO_DW_1
-       default "GPIO_1"
+	   string "Driver name"
+	   depends on GPIO_DW_1
+	   default "GPIO_1"
 
 config GPIO_DW_1_BASE_ADDR
-       hex "Controller base address"
-       depends on GPIO_DW_1
-       default 0x00000000
+	   hex "Controller base address"
+	   depends on GPIO_DW_1
+	   default 0x00000000
 
 config GPIO_DW_1_BITS
-       int "number of pins controlled"
-       depends on GPIO_DW_1
-       default 32
-       help
-       Number of pins controlled by controller
+	   int "number of pins controlled"
+	   depends on GPIO_DW_1
+	   default 32
+	   help
+	   Number of pins controlled by controller
 
 config GPIO_DW_1_CLOCK_GATE_SUBSYS
 	int "Clock controller's subsystem"
@@ -276,18 +276,18 @@ config GPIO_DW_1_IRQ_SHARED_NAME
 	  correctly.
 
 config GPIO_DW_1_IRQ
-       int "Controller interrupt number"
-       depends on GPIO_DW_1 && GPIO_DW_1_IRQ_DIRECT
-       default 0
-       help
-       IRQ number for the controller
+	   int "Controller interrupt number"
+	   depends on GPIO_DW_1 && GPIO_DW_1_IRQ_DIRECT
+	   default 0
+	   help
+	   IRQ number for the controller
 
 config GPIO_DW_1_PRI
-       int "Controller interrupt priority"
-       depends on GPIO_DW_1 && GPIO_DW_1_IRQ_DIRECT
-       default 2
-       help
-       IRQ priority
+	   int "Controller interrupt priority"
+	   depends on GPIO_DW_1 && GPIO_DW_1_IRQ_DIRECT
+	   default 2
+	   help
+	   IRQ priority
 
 choice
 prompt "DW GPIO port 1 trigger condition"
@@ -710,6 +710,11 @@ config GPIO_K64
 	help
 	  Enable driver for Freescale K64-based GPIOs.
 
+config PORT_K64_INT_STATUS_OFFSET
+	hex "Freescale K64-based Port Control interrupt status register offset"
+	depends on GPIO_K64
+	default 0xA0
+
 config GPIO_K64_A
 	bool "Freescale K64-based GPIO Port A"
 	depends on GPIO_K64
@@ -725,14 +730,28 @@ config GPIO_K64_A_DEV_NAME
 	  Specify the device name.
 
 config GPIO_K64_A_BASE_ADDR
-   hex "Freescale K64-based GPIO Port A base address"
-   depends on GPIO_K64_A
-   default 0x400FF000
+	hex "Freescale K64-based GPIO Port A base address"
+	depends on GPIO_K64_A
+	default 0x400FF000
 
 config PORT_K64_A_BASE_ADDR
-   hex "Freescale K64-based Port Control Port A base address"
-   depends on GPIO_K64_A
-   default 0x40049000
+	hex "Freescale K64-based Port Control Port A base address"
+	depends on GPIO_K64_A
+	default 0x40049000
+
+config GPIO_K64_PORTA_IRQ
+	int "Freescale K64-based Port A interrupt number"
+	depends on GPIO_K64_A
+	default 59
+	help
+	  K64 Port A IRQ number for the interrupt controller
+
+config GPIO_K64_PORTA_PRI
+	int "Freescale K64-based Port A interrupt priority"
+	depends on GPIO_K64_A
+	default 2
+	help
+	  K64 Port A IRQ priority
 
 config GPIO_K64_B
 	bool "Freescale K64-based GPIO Port B"
@@ -749,14 +768,28 @@ config GPIO_K64_B_DEV_NAME
 	  Specify the device name.
 
 config GPIO_K64_B_BASE_ADDR
-   hex "Freescale K64-based GPIO Port B base address"
-   depends on GPIO_K64_B
-   default 0x400FF040
+	hex "Freescale K64-based GPIO Port B base address"
+	depends on GPIO_K64_B
+	default 0x400FF040
 
 config PORT_K64_B_BASE_ADDR
-   hex "Freescale K64-based Port Control Port B base address"
-   depends on GPIO_K64_B
-   default 0x4004A000
+	hex "Freescale K64-based Port Control Port B base address"
+	depends on GPIO_K64_B
+	default 0x4004A000
+
+config GPIO_K64_PORTB_IRQ
+	int "Freescale K64-based Port B interrupt number"
+	depends on GPIO_K64_B
+	default 60
+	help
+	K64 Port B IRQ number for the interrupt controller
+
+config GPIO_K64_PORTB_PRI
+	int "Freescale K64-based Port B interrupt priority"
+	depends on GPIO_K64_B
+	default 2
+	help
+	  K64 Port B IRQ priority
 
 config GPIO_K64_C
 	bool "Freescale K64-based GPIO Port B"
@@ -773,14 +806,28 @@ config GPIO_K64_C_DEV_NAME
 	  Specify the device name.
 
 config GPIO_K64_C_BASE_ADDR
-   hex "Freescale K64-based GPIO Port C base address"
-   depends on GPIO_K64_C
-   default 0x400FF080
+	hex "Freescale K64-based GPIO Port C base address"
+	depends on GPIO_K64_C
+	default 0x400FF080
 
 config PORT_K64_C_BASE_ADDR
-   hex "Freescale K64-based Port Control Port C base address"
-   depends on GPIO_K64_C
-   default 0x4004B000
+	hex "Freescale K64-based Port Control Port C base address"
+	depends on GPIO_K64_C
+	default 0x4004B000
+
+config GPIO_K64_PORTC_IRQ
+	int "Freescale K64-based Port C interrupt number"
+	depends on GPIO_K64_C
+	default 61
+	help
+	  K64 Port C IRQ number for the interrupt controller
+
+config GPIO_K64_PORTC_PRI
+	int "Freescale K64-based Port C interrupt priority"
+	depends on GPIO_K64_C
+	default 2
+	help
+	  K64 Port C IRQ priority
 
 config GPIO_K64_D
 	bool "Freescale K64-based GPIO Port D"
@@ -797,14 +844,28 @@ config GPIO_K64_D_DEV_NAME
 	  Specify the device name.
 
 config GPIO_K64_D_BASE_ADDR
-   hex "Freescale K64-based GPIO Port D base address"
-   depends on GPIO_K64_D
-   default 0x400FF0C0
+	hex "Freescale K64-based GPIO Port D base address"
+	depends on GPIO_K64_D
+	default 0x400FF0C0
 
 config PORT_K64_D_BASE_ADDR
-   hex "Freescale K64-based Port Control Port D base address"
-   depends on GPIO_K64_D
-   default 0x4004C000
+	hex "Freescale K64-based Port Control Port D base address"
+	depends on GPIO_K64_D
+	default 0x4004C000
+
+config GPIO_K64_PORTD_IRQ
+	int "Freescale K64-based Port D interrupt number"
+	depends on GPIO_K64_D
+	default 62
+	help
+	K64 Port D IRQ number for the interrupt controller
+
+config GPIO_K64_PORTD_PRI
+	int "Freescale K64-based Port D interrupt priority"
+	depends on GPIO_K64_D
+	default 2
+	help
+	  K64 Port D IRQ priority
 
 config GPIO_K64_E
 	bool "Freescale K64-based GPIO Port E"
@@ -821,13 +882,27 @@ config GPIO_K64_E_DEV_NAME
 	  Specify the device name.
 
 config GPIO_K64_E_BASE_ADDR
-   hex "Freescale K64-based GPIO Port E base address"
-   depends on GPIO_K64_E
-   default 0x400FF100
+	hex "Freescale K64-based GPIO Port E base address"
+	depends on GPIO_K64_E
+	default 0x400FF100
 
 config PORT_K64_E_BASE_ADDR
-   hex "Freescale K64-based Port Control Port E base address"
-   depends on GPIO_K64_E
-   default 0x4004D000
+	hex "Freescale K64-based Port Control Port E base address"
+	depends on GPIO_K64_E
+	default 0x4004D000
+
+config GPIO_K64_PORTE_IRQ
+	int "Freescale K64-based Port E interrupt number"
+	depends on GPIO_K64_E
+	default 63
+	help
+	K64 Port E IRQ number for the interrupt controller
+
+config GPIO_K64_PORTE_PRI
+	int "Freescale K64-based Port E interrupt priority"
+	depends on GPIO_K64_E
+	default 2
+	help
+	  K64 Port E IRQ priority
 
 endif # GPIO
diff --git a/drivers/gpio/gpio_k64.c b/drivers/gpio/gpio_k64.c
index 123d7c5..f2364b8 100644
--- a/drivers/gpio/gpio_k64.c
+++ b/drivers/gpio/gpio_k64.c
@@ -32,7 +32,7 @@
 /**
  * @brief Configure pin or port
  *
- * @param dev Device struct
+ * @param dev Device structure pointer
  * @param access_op Access operation (pin or port)
  * @param pin The pin number
  * @param flags Flags of pin or port
@@ -49,8 +49,8 @@ static int gpio_k64_config(struct device *dev, int access_op,
 
 	/* check for an invalid pin configuration */
 
-	if (flags & GPIO_INT) {
-		/* interrupts not supported */
+	if (((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) ||
+		((flags & GPIO_DIR_IN) && (flags & GPIO_DIR_OUT))) {
 		return DEV_INVALID_OP;
 	}
 
@@ -91,7 +91,36 @@ static int gpio_k64_config(struct device *dev, int access_op,
 		setting = PINMUX_PULL_DISABLE;
 	}
 
-	/* write pull-up/-down configuration settings */
+	/*
+	 * Set up interrupt configuration, in Port Control module:
+	 */
+
+	if (flags & GPIO_INT) {
+
+		/* edge or level */
+
+		if (flags & GPIO_INT_EDGE) {
+
+			if (flags & GPIO_INT_ACTIVE_HIGH) {
+				setting |= PINMUX_INT_RISING;
+			} else if (flags & GPIO_INT_DOUBLE_EDGE) {
+				setting |= PINMUX_INT_BOTH_EDGE;
+			} else {
+				setting |= PINMUX_INT_FALLING;
+			}
+
+		} else {  /* GPIO_INT_LEVEL */
+
+			if (flags & GPIO_INT_ACTIVE_HIGH) {
+				setting |= PINMUX_INT_HIGH;
+			} else {
+				setting |= PINMUX_INT_LOW;
+			}
+
+		} 
+	}
+
+	/* write pull-up/-down and, if set, interrupt configuration settings */
 
 	if (access_op == GPIO_ACCESS_BY_PIN) {
 
@@ -101,6 +130,10 @@ static int gpio_k64_config(struct device *dev, int access_op,
 
 		value &= ~(PINMUX_PULL_EN_MASK | PINMUX_PULL_SEL_MASK);
 
+		if (flags & GPIO_INT) {
+			value &= ~PINMUX_INT_MASK;
+		}
+
 		value |= setting;
 
 		sys_write32(value,
@@ -116,6 +149,10 @@ static int gpio_k64_config(struct device *dev, int access_op,
 
 			value &= ~(PINMUX_PULL_EN_MASK | PINMUX_PULL_SEL_MASK);
 
+			if (flags & GPIO_INT) {
+				value &= ~PINMUX_INT_MASK;
+			}
+
 			value |= setting;
 
 			sys_write32(value,
@@ -130,7 +167,7 @@ static int gpio_k64_config(struct device *dev, int access_op,
 /**
  * @brief Set the pin or port output
  *
- * @param dev Device struct
+ * @param dev Device structure pointer
  * @param access_op Access operation (pin or port)
  * @param pin The pin number
  * @param value Value to set (0 or 1)
@@ -166,7 +203,7 @@ static int gpio_k64_write(struct device *dev, int access_op,
 /**
  * @brief Read the input pin or port status
  *
- * @param dev Device struct
+ * @param dev Device structure pointer
  * @param access_op Access operation (pin or port)
  * @param pin The pin number
  * @param value Value of input pin(s)
@@ -193,34 +230,75 @@ static int gpio_k64_read(struct device *dev, int access_op,
 	return DEV_OK;
 }
 
+/**
+ * @brief Set the application callback for a GPIO port
+ *
+ * @param dev Device structure pointer
+ * @param callback Application callback function
+ *
+ * @return DEV_OK, always
+ */
 static int gpio_k64_set_callback(struct device *dev, gpio_callback_t callback)
 {
-	ARG_UNUSED(dev);
-	ARG_UNUSED(callback);
+	struct gpio_k64_data *data = dev->driver_data;
 
-	return DEV_INVALID_OP;
+	data->callback_func = callback;
+
+	return DEV_OK;
 }
 
+/**
+ * @brief Enable GPIO pin or port callback
+ *
+ * @param dev Device structure pointer
+ * @param access_op Access operation (pin or port)
+ * @param pin Pin number operate on; ignored for port operations
+ *
+ * @return DEV_OK, always
+ */
 static int gpio_k64_enable_callback(struct device *dev, int access_op,
 									uint32_t pin)
 {
-	ARG_UNUSED(dev);
-	ARG_UNUSED(access_op);
-	ARG_UNUSED(pin);
+	struct gpio_k64_data *data = dev->driver_data;
 
-	return DEV_INVALID_OP;
+	if (GPIO_ACCESS_BY_PIN == access_op) {
+		data->pin_callback_enables |= (1 << pin);
+	} else {
+		data->port_callback_enable = 1;
+	}
+
+	return DEV_OK;
 }
 
+/**
+ * @brief Disable GPIO pin or port callback
+ *
+ * @param dev Device structure pointer
+ * @param access_op Access operation (pin or port)
+ * @param pin Pin number operate on; ignored for port operations
+ *
+ * @return DEV_OK, always
+ */
 static int gpio_k64_disable_callback(struct device *dev, int access_op,
 									 uint32_t pin)
 {
-	ARG_UNUSED(dev);
-	ARG_UNUSED(access_op);
-	ARG_UNUSED(pin);
+	struct gpio_k64_data *data = dev->driver_data;
 
-	return DEV_INVALID_OP;
+	if (GPIO_ACCESS_BY_PIN == access_op) {
+		data->pin_callback_enables &= ~(1 << pin);
+	} else {
+		data->port_callback_enable = 0;
+	}
+
+	return DEV_OK;
 }
 
+/**
+ * @brief Save the state of the device and go to low power state
+ * @param dev Pointer to device structure for driver instance
+ *
+ * @return DEV_INVALID_OP, always
+ */
 static int gpio_k64_suspend_port(struct device *dev)
 {
 	ARG_UNUSED(dev);
@@ -228,6 +306,12 @@ static int gpio_k64_suspend_port(struct device *dev)
 	return DEV_INVALID_OP;
 }
 
+/**
+ * @brief Restore state stored during suspend and resume operation
+ * @param dev Pointer to device structure for driver instance
+ *
+ * @return DEV_INVALID_OP, always
+ */
 static int gpio_k64_resume_port(struct device *dev)
 {
 	ARG_UNUSED(dev);
@@ -235,6 +319,61 @@ static int gpio_k64_resume_port(struct device *dev)
 	return DEV_INVALID_OP;
 }
 
+
+/**
+ * @brief Handler for port interrupts
+ * @param dev Pointer to device structure for driver instance
+ *
+ * @return N/A
+ */
+static void gpio_k64_port_isr(void *dev)
+{
+	struct device *port = (struct device *)dev;
+	struct gpio_k64_data *data = port->driver_data;
+	struct gpio_k64_config *config = port->config->config_info;
+	mem_addr_t int_status_reg_addr;
+	uint32_t enabled_int, int_status, pin;
+
+	if (!data->callback_func) {
+		return;
+	}
+
+	int_status_reg_addr = config->port_base_addr +
+						   CONFIG_PORT_K64_INT_STATUS_OFFSET;
+
+	int_status = sys_read32(int_status_reg_addr);
+
+	if (data->port_callback_enable) {
+
+		data->callback_func(port, int_status);
+
+	} else if (data->pin_callback_enables) {
+
+		/* perform callback for each callback-enabled pin with an interrupt */
+
+		enabled_int = int_status & data->pin_callback_enables;
+
+		while ((pin = find_lsb_set(enabled_int))) {
+
+			pin--;	/* normalize the pin number */
+
+			data->callback_func(port, (1 << pin));
+
+			/* clear the interrupt status */
+
+			enabled_int &= ~(1 << pin);
+
+		}
+
+	}
+
+	/* clear the port interrupts */
+
+	sys_write32(0xFFFFFFFF, int_status_reg_addr);
+
+}
+
+
 static struct gpio_driver_api gpio_k64_drv_api_funcs = {
 	.config = gpio_k64_config,
 	.write = gpio_k64_write,
@@ -246,10 +385,11 @@ static struct gpio_driver_api gpio_k64_drv_api_funcs = {
 	.resume = gpio_k64_resume_port,
 };
 
+
 /**
  * @brief Initialization function of Freescale K64-based GPIO port
  *
- * @param dev Device struct
+ * @param dev Device structure pointer
  * @return DEV_OK if successful, failed otherwise.
  */
 int gpio_k64_init(struct device *dev)
@@ -262,69 +402,139 @@ int gpio_k64_init(struct device *dev)
 /* Initialization for Port A */
 #ifdef CONFIG_GPIO_K64_A
 
+static int gpio_k64_A_init(struct device *dev);
+
 static struct gpio_k64_config gpio_k64_A_cfg = {
 	.gpio_base_addr = CONFIG_GPIO_K64_A_BASE_ADDR,
 	.port_base_addr = CONFIG_PORT_K64_A_BASE_ADDR,
 };
 
-DEVICE_INIT(gpio_k64_A, CONFIG_GPIO_K64_A_DEV_NAME, gpio_k64_init,
-			(void *)0, &gpio_k64_A_cfg,
+static struct gpio_k64_data gpio_data_A;
+
+DEVICE_INIT(gpio_k64_A, CONFIG_GPIO_K64_A_DEV_NAME, gpio_k64_A_init,
+			&gpio_data_A, &gpio_k64_A_cfg,
 			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
+static int gpio_k64_A_init(struct device *dev)
+{
+	IRQ_CONNECT(CONFIG_GPIO_K64_PORTA_IRQ, CONFIG_GPIO_K64_PORTA_PRI,
+				gpio_k64_port_isr, DEVICE_GET(gpio_k64_A), 0);
+
+	irq_enable(CONFIG_GPIO_K64_PORTA_IRQ);
+
+	return (gpio_k64_init(dev));
+}
+
 #endif /* CONFIG_GPIO_K64_A */
 
 /* Initialization for Port B */
 #ifdef CONFIG_GPIO_K64_B
 
+static int gpio_k64_B_init(struct device *dev);
+
 static struct gpio_k64_config gpio_k64_B_cfg = {
 	.gpio_base_addr = CONFIG_GPIO_K64_B_BASE_ADDR,
 	.port_base_addr = CONFIG_PORT_K64_B_BASE_ADDR,
 };
 
-DEVICE_INIT(gpio_k64_B, CONFIG_GPIO_K64_B_DEV_NAME, gpio_k64_init,
-			(void *)0, &gpio_k64_B_cfg,
+static struct gpio_k64_data gpio_data_B;
+
+DEVICE_INIT(gpio_k64_B, CONFIG_GPIO_K64_B_DEV_NAME, gpio_k64_B_init,
+			&gpio_data_B, &gpio_k64_B_cfg,
 			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
+static int gpio_k64_B_init(struct device *dev)
+{
+	IRQ_CONNECT(CONFIG_GPIO_K64_PORTB_IRQ, CONFIG_GPIO_K64_PORTB_PRI,
+				gpio_k64_port_isr, DEVICE_GET(gpio_k64_B), 0);
+
+	irq_enable(CONFIG_GPIO_K64_PORTB_IRQ);
+
+	return (gpio_k64_init(dev));
+}
+
 #endif /* CONFIG_GPIO_K64_B */
 
 /* Initialization for Port C */
 #ifdef CONFIG_GPIO_K64_C
 
+static int gpio_k64_C_init(struct device *dev);
+
 static struct gpio_k64_config gpio_k64_C_cfg = {
 	.gpio_base_addr = CONFIG_GPIO_K64_C_BASE_ADDR,
 	.port_base_addr = CONFIG_PORT_K64_C_BASE_ADDR,
 };
 
-DEVICE_INIT(gpio_k64_C, CONFIG_GPIO_K64_C_DEV_NAME, gpio_k64_init,
-			(void *)0, &gpio_k64_C_cfg,
+static struct gpio_k64_data gpio_data_C;
+
+DEVICE_INIT(gpio_k64_C, CONFIG_GPIO_K64_C_DEV_NAME, gpio_k64_C_init,
+			&gpio_data_C, &gpio_k64_C_cfg,
 			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
+static int gpio_k64_C_init(struct device *dev)
+{
+	IRQ_CONNECT(CONFIG_GPIO_K64_PORTC_IRQ, CONFIG_GPIO_K64_PORTC_PRI,
+				gpio_k64_port_isr, DEVICE_GET(gpio_k64_C), 0);
+
+	irq_enable(CONFIG_GPIO_K64_PORTC_IRQ);
+
+	return (gpio_k64_init(dev));
+}
+
 #endif /* CONFIG_GPIO_K64_C */
 
 /* Initialization for Port D */
 #ifdef CONFIG_GPIO_K64_D
 
+static int gpio_k64_D_init(struct device *dev);
+
 static struct gpio_k64_config gpio_k64_D_cfg = {
 	.gpio_base_addr = CONFIG_GPIO_K64_D_BASE_ADDR,
 	.port_base_addr = CONFIG_PORT_K64_D_BASE_ADDR,
 };
 
-DEVICE_INIT(gpio_k64_D, CONFIG_GPIO_K64_D_DEV_NAME, gpio_k64_init,
-			(void *)0, &gpio_k64_D_cfg,
+static struct gpio_k64_data gpio_data_D;
+
+DEVICE_INIT(gpio_k64_D, CONFIG_GPIO_K64_D_DEV_NAME, gpio_k64_D_init,
+			&gpio_data_D, &gpio_k64_D_cfg,
 			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
+static int gpio_k64_D_init(struct device *dev)
+{
+	IRQ_CONNECT(CONFIG_GPIO_K64_PORTD_IRQ, CONFIG_GPIO_K64_PORTD_PRI,
+				gpio_k64_port_isr, DEVICE_GET(gpio_k64_D), 0);
+
+	irq_enable(CONFIG_GPIO_K64_PORTD_IRQ);
+
+	return (gpio_k64_init(dev));
+}
+
 #endif /* CONFIG_GPIO_K64_D */
 
 /* Initialization for Port E */
 #ifdef CONFIG_GPIO_K64_E
 
+static int gpio_k64_E_init(struct device *dev);
+
 static struct gpio_k64_config gpio_k64_E_cfg = {
 	.gpio_base_addr = CONFIG_GPIO_K64_E_BASE_ADDR,
 	.port_base_addr = CONFIG_PORT_K64_E_BASE_ADDR,
 };
 
-DEVICE_INIT(gpio_k64_E, CONFIG_GPIO_K64_E_DEV_NAME, gpio_k64_init,
-			(void *)0, &gpio_k64_E_cfg,
+static struct gpio_k64_data gpio_data_E;
+
+DEVICE_INIT(gpio_k64_E, CONFIG_GPIO_K64_E_DEV_NAME, gpio_k64_E_init,
+			&gpio_data_E, &gpio_k64_E_cfg,
 			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
+static int gpio_k64_E_init(struct device *dev)
+{
+	IRQ_CONNECT(CONFIG_GPIO_K64_PORTE_IRQ, CONFIG_GPIO_K64_PORTE_PRI,
+				gpio_k64_port_isr, DEVICE_GET(gpio_k64_E), 0);
+
+	irq_enable(CONFIG_GPIO_K64_PORTE_IRQ);
+
+	return (gpio_k64_init(dev));
+}
+
 #endif /* CONFIG_GPIO_K64_E */
diff --git a/drivers/gpio/gpio_k64.h b/drivers/gpio/gpio_k64.h
index c7dac66..879ec51 100644
--- a/drivers/gpio/gpio_k64.h
+++ b/drivers/gpio/gpio_k64.h
@@ -54,4 +54,13 @@ struct gpio_k64_config {
 	uint32_t port_base_addr;
 };
 
+
+struct gpio_k64_data {
+	/* port ISR callback routine address */
+	gpio_callback_t callback_func;
+	/* pin callback routine enable flags, by pin number */
+	uint32_t pin_callback_enables;
+	/* port callback routine enable flag */
+	uint8_t port_callback_enable;
+};
 #endif /* _GPIO_K64_H_ */
diff --git a/drivers/pinmux/pinmux_k64.c b/drivers/pinmux/pinmux_k64.c
index 043429a..1367c0e 100644
--- a/drivers/pinmux/pinmux_k64.c
+++ b/drivers/pinmux/pinmux_k64.c
@@ -166,8 +166,7 @@ static uint32_t _fsl_k64_set_pin(struct device *dev,
 	bool is_gpio = false;
 	int gpio_setting;
 
-	if ((pin_id >= CONFIG_PINMUX_NUM_PINS) ||
-		(func & PINMUX_INT_MASK)) {  /* interrupts not supported */
+	if (pin_id >= CONFIG_PINMUX_NUM_PINS) {
 
 		return DEV_INVALID_OP;
 	}
-- 
1.9.1


From b09234c9776c0a217ffaca680ec3107418a63ffa Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 2 Feb 2016 15:25:26 -0500
Subject: [PATCH 74/82] x86/pinmux: merge with expand pinmux API func/mode
 param size

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/boards/arduino_101/pinmux.c b/boards/arduino_101/pinmux.c
index def0a86..274ebe1 100644
--- a/boards/arduino_101/pinmux.c
+++ b/boards/arduino_101/pinmux.c
@@ -229,7 +229,7 @@ static inline void _pinmux_pullups(uint32_t base_address)
 
 
 #ifdef CONFIG_PINMUX_DEV
-static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
+static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint32_t func)
 {
 	struct pinmux_config * const pmux = dev->config->config_info;
 
@@ -262,7 +262,7 @@ static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
 	return DEV_OK;
 }
 
-static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
+static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint32_t *func)
 {
 	struct pinmux_config * const pmux = dev->config->config_info;
 
@@ -297,7 +297,7 @@ static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
 	return DEV_OK;
 }
 #else
-static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
+static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint32_t func)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(pin);
@@ -308,7 +308,7 @@ static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
 	return DEV_NOT_CONFIG;
 }
 
-static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
+static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint32_t *func)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(pin);
diff --git a/boards/quark_d2000_crb/pinmux.c b/boards/quark_d2000_crb/pinmux.c
index 706e388..1ce7fe6 100644
--- a/boards/quark_d2000_crb/pinmux.c
+++ b/boards/quark_d2000_crb/pinmux.c
@@ -149,7 +149,7 @@ static void _quark_d2000_set_mux(uint32_t base, uint32_t pin, uint8_t func)
 }
 
 #ifdef CONFIG_PINMUX_DEV
-static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
+static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint32_t func)
 {
 	struct pinmux_config * const pmux = dev->config->config_info;
 	/*
@@ -184,7 +184,7 @@ static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
 	return DEV_OK;
 }
 
-static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
+static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint32_t *func)
 {
 	struct pinmux_config * const pmux = dev->config->config_info;
 	/*
@@ -218,7 +218,7 @@ static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
 	return DEV_OK;
 }
 #else
-static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
+static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint32_t func)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(pin);
@@ -229,7 +229,7 @@ static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
 	return DEV_NOT_CONFIG;
 }
 
-static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
+static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint32_t *func)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(pin);
diff --git a/boards/quark_se_ctb/pinmux.c b/boards/quark_se_ctb/pinmux.c
index 37a90f1..e0279fa 100644
--- a/boards/quark_se_ctb/pinmux.c
+++ b/boards/quark_se_ctb/pinmux.c
@@ -212,7 +212,7 @@ static uint32_t _quark_se_set_mux(uint32_t base, uint32_t pin, uint8_t func)
 }
 
 #ifdef CONFIG_PINMUX_DEV
-static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
+static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint32_t func)
 {
 	const struct pinmux_config *pmux = dev->config->config_info;
 
@@ -245,7 +245,7 @@ static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
 	return DEV_OK;
 }
 
-static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
+static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint32_t *func)
 {
 	const struct pinmux_config *pmux = dev->config->config_info;
 
@@ -280,7 +280,7 @@ static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
 	return DEV_OK;
 }
 #else
-static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
+static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint32_t func)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(pin);
@@ -291,7 +291,7 @@ static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
 	return DEV_NOT_CONFIG;
 }
 
-static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
+static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint32_t *func)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(pin);
diff --git a/boards/quark_se_devboard/pinmux.c b/boards/quark_se_devboard/pinmux.c
index 9707153..f32673c 100644
--- a/boards/quark_se_devboard/pinmux.c
+++ b/boards/quark_se_devboard/pinmux.c
@@ -210,7 +210,7 @@ static uint32_t _quark_se_set_mux(uint32_t base, uint32_t pin, uint8_t func)
 }
 
 #ifdef CONFIG_PINMUX_DEV
-static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
+static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint32_t func)
 {
 	const struct pinmux_config *pmux = dev->config->config_info;
 
@@ -244,7 +244,7 @@ static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
 	return DEV_OK;
 }
 
-static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
+static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint32_t *func)
 {
 	const struct pinmux_config *pmux = dev->config->config_info;
 
@@ -280,7 +280,7 @@ static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
 	return DEV_OK;
 }
 #else
-static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
+static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint32_t func)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(pin);
@@ -291,7 +291,7 @@ static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
 	return DEV_NOT_CONFIG;
 }
 
-static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
+static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint32_t *func)
 {
 	ARG_UNUSED(dev);
 	ARG_UNUSED(pin);
-- 
1.9.1


From cd3c19e5808b7ce22bf8ed37d4d70143c74b0a04 Mon Sep 17 00:00:00 2001
From: Mike Hirst <michael.hirst@windriver.com>
Date: Mon, 14 Dec 2015 13:48:38 -0500
Subject: [PATCH 75/82] k64f: add Pulse Width Modulation (PWM) support


diff --git a/arch/arm/soc/fsl_frdm_k64f/Kconfig b/arch/arm/soc/fsl_frdm_k64f/Kconfig
index 0fd6785..fc412c2 100644
--- a/arch/arm/soc/fsl_frdm_k64f/Kconfig
+++ b/arch/arm/soc/fsl_frdm_k64f/Kconfig
@@ -165,6 +165,9 @@ config GPIO
 config PINMUX
 	def_bool y
 
+config PWM
+	def_bool n
+
 if GPIO
 
 config GPIO_K64
@@ -220,4 +223,11 @@ config PRESERVE_JTAG_IO_PINS
 
 endif #PINMUX
 
+if PWM
+config PWM_FTM
+	def_bool y
+config PWM_FTM_0
+	def_bool y
+endif
+
 endif
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index a282486..d7ad30b 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -22,6 +22,10 @@ menuconfig PWM
 	help
 	  Enable config options for PWM drivers.
 
+################################################
+# PCA9685
+################################################
+
 config PWM_PCA9685
 	bool "PCA9685 I2C-based PWM chip"
 	depends on PWM && I2C
@@ -96,3 +100,482 @@ config PWM_DW_NUM_PORTS
 	  Specify how many PWM ports on the IP block.
 
 	  Default is 1.
+
+################################################
+# K64 Flex Timer Module (FTM)
+################################################
+
+config PWM_FTM
+	bool "PWM Freescale Flex Timer Module (FTM)"
+	depends on PWM
+	default n
+	help
+	  Enable Pulse Width Modulation driver for Freescale
+	  Flex Timer Module (FTM).
+
+config PWM_FTM_DEBUG
+	bool "Enable Debugging for pwm_ftm driver"
+	depends on PWM_FTM
+	default n
+	help
+	  Enable debugging for pwm_ftm driver.
+
+#### FTM0 #####
+
+config PWM_FTM_0
+	bool "FTM PWM Module 0"
+	depends on PWM_FTM
+	default n
+	help
+	  Enable config PWM options for FTM0 source module.
+
+config PWM_FTM_0_DEV_NAME
+	string "FTM PWM Module 0 Device Name"
+	depends on PWM_FTM_0
+	default "PWM_FTM0"
+	help
+	  Specify the device name for the FTM0 source module.
+
+config PWM_FTM_0_REG_BASE
+       hex "FTM0 Register Base Address"
+       depends on PWM_FTM_0
+       default 0x40038000
+       help
+         Specify the memory mapped base address of FTM0.  This is the address
+	 of FTM0_SC which is the first register of the module
+
+config PWM_FTM_0_PRESCALE
+       int "FTM0 prescale value"
+       default 1
+       depends on PWM_FTM_0
+       help
+         Specify the FTM timer prescale value.  The valid values are
+	 1, 2, 4, 8, 16, 32, 64, or 128
+
+config PWM_FTM_0_PERIOD
+       int "FTM0 period value"
+       default 65535
+       depends on PWM_FTM_0
+       help
+         Specify the FTM0 PWM period in ticks
+
+menu "FTM0 Clock Source"
+
+choice PWM_FTM_0_CLOCK_SOURCE_CHOICE
+        prompt "Choose the FTM0 clock source"
+        default PWM_FTM_0_CLOCK_SOURCE_SYSTEM
+
+config  PWM_FTM_0_CLOCK_SOURCE_NONE
+        bool "No clock selected (FTM counter disable)"
+
+config  PWM_FTM_0_CLOCK_SOURCE_SYSTEM
+        bool "System clock"
+
+config  PWM_FTM_0_CLOCK_SOURCE_FIXED
+        bool "Fixed Frequency Clock"
+
+config  PWM_FTM_0_CLOCK_SOURCE_EXTERNAL
+        bool "External Clock"
+
+config  PWM_FTM_0_CLOCK_SOURCE_QUAD
+        bool "Quadrature Decoder"
+
+endchoice
+
+endmenu
+
+config PWM_FTM_0_CLOCK_SOURCE
+	int
+	# Omit prompt to signify "hidden" option
+	default 0 if PWM_FTM_0_CLOCK_SOURCE_NONE
+	default 1 if PWM_FTM_0_CLOCK_SOURCE_SYSTEM
+	default 2 if PWM_FTM_0_CLOCK_SOURCE_FIXED
+	default 3 if PWM_FTM_0_CLOCK_SOURCE_EXTERNAL
+	default 4 if PWM_FTM_0_CLOCK_SOURCE_QUAD
+	help
+	  Specify FTM0 clock source
+
+config PWM_FTM_0_PHASE_ENABLE_0
+       bool "FTM0 Enable Phase for channel 0"
+       depends on PWM_FTM_0
+       default n
+       help
+         Allow a phase offset on FTM0 channel 0.  This configures
+	 channels 0 and 1 to be in combine mode therefore
+	 channel 1 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_0_PHASE_ENABLE_2
+       bool "FTM0 Enable Phase for channel 2"
+       depends on PWM_FTM_0
+       default n
+       help
+         Allow a phase offset on FTM0 channel 2.  This configures
+	 channels 2 and 3 to be in combine mode therefore
+	 channel 3 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_0_PHASE_ENABLE_4
+       bool "FTM0 Enable Phase for channel 4"
+       depends on PWM_FTM_0
+       default n
+       help
+         Allow a phase offset on FTM0 channel 4.  This configures
+	 channels 4 and 5 to be in combine mode therefore
+	 channel 5 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_0_PHASE_ENABLE_6
+       bool "FTM0 Enable Phase for channel 6"
+       depends on PWM_FTM_0
+       default n
+       help
+         Allow a phase offset on FTM0 channel 6.  This configures
+	 channels 6 and 7 to be in combine mode therefore
+	 channel 7 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+#### FTM1 #####
+
+config PWM_FTM_1
+	bool "FTM PWM Module 1"
+	depends on PWM_FTM
+	default n
+	help
+	  Enable config PWM options for FTM1 source module.
+
+config PWM_FTM_1_DEV_NAME
+	string "FTM PWM Module 1 Device Name"
+	depends on PWM_FTM_1
+	default "PWM_FTM1"
+	help
+	  Specify the device name for the FTM1 source module.
+
+config PWM_FTM_1_REG_BASE
+       hex "FTM1 Register Base Address"
+       depends on PWM_FTM_1
+       default 0x40039000
+       help
+         Specify the memory mapped base address of FTM1.  This is the address
+	 of FTM1_SC which is the first register of the module
+
+config PWM_FTM_1_PRESCALE
+       int "FTM1 prescale value"
+       default 1
+       depends on PWM_FTM_1
+       help
+         Specify the FTM1 timer prescale value.  The valid values are
+	 1, 2, 4, 8, 16, 32, 64, or 128
+
+config PWM_FTM_1_PERIOD
+       int "FTM1 period value"
+       default 65535
+       depends on PWM_FTM_1
+       help
+         Specify the FTM1 PWM period in ticks
+
+menu "FTM1 Clock Source"
+
+choice PWM_FTM_1_CLOCK_SOURCE_CHOICE
+        prompt "Choose the FTM1 clock source"
+        default PWM_FTM_1_CLOCK_SOURCE_SYSTEM
+
+config  PWM_FTM_1_CLOCK_SOURCE_NONE
+        bool "No clock selected (FTM counter disable)"
+
+config  PWM_FTM_1_CLOCK_SOURCE_SYSTEM
+        bool "System clock"
+
+config  PWM_FTM_1_CLOCK_SOURCE_FIXED
+        bool "Fixed Frequency Clock"
+
+config  PWM_FTM_1_CLOCK_SOURCE_EXTERNAL
+        bool "External Clock"
+
+config  PWM_FTM_1_CLOCK_SOURCE_QUAD
+        bool "Quadrature Decoder"
+
+endchoice
+
+endmenu
+
+config PWM_FTM_1_CLOCK_SOURCE
+	int
+	# Omit prompt to signify "hidden" option
+	default 0 if PWM_FTM_1_CLOCK_SOURCE_NONE
+	default 1 if PWM_FTM_1_CLOCK_SOURCE_SYSTEM
+	default 2 if PWM_FTM_1_CLOCK_SOURCE_FIXED
+	default 3 if PWM_FTM_1_CLOCK_SOURCE_EXTERNAL
+	default 4 if PWM_FTM_1_CLOCK_SOURCE_QUAD
+	help
+	  Specify FTM1 clock source
+
+config PWM_FTM_1_PHASE_ENABLE_0
+       bool "FTM1 Enable Phase for channel 0"
+       depends on PWM_FTM_1
+       default n
+       help
+         Allow a phase offset on FTM1 channel 0.  This configures
+	 channels 0 and 1 to be in combine mode therefore
+	 channel 1 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_1_PHASE_ENABLE_2
+       bool "FTM1 Enable Phase for channel 2"
+       depends on PWM_FTM_1
+       default n
+       help
+         Allow a phase offset on FTM1 channel 2.  This configures
+	 channels 2 and 3 to be in combine mode therefore
+	 channel 3 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_1_PHASE_ENABLE_4
+       bool "FTM1 Enable Phase for channel 4"
+       depends on PWM_FTM_1
+       default n
+       help
+         Allow a phase offset on FTM1 channel 4.  This configures
+	 channels 4 and 5 to be in combine mode therefore
+	 channel 5 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_1_PHASE_ENABLE_6
+       bool "FTM1 Enable Phase for channel 6"
+       depends on PWM_FTM_1
+       default n
+       help
+         Allow a phase offset on FTM1 channel 6.  This configures
+	 channels 6 and 7 to be in combine mode therefore
+	 channel 7 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+#### FTM2 #####
+
+config PWM_FTM_2
+	bool "FTM PWM Module 2"
+	depends on PWM_FTM
+	default n
+	help
+	  Enable config PWM options for FTM2 source module.
+
+config PWM_FTM_2_DEV_NAME
+	string "FTM PWM Module 2 Device Name"
+	depends on PWM_FTM_2
+	default "PWM_FTM2"
+	help
+	  Specify the device name for the FTM2 source module.
+
+config PWM_FTM_2_REG_BASE
+       hex "FTM2 Register Base Address"
+       depends on PWM_FTM_2
+       default 0x4003A000
+       help
+         Specify the memory mapped base address of FTM2.  This is the address
+	 of FTM2_SC which is the first register of the module
+
+config PWM_FTM_2_PRESCALE
+       int "FTM2 prescale value"
+       default 1
+       depends on PWM_FTM_2
+       help
+         Specify the FTM2 timer prescale value.  The valid values are
+	 1, 2, 4, 8, 16, 32, 64, or 128
+
+config PWM_FTM_2_PERIOD
+       int "FTM2 period value"
+       default 65535
+       depends on PWM_FTM_2
+       help
+         Specify the FTM2 PWM period in ticks
+
+menu "FTM2 Clock Source"
+
+choice PWM_FTM_2_CLOCK_SOURCE_CHOICE
+        prompt "Choose the FTM2 clock source"
+        default PWM_FTM_2_CLOCK_SOURCE_SYSTEM
+
+config  PWM_FTM_2_CLOCK_SOURCE_NONE
+        bool "No clock selected (FTM counter disable)"
+
+config  PWM_FTM_2_CLOCK_SOURCE_SYSTEM
+        bool "System clock"
+
+config  PWM_FTM_2_CLOCK_SOURCE_FIXED
+        bool "Fixed Frequency Clock"
+
+config  PWM_FTM_2_CLOCK_SOURCE_EXTERNAL
+        bool "External Clock"
+
+config  PWM_FTM_2_CLOCK_SOURCE_QUAD
+        bool "Quadrature Decoder"
+
+endchoice
+
+endmenu
+
+config PWM_FTM_2_CLOCK_SOURCE
+	int
+	# Omit prompt to signify "hidden" option
+	default 0 if PWM_FTM_2_CLOCK_SOURCE_NONE
+	default 1 if PWM_FTM_2_CLOCK_SOURCE_SYSTEM
+	default 2 if PWM_FTM_2_CLOCK_SOURCE_FIXED
+	default 3 if PWM_FTM_2_CLOCK_SOURCE_EXTERNAL
+	default 4 if PWM_FTM_2_CLOCK_SOURCE_QUAD
+	help
+	  Specify FTM2 clock source
+
+config PWM_FTM_2_PHASE_ENABLE_0
+       bool "FTM2 Enable Phase for channel 0"
+       depends on PWM_FTM_2
+       default n
+       help
+         Allow a phase offset on FTM2 channel 0.  This configures
+	 channels 0 and 1 to be in combine mode therefore
+	 channel 1 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_2_PHASE_ENABLE_2
+       bool "FTM2 Enable Phase for channel 2"
+       depends on PWM_FTM_2
+       default n
+       help
+         Allow a phase offset on FTM2 channel 2.  This configures
+	 channels 2 and 3 to be in combine mode therefore
+	 channel 3 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_2_PHASE_ENABLE_4
+       bool "FTM2 Enable Phase for channel 4"
+       depends on PWM_FTM_2
+       default n
+       help
+         Allow a phase offset on FTM2 channel 4.  This configures
+	 channels 4 and 5 to be in combine mode therefore
+	 channel 5 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_2_PHASE_ENABLE_6
+       bool "FTM2 Enable Phase for channel 6"
+       depends on PWM_FTM_2
+       default n
+       help
+         Allow a phase offset on FTM2 channel 6.  This configures
+	 channels 6 and 7 to be in combine mode therefore
+	 channel 7 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+#### FTM3 #####
+
+config PWM_FTM_3
+	bool "FTM PWM Module 3"
+	depends on PWM_FTM
+	default n
+	help
+	  Enable config PWM options for FTM3 source module.
+
+config PWM_FTM_3_DEV_NAME
+	string "FTM PWM Module 3 Device Name"
+	depends on PWM_FTM_3
+	default "PWM_FTM3"
+	help
+	  Specify the device name for the FTM3 source module.
+
+config PWM_FTM_3_REG_BASE
+       hex "FTM3 Register Base Address"
+       depends on PWM_FTM_3
+       default 0x400B9000
+       help
+         Specify the memory mapped base address of FTM3.  This is the address
+	 of FTM3_SC which is the first register of the module
+
+config PWM_FTM_3_PRESCALE
+       int "FTM3 prescale value"
+       default 3
+       depends on PWM_FTM_3
+       help
+         Specify the FTM timer prescale value.  The valid values are
+	 1, 2, 4, 8, 16, 32, 64, or 128
+
+config PWM_FTM_3_PERIOD
+       int "FTM3 period value"
+       default 65535
+       depends on PWM_FTM_3
+       help
+         Specify the FTM3 PWM period in ticks
+
+menu "FTM3 Clock Source"
+
+choice PWM_FTM_3_CLOCK_SOURCE_CHOICE
+        prompt "Choose the FTM3 clock source"
+        default PWM_FTM_3_CLOCK_SOURCE_SYSTEM
+
+config  PWM_FTM_3_CLOCK_SOURCE_NONE
+        bool "No clock selected (FTM counter disable)"
+
+config  PWM_FTM_3_CLOCK_SOURCE_SYSTEM
+        bool "System clock"
+
+config  PWM_FTM_3_CLOCK_SOURCE_FIXED
+        bool "Fixed Frequency Clock"
+
+config  PWM_FTM_3_CLOCK_SOURCE_EXTERNAL
+        bool "External Clock"
+
+config  PWM_FTM_3_CLOCK_SOURCE_QUAD
+        bool "Quadrature Decoder"
+
+endchoice
+
+endmenu
+
+config PWM_FTM_3_CLOCK_SOURCE
+	int
+	# Omit prompt to signify "hidden" option
+	default 0 if PWM_FTM_3_CLOCK_SOURCE_NONE
+	default 1 if PWM_FTM_3_CLOCK_SOURCE_SYSTEM
+	default 2 if PWM_FTM_3_CLOCK_SOURCE_FIXED
+	default 3 if PWM_FTM_3_CLOCK_SOURCE_EXTERNAL
+	default 4 if PWM_FTM_3_CLOCK_SOURCE_QUAD
+	help
+	  Specify FTM3 clock source
+
+config PWM_FTM_3_PHASE_ENABLE_0
+       bool "FTM3 Enable Phase for channel 0"
+       depends on PWM_FTM_3
+       default n
+       help
+         Allow a phase offset on FTM3 channel 0.  This configures
+	 channels 0 and 1 to be in combine mode therefore
+	 channel 1 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_3_PHASE_ENABLE_2
+       bool "FTM3 Enable Phase for channel 2"
+       depends on PWM_FTM_3
+       default n
+       help
+         Allow a phase offset on FTM3 channel 2.  This configures
+	 channels 2 and 3 to be in combine mode therefore
+	 channel 3 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_3_PHASE_ENABLE_4
+       bool "FTM3 Enable Phase for channel 4"
+       depends on PWM_FTM_3
+       default n
+       help
+         Allow a phase offset on FTM3 channel 4.  This configures
+	 channels 4 and 5 to be in combine mode therefore
+	 channel 5 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
+
+config PWM_FTM_3_PHASE_ENABLE_6
+       bool "FTM3 Enable Phase for channel 6"
+       depends on PWM_FTM_3
+       default n
+       help
+         Allow a phase offset on FTM3 channel 6.  This configures
+	 channels 6 and 7 to be in combine mode therefore
+	 channel 7 is not valid as an output signal.
+	 Note: phase is an unsupported feature.
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index 080cf94..4170d70 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -3,3 +3,4 @@ ccflags-y +=-I$(srctree)/drivers
 
 obj-$(CONFIG_PWM_PCA9685)	+= pwm_pca9685.o
 obj-$(CONFIG_PWM_DW)		+= pwm_dw.o
+obj-$(CONFIG_PWM_FTM)		+= pwm_ftm.o
diff --git a/drivers/pwm/pwm_ftm.c b/drivers/pwm/pwm_ftm.c
new file mode 100644
index 0000000..ed54b32
--- /dev/null
+++ b/drivers/pwm/pwm_ftm.c
@@ -0,0 +1,912 @@
+/*
+ * Copyright (c) 2015, Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file PWM driver for Freescale FlexTimer Module (FTM)
+ *
+ * This file implements Pulse Width Modulation using the Freescale FlexTimer
+ * Module (FTM).  Basic functionality is implemented using edge-aligned PWM
+ * mode.  More complex functionality such as non-zero phase is not supported
+ * since combined mode operation is not implemented.
+ *
+ * The following configuration options are supported. ("x" can be one of the
+ * following values: 0, 1, 2, or 3 representing one of the four FMT modules
+ * FTM0, FTM1, FTM2, or FTM3.)
+ *
+ *   - CONFIG_PWM_FTM_x_DEV_NAME: string representing the device name
+ *   - CONFIG_PWM_FTM_x_REG_BASE: the base address of FTM (FTMx_SC)
+ *   - CONFIG_PWM_FTM_x_PRESCALE: the clock prescaler value
+ *   - CONFIG_PWM_FTM_x_CLOCK_SOURCE: the clock source
+ *   - CONFIG_PWM_FTM_DEBUG: enable debug log output for the driver
+ *   - CONFIG_STDOUT_CONSOLE: choose debug logs using printf of printk
+ *
+ * The following configuration options are not supported.  These are place
+ * holders for future functionality
+ *
+ *   - CONFIG_PWM_FTM_x_PHASE_ENABLE_0 support non-zero phase on channel 0
+ *   - CONFIG_PWM_FTM_x_PHASE_ENABLE_1 support non-zero phase on channel 1
+ *   - CONFIG_PWM_FTM_x_PHASE_ENABLE_2 support non-zero phase on channel 2
+ *   - CONFIG_PWM_FTM_x_PHASE_ENABLE_3 support non-zero phase on channel 3
+ */
+
+#include <nanokernel.h>
+
+#include <board.h>
+#include <k20_sim.h>
+#include <pwm.h>
+
+#include "pwm_ftm.h"
+#include <stdio.h>
+
+/*
+ * Non-zero phase is not supported because combine mode is not yet
+ * implemented.
+ */
+#undef COMBINE_MODE_SUPPORT
+
+#ifndef CONFIG_PWM_FTM_DEBUG
+#define DBG(...) {;}
+#else /* CONFIG_PWM_FTM_DEBUG */
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#define DBG printf
+#else
+#include <misc/printk.h>
+#define DBG printk
+#endif /* CONFIG_STDOUT_CONSOLE */
+#endif /* CONFIG_PWM_FTM_DEBUG */
+
+/* Maximum PWM outputs */
+#define MAX_PWM_OUT		8
+
+/**
+ * @brief Enable the clock for the FTM subsystem
+ *
+ * This function must be called before writing to FTM registers.  Failure to
+ * do so may result in bus fault.
+ *
+ * @param ftm_num index indicating which FTM
+ *
+ * @return DEV_OK if successful, failed otherwise
+ */
+
+static int pwm_ftm_clk_enable(uint8_t ftm_num)
+{
+
+	K20_SIM_t *sim =
+		(K20_SIM_t *)PERIPH_ADDR_BASE_SIM; /* sys integ. ctl */
+
+	if (ftm_num > 3) {
+		DBG("ERROR: Illegal FTM number (%d).\n"
+		    "  Cannot enable PWM clock\n", ftm_num);
+		return DEV_INVALID_CONF;
+	}
+
+	/* enabling the FTM by setting one of the bits SIM_SCGC6[26:24] */
+
+	sim->scgc6 |= 1 << (24 + ftm_num);
+
+	return DEV_OK;
+}
+
+
+
+/**
+ * @brief Initial FTM configuration
+ *
+ * Initialize the FTM hardware based on configuration options.
+ *
+ * @param dev Device struct
+ * @param access_op Access operation (pin or port)
+ * @param channel The pwm channel number
+ * @param flags Device flags (unused)
+ *
+ * @return DEV_OK if successful, failed otherwise
+ */
+
+static int pwm_ftm_configure(struct device *dev, int access_op,
+			     uint32_t channel, int flags)
+{
+	int return_val = DEV_OK;
+
+	uint32_t clock_source;
+	uint32_t prescale;
+	uint32_t polarity;
+
+	uint32_t reg_val;
+
+
+	DBG("pwm_ftm_configure...\n");
+
+	const struct pwm_ftm_config * const config =
+		dev->config->config_info;
+
+	ARG_UNUSED(access_op);
+        ARG_UNUSED(flags);
+
+	/* enable the clock for the FTM subsystem */
+	pwm_ftm_clk_enable(config->ftm_num);
+
+	/*
+	 * Initialize:
+	 *  clock source = x (system, fixed, external) from config
+	 *  prescaler divide-by x=(1,2,4,8,16,32,64,128) from config
+	 *  free-running count-up
+	 *  edge-aligned PWM mode
+	 *  pair: independent outputs
+	 *  polarity +
+	 *  no interrupt
+	 */
+
+	/*
+	 * PS[2:0] = prescale
+	 * MOD = pulse width
+	 */
+
+	clock_source = (config->clock_source & 0x3) << PWM_FTM_SC_CLKS_SHIFT;
+
+	if (clock_source == 0) {
+		DBG("Warning: no clock source. PWM is disabled\n");
+	}
+
+
+	switch (config->prescale) {
+		case PWM_FTM_PRESCALE_1:
+			prescale = PWM_FTM_SC_PS_D1;
+			break;
+
+		case PWM_FTM_PRESCALE_2:
+			prescale = PWM_FTM_SC_PS_D2;
+			break;
+
+		case PWM_FTM_PRESCALE_4:
+			prescale = PWM_FTM_SC_PS_D4;
+			break;
+
+		case PWM_FTM_PRESCALE_8:
+			prescale = PWM_FTM_SC_PS_D8;
+			break;
+
+		case PWM_FTM_PRESCALE_16:
+			prescale = PWM_FTM_SC_PS_D16;
+			break;
+
+		case PWM_FTM_PRESCALE_32:
+			prescale = PWM_FTM_SC_PS_D32;
+			break;
+
+		case PWM_FTM_PRESCALE_64:
+			prescale = PWM_FTM_SC_PS_D64;
+			break;
+
+		case PWM_FTM_PRESCALE_128:
+			prescale = PWM_FTM_SC_PS_D128;
+			break;
+
+		default:
+			/* Illegal prescale value. Default to 1. */
+			prescale = PWM_FTM_SC_PS_D1;
+			return_val = DEV_INVALID_OP;
+			break;
+	}
+
+
+#ifdef COMBINE_MODE_SUPPORT
+	/* Enable FTMEN=1 and set outputs to initial value */
+	mode_reg_val = 	sys_read32(PWM_FTM_MODE(config->reg_base));
+	mode_reg_val |= PWM_FTM_MODE_FTMEN | PWM_FTM_MODE_INIT;
+
+	DBG("pwm_ftm_configure sys_write32(0x%08x, 0x%08x)..\n",
+	    mode_reg_val, PWM_FTM_MODE(config->reg_base));
+
+	sys_write32(mode_reg_val, PWM_FTM_MODE(config->reg_base));
+
+	/* Enable enhanced synchronization */
+
+	DBG("pwm_ftm_configure sys_write32(0x%08x, 0x%08x)..\n",
+	    PWM_FTM_SYNCONF_SYNCMODE|PWM_FTM_SYNCONF_CNTINC, PWM_FTM_SYNCONF(config->reg_base));
+
+	sys_write32(PWM_FTM_SYNCONF_SYNCMODE|PWM_FTM_SYNCONF_CNTINC,
+		    PWM_FTM_SYNCONF(config->reg_base));
+
+#endif /*COMBINE_MODE_SUPPORT*/
+
+	/* Configure: PS | CLKS | up-counter | disable TOF intr */
+	reg_val = prescale | clock_source;
+
+	DBG("pwm_ftm_configure sys_write32(0x%08x, 0x%08x)..\n",
+	    reg_val, PWM_FTM_SC(config->reg_base));
+
+	sys_write32(reg_val, PWM_FTM_SC(config->reg_base));
+
+	DBG("pwm_ftm_configure sys_write32(0x%08x, 0x%08x)..\n",
+	    config->period, PWM_FTM_MOD(config->reg_base));
+
+	/* set MOD to max */
+	sys_write32(config->period, PWM_FTM_MOD(config->reg_base));
+
+	/* set channel control to edge-aligned */
+	reg_val = PWM_FTM_CNSC_MSB | PWM_FTM_CNSC_ELSB;
+
+	DBG("pwm_ftm_configure sys_write32(0x%08x, 0x%08x)..\n",
+	    reg_val, PWM_FTM_CNSC(config->reg_base,channel));
+
+	sys_write32(reg_val, PWM_FTM_CNSC(config->reg_base,channel));
+
+	DBG("pwm_ftm_configure sys_read32 4..\n");
+
+	/* set polarity high for this channel */
+	polarity = sys_read32(PWM_FTM_POL(config->reg_base));
+	polarity &= ~(1<<channel);
+
+	DBG("pwm_ftm_configure sys_write32(0x%08x, 0x%08x)..\n",
+	    polarity, PWM_FTM_POL(config->reg_base));
+
+	sys_write32(polarity, PWM_FTM_POL(config->reg_base));
+
+	return return_val;
+}
+
+
+/**
+ * @brief API call to set the on/off timer values
+ *
+ * @param dev Device struct
+ * @param access_op Access operation (pin or port)
+ * @param channel The pwm channel number
+ * @param on Timer count value for the start of the pulse on each cycle (must be 0)
+ * @param off Timer count value for the end of the pulse.  After this, the signal
+ *       will be off (low if positive polarity) for the rest of the cycle.
+ *
+ * @return DEV_OK if successful, failed otherwise
+ */
+
+static int pwm_ftm_set_values(struct device *dev, int access_op,
+			      uint32_t channel, uint32_t on, uint32_t off)
+{
+	const struct pwm_ftm_config * const config =
+		dev->config->config_info;
+	struct pwm_ftm_drv_data * const drv_data =
+		(struct pwm_ftm_drv_data * const)dev->driver_data;
+
+	DBG("pwm_ftm_set_values (on=%d, off=%d)\n", on, off);
+
+	uint32_t pwm_pair;
+	uint32_t combine;
+
+	switch (access_op) {
+		case PWM_ACCESS_BY_PIN:
+
+			break;
+
+		case PWM_ACCESS_ALL:
+
+			return DEV_INVALID_OP;
+			break;
+
+		default:
+			return DEV_INVALID_OP;
+			break;
+	}
+
+	/* If either ON and/or OFF > max ticks, treat PWM as 100%.
+	 * If OFF value == 0, treat it as 0%.
+	 * Otherwise, populate registers accordingly.
+	 */
+
+	if ((on >= config->period) || (off >= config->period)) {
+		/* Fully on. Set to 100% */
+
+		DBG("pwm_ftm_set_values sys_write32(0x%08x, 0x%08x)..\n",
+		    config->period, PWM_FTM_CNV(config->reg_base, channel));
+
+		/* CnV = pulse width */
+		sys_write32(config->period, PWM_FTM_CNV(config->reg_base, channel));
+
+	} else if (off == 0) {
+		/* Fully off. Set to 0% */
+
+		DBG("pwm_ftm_set_values sys_write32(0x%08x, 0x%08x)..\n",
+		    0, PWM_FTM_CNV(config->reg_base, channel));
+
+		/* CnV = 0 */
+		sys_write32(0, PWM_FTM_CNV(config->reg_base, channel));
+
+	} else {
+
+
+		/* if on != 0 then set to combine mode and pwm must be even */
+		if (on != 0) {
+
+#ifdef COMBINE_MODE_SUPPORT
+			/* TODO should verify that the other channel is not in
+			 * use in non-combine mode
+			 */
+
+
+			/* If phase != 0 enable combine mode */
+			if (channel % 2 != 0) {
+				DBG ("If Phase is non-zero pwm must be 0, 2, 4, 6.\n");
+				return DEV_INVALID_CONF;
+			}
+
+			DBG ("Note: Enabling phase on pwm%d therefore "
+			     "pwm%d is not valid for output\n", channel, channel+1);
+
+			pwm_pair = channel / 2;
+
+			/* verify that the pair is configured for non-zero phase */
+			switch (pwm_pair) {
+				case 0:
+					if (!config->phase_enable0) {
+						DBG("Error: Phase capability must be enabled on FTM0\n");
+						return DEV_INVALID_CONF;
+					}
+					break;
+
+				case 1:
+					if (!config->phase_enable2) {
+						DBG("Error: Phase capability must be enabled on FTM2\n");
+						return DEV_INVALID_CONF;
+					}
+					drv_data->phase[1] = on;
+					break;
+
+				case 2:
+					if (!config->phase_enable4) {
+						DBG("Error: Phase capability must be enabled on FTM4\n");
+						return DEV_INVALID_CONF;
+					}
+					break;
+
+				case 3:
+					if (!config->phase_enable6) {
+						DBG("Error: Phase capability must be enabled on FTM0\n");
+						return DEV_INVALID_CONF;
+					}
+					break;
+
+				default:
+					return DEV_INVALID_CONF;
+			}
+
+			drv_data->phase[pwm_pair] = on;
+
+			combine =
+				sys_read32(PWM_FTM_COMBINE(config->reg_base));
+			combine |= 1 << (pwm_pair * 8);
+
+			DBG("pwm_ftm_set_values sys_write32(0x%08x, 0x%08x)..\n",
+			    combine, PWM_FTM_COMBINE(config->reg_base));
+
+			sys_write32(combine, PWM_FTM_COMBINE(config->reg_base));
+
+			DBG("pwm_ftm_set_values sys_write32(0x%08x, 0x%08x)..\n",
+			    on, PWM_FTM_CNV(config->reg_base, channel));
+
+			/* set the on value */
+			sys_write32(on, PWM_FTM_CNV(config->reg_base, channel));
+
+			DBG("pwm_ftm_set_values sys_write32(0x%08x, 0x%08x)..\n",
+			    off, PWM_FTM_CNV(config->reg_base, channel+1));
+
+			/* set the off value */
+			sys_write32(off, PWM_FTM_CNV(config->reg_base, channel+1));
+#else /*COMBINE_MODE_SUPPORT*/
+			DBG("Error: \"on\" value must be zero. Phase is not supported\n");
+			return DEV_INVALID_CONF;
+#endif /*COMBINE_MODE_SUPPORT*/
+
+		} else {
+
+			/* zero phase.  No need to combine two channels. */
+
+			if (channel % 2 != 0) {
+				pwm_pair = (channel - 1) / 2;
+			} else {
+				pwm_pair = channel / 2;
+			}
+
+			drv_data->phase[pwm_pair] = 0;
+
+			combine =
+				sys_read32(PWM_FTM_COMBINE(config->reg_base));
+			combine &= ~(1 << (pwm_pair * 8));
+
+			DBG("pwm_ftm_set_values sys_write32(0x%08x, 0x%08x)..\n",
+			    combine, PWM_FTM_COMBINE(config->reg_base));
+
+			sys_write32(combine, PWM_FTM_COMBINE(config->reg_base));
+
+			/* set the off value */
+
+			DBG("pwm_ftm_set_values sys_write32(0x%08x, 0x%08x)..\n",
+			    off, PWM_FTM_CNV(config->reg_base, channel));
+
+			sys_write32(off, PWM_FTM_CNV(config->reg_base, channel));
+		}
+
+	}
+
+	DBG("pwm_ftm_set_values done.\n");
+
+	return DEV_OK;
+}
+
+/**
+ * @brief API call to set the duty cycle
+ *
+ * Duty cycle describes the percentage of time a signal is in the ON state.
+ *
+ * @param dev Device struct
+ * @param access_op Access operation (pin or port)
+ * @param channel The pwm channel number
+ * @param duty Percentage of time signal is on (value between 0 and 100)
+ *
+ * @return DEV_OK if successful, failed otherwise
+ */
+
+static int pwm_ftm_set_duty_cycle(struct device *dev, int access_op,
+				  uint32_t channel, uint8_t duty)
+{
+	uint32_t on, off;
+
+	const struct pwm_ftm_config * const config =
+		dev->config->config_info;
+	struct pwm_ftm_drv_data * const drv_data =
+		(struct pwm_ftm_drv_data * const)dev->driver_data;
+
+	ARG_UNUSED(access_op);
+
+	DBG("pwm_ftm_set_duty_cycle...\n");
+
+	if (duty == 0) {
+		/* Turn off PWM */
+		on = 0;
+		off = 0;
+	} else if (duty >= 100) {
+		/* Force PWM to be 100% */
+		on = 0;
+		off = config->period + 1;
+	} else {
+
+		on = 0;
+
+        /*
+         * Set the "on" value to the phase offset if it was set by
+         * pwm_ftm_set_phase()
+         */
+
+		switch (channel) {
+			case 0:
+				if (config->phase_enable0)
+					on = drv_data->phase[0];
+				break;
+
+			case 2:
+				if (config->phase_enable2)
+					on = drv_data->phase[1];
+				break;
+
+			case 4:
+				if (config->phase_enable4)
+					on = drv_data->phase[2];
+				break;
+
+			case 6:
+				if (config->phase_enable6)
+					on = drv_data->phase[3];
+				break;
+
+			default:
+				break;
+		}
+
+
+        /* Calculate the timer value for when to stop the pulse */
+
+		off = on + config->period * duty / 100;
+
+		DBG("pwm_ftm_set_duty_cycle on=%d, off=%d, "
+		    "period=%d, duty=%d.\n",
+		    on, off, config->period, duty);
+
+		/* check for valid off value */
+		if (off > config->period)
+			return  DEV_INVALID_OP;
+	}
+
+	return pwm_ftm_set_values(dev, access_op, channel, on, off);
+
+	DBG("pwm_ftm_set_duty_cycle done.\n");
+
+}
+
+/**
+ * @brief API call to set the phase
+ *
+ * Phase describes number of clock ticks of delay before the start of the
+ * pulse.  The maximum count of the FTM timer is 65536 so the phase value is
+ * an integer from 0 to 65536.
+ *
+ * A non-zero phase value requires the timer pair to be set to combined mode
+ * so the odd-numbered (n+1) channel is not available for output
+ *
+ * Note: non-zero phase is not supported in this implementation
+ *
+ * @param dev Device struct
+ * @param access_op Access operation (pin or port)
+ * @param channel The pwm channel number
+ * @param phase Clock ticks of delay before start of the pulse (must be 0)
+ *
+ * @return DEV_OK if successful, failed otherwise
+ */
+
+static int pwm_ftm_set_phase(struct device *dev, int access_op,
+			     uint32_t channel, uint8_t phase)
+{
+
+#ifdef COMBINE_MODE_SUPPORT
+	const struct pwm_ftm_config * const config =
+		dev->config->config_info;
+	struct pwm_ftm_drv_data * const drv_data =
+		(struct pwm_ftm_drv_data * const)dev->driver_data;
+
+	ARG_UNUSED(access_op);
+
+	DBG("pwm_ftm_set_phase...\n");
+
+	if ((phase < 0) || (phase > config->period))
+		return DEV_INVALID_OP;
+
+	switch (channel) {
+		case 0:
+			if (!config->phase_enable0)
+				return DEV_INVALID_OP;
+			drv_data->phase[0] = phase;
+			break;
+
+		case 2:
+			if (!config->phase_enable2)
+				return DEV_INVALID_OP;
+			drv_data->phase[1] = phase;
+			break;
+
+		case 4:
+			if (!config->phase_enable4)
+				return DEV_INVALID_OP;
+			drv_data->phase[2] = phase;
+			break;
+
+		case 6:
+			if (!config->phase_enable6)
+				return DEV_INVALID_OP;
+			drv_data->phase[3] = phase;
+			break;
+
+		default:
+			/* channel must be 0, 2, 4, or 6 */
+			return DEV_INVALID_OP;
+
+	}
+
+	DBG("pwm_ftm_set_phase done.\n");
+
+	return DEV_OK;
+#else /*COMBINE_MODE_SUPPORT*/
+
+	ARG_UNUSED(dev);
+	ARG_UNUSED(access_op);
+	ARG_UNUSED(channel);
+	ARG_UNUSED(phase);
+
+	DBG("ERROR: non-zero phase is not supported.\n");
+
+	return DEV_INVALID_OP;
+#endif /*COMBINE_MODE_SUPPORT*/
+}
+
+/**
+ * @brief API call to disable FTM
+ *
+ * This function simply sets the clock source to "no clock selected" thus
+ * disabling the FTM
+ *
+ * @param dev Device struct
+ *
+ * @return DEV_OK if successful, failed otherwise
+ */
+
+static int pwm_ftm_suspend(struct device *dev)
+{
+	uint32_t reg_val;
+
+	const struct pwm_ftm_config * const config =
+		dev->config->config_info;
+
+	DBG("pwm_ftm_suspend...\n");
+
+	/* set clock source to "no clock selected" */
+
+	reg_val = sys_read32(PWM_FTM_SC(config->reg_base));
+
+	reg_val &= ~PWM_FTM_SC_CLKS_MASK;
+
+	reg_val |= PWM_FTM_SC_CLKS_DISABLE;
+
+	sys_write32(reg_val, PWM_FTM_SC(config->reg_base));
+
+	DBG("pwm_ftm_suspend done.\n");
+
+	return DEV_OK;
+
+}
+
+/**
+ * @brief API call to reenable FTM
+ *
+ * This function simply sets the clock source to the configuration value with
+ * the assumption that FTM was previously disabled by setting the clock source
+ * to "no clock selected" due to a call to pwm_ftm_suspend.
+ *
+ * @param dev Device struct
+ *
+ * @return DEV_OK if successful, failed otherwise
+ */
+
+static int pwm_ftm_resume(struct device *dev)
+{
+	uint32_t clock_source;
+	uint32_t reg_val;
+
+	/* set clock source to config value */
+
+	const struct pwm_ftm_config * const config =
+		dev->config->config_info;
+
+	DBG("pwm_ftm_resume...\n");
+
+	clock_source = (config->clock_source << PWM_FTM_SC_CLKS_SHIFT) &&
+		PWM_FTM_SC_CLKS_MASK;
+
+	reg_val = sys_read32(PWM_FTM_SC(config->reg_base));
+
+	reg_val &= ~PWM_FTM_SC_CLKS_MASK;
+
+	reg_val |= clock_source;
+
+	sys_write32(reg_val, PWM_FTM_SC(config->reg_base));
+
+	DBG("pwm_ftm_resume done.\n");
+
+	return DEV_OK;
+}
+
+static struct pwm_driver_api pwm_ftm_drv_api_funcs = {
+	.config = pwm_ftm_configure,
+	.set_values = pwm_ftm_set_values,
+	.set_duty_cycle = pwm_ftm_set_duty_cycle,
+	.set_phase = pwm_ftm_set_phase,
+	.suspend = pwm_ftm_suspend,
+	.resume = pwm_ftm_resume,
+};
+
+/**
+ * @brief Initialization function of FTM
+ *
+ * @param dev Device struct
+ * @return DEV_OK if successful, failed otherwise.
+ */
+int pwm_ftm_init(struct device *dev)
+{
+
+	DBG("pwm_ftm_init...\n");
+
+	dev->driver_api = &pwm_ftm_drv_api_funcs;
+
+	return DEV_OK;
+}
+
+/* Initialization for PWM_FTM_0 */
+#ifdef CONFIG_PWM_FTM_0
+#include <device.h>
+#include <init.h>
+
+static struct pwm_ftm_config pwm_ftm_0_cfg = {
+	.ftm_num       = 0,
+	.reg_base      = CONFIG_PWM_FTM_0_REG_BASE,
+	.prescale      = CONFIG_PWM_FTM_0_PRESCALE,
+	.clock_source  = CONFIG_PWM_FTM_0_CLOCK_SOURCE,
+
+#ifdef CONFIG_PWM_FTM_0_PHASE_ENABLE_0
+	.phase_enable0 = 1,
+#else
+	.phase_enable0 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_0_PHASE_ENABLE_2
+	.phase_enable2 = 1,
+#else
+	.phase_enable2 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_0_PHASE_ENABLE_4
+	.phase_enable4 = 1,
+#else
+	.phase_enable4 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_0_PHASE_ENABLE_6
+	.phase_enable6 = 1,
+#else
+	.phase_enable6 = 0,
+#endif
+
+	.period = CONFIG_PWM_FTM_0_PERIOD,
+};
+
+static struct pwm_ftm_drv_data pwm_ftm_0_drvdata;
+
+DECLARE_DEVICE_INIT_CONFIG(pwm_ftm_0,
+			   CONFIG_PWM_FTM_0_DEV_NAME,
+			   pwm_ftm_init, &pwm_ftm_0_cfg);
+
+nano_early_init(pwm_ftm_0, &pwm_ftm_0_drvdata);
+
+#endif /* CONFIG_PWM_FTM_0 */
+
+/* Initialization for PWM_FTM_1 */
+#ifdef CONFIG_PWM_FTM_1
+#include <device.h>
+#include <init.h>
+
+static struct pwm_ftm_config pwm_ftm_1_cfg = {
+	.ftm_num       = 1,
+	.reg_base      = CONFIG_PWM_FTM_1_REG_BASE,
+	.prescale      = CONFIG_PWM_FTM_1_PRESCALE,
+	.clock_source  = CONFIG_PWM_FTM_1_CLOCK_SOURCE,
+
+#ifdef CONFIG_PWM_FTM_1_PHASE_ENABLE_0
+	.phase_enable0 = 1,
+#else
+	.phase_enable0 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_1_PHASE_ENABLE_2
+	.phase_enable2 = 1,
+#else
+	.phase_enable2 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_1_PHASE_ENABLE_4
+	.phase_enable4 = 1,
+#else
+	.phase_enable4 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_1_PHASE_ENABLE_6
+	.phase_enable6 = 1,
+#else
+	.phase_enable6 = 0,
+#endif
+
+};
+
+static struct pwm_ftm_drv_data pwm_ftm_1_drvdata;
+
+DECLARE_DEVICE_INIT_CONFIG(pwm_ftm_1,
+			   CONFIG_PWM_FTM_1_DEV_NAME,
+			   pwm_ftm_init, &pwm_ftm_1_cfg);
+
+nano_early_init(pwm_ftm_1, &pwm_ftm_1_drvdata);
+
+#endif /* CONFIG_PWM_FTM_1 */
+
+
+/* Initialization for PWM_FTM_2 */
+#ifdef CONFIG_PWM_FTM_2
+#include <device.h>
+#include <init.h>
+
+static struct pwm_ftm_config pwm_ftm_2_cfg = {
+	.ftm_num       = 2,
+	.reg_base      = CONFIG_PWM_FTM_2_REG_BASE,
+	.prescale      = CONFIG_PWM_FTM_2_PRESCALE,
+	.clock_source  = CONFIG_PWM_FTM_2_CLOCK_SOURCE,
+
+#ifdef CONFIG_PWM_FTM_2_PHASE_ENABLE_0
+	.phase_enable0 = 1,
+#else
+	.phase_enable0 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_2_PHASE_ENABLE_2
+	.phase_enable2 = 1,
+#else
+	.phase_enable2 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_2_PHASE_ENABLE_4
+	.phase_enable4 = 1,
+#else
+	.phase_enable4 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_2_PHASE_ENABLE_6
+	.phase_enable6 = 1,
+#else
+	.phase_enable6 = 0,
+#endif
+
+};
+
+static struct pwm_ftm_drv_data pwm_ftm_2_drvdata;
+
+DECLARE_DEVICE_INIT_CONFIG(pwm_ftm_2,
+			   CONFIG_PWM_FTM_2_DEV_NAME,
+			   pwm_ftm_init, &pwm_ftm_2_cfg);
+
+nano_early_init(pwm_ftm_2, &pwm_ftm_2_drvdata);
+
+#endif /* CONFIG_PWM_FTM_2 */
+
+
+/* Initialization for PWM_FTM_3 */
+#ifdef CONFIG_PWM_FTM_3
+#include <device.h>
+#include <init.h>
+
+static struct pwm_ftm_config pwm_ftm_3_cfg = {
+	.ftm_num       = 3,
+	.reg_base      = CONFIG_PWM_FTM_3_REG_BASE,
+	.prescale      = CONFIG_PWM_FTM_3_PRESCALE,
+	.clock_source  = CONFIG_PWM_FTM_3_CLOCK_SOURCE,
+
+#ifdef CONFIG_PWM_FTM_3_PHASE_ENABLE_0
+	.phase_enable0 = 1,
+#else
+	.phase_enable0 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_3_PHASE_ENABLE_2
+	.phase_enable2 = 1,
+#else
+	.phase_enable2 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_3_PHASE_ENABLE_4
+	.phase_enable4 = 1,
+#else
+	.phase_enable4 = 0,
+#endif
+
+#ifdef CONFIG_PWM_FTM_3_PHASE_ENABLE_6
+	.phase_enable6 = 1,
+#else
+	.phase_enable6 = 0,
+#endif
+
+};
+
+static struct pwm_ftm_drv_data pwm_ftm_3_drvdata;
+
+DECLARE_DEVICE_INIT_CONFIG(pwm_ftm_3,
+			   CONFIG_PWM_FTM_3_DEV_NAME,
+			   pwm_ftm_init, &pwm_ftm_3_cfg);
+
+nano_early_init(pwm_ftm_3, &pwm_ftm_3_drvdata);
+
+#endif /* CONFIG_PWM_FTM_3 */
diff --git a/drivers/pwm/pwm_ftm.h b/drivers/pwm/pwm_ftm.h
new file mode 100644
index 0000000..ee68264
--- /dev/null
+++ b/drivers/pwm/pwm_ftm.h
@@ -0,0 +1,185 @@
+/*
+ * Copyright (c) 2015, Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file Header file for the PWM driver for Freescale FlexTimer Module (FTM)
+ */
+
+#ifndef __PWM_FTM_H__
+#define __PWM_FTM_H__
+
+#include <stdbool.h>
+
+/* Valid prescale values */
+#define PWM_FTM_PRESCALE_1       1
+#define PWM_FTM_PRESCALE_2       2
+#define PWM_FTM_PRESCALE_4       4
+#define PWM_FTM_PRESCALE_8       8
+#define PWM_FTM_PRESCALE_16     16
+#define PWM_FTM_PRESCALE_32     32
+#define PWM_FTM_PRESCALE_64     64
+#define PWM_FTM_PRESCALE_128   128
+
+/* flags are not used.  This value can be passed into pwm_pin_configure */
+#define PWM_FTM_FLAG_NONE        0
+
+
+/* FTM register bit definitions */
+
+
+#define PWM_FTM_SC(base)       ((base)+0x00) /* Status And Control */
+#define PWM_FTM_CNT(base)      ((base)+0x04) /* Counter */
+#define PWM_FTM_MOD(base)      ((base)+0x08) /* Modulo */
+
+#define PWM_FTM_CNSC(base,ch)  ((base)+0x0C+(ch)*8) /* Channel-n Status&Ctrl */
+#define PWM_FTM_CNV(base,ch)   ((base)+0x10+(ch)*8) /* Channel-n Value */
+
+#define PWM_FTM_CNTIN(base)    ((base)+0x4C) /* Counter Initial Value */
+#define PWM_FTM_STATUS(base)   ((base)+0x50) /* Capture And Compare Status */
+#define PWM_FTM_MODE(base)     ((base)+0x54) /* Features Mode Selection */
+#define PWM_FTM_SYNC(base)     ((base)+0x58) /* Synchronization */
+#define PWM_FTM_OUTINIT(base)  ((base)+0x5C) /* Initial St For Channels Output */
+#define PWM_FTM_OUTMASK(base)  ((base)+0x60) /* Output Mask */
+#define PWM_FTM_COMBINE(base)  ((base)+0x64) /* Function For Linked Channels */
+#define PWM_FTM_DEADTIME(base) ((base)+0x68) /* Deadtime Insertion Control */
+#define PWM_FTM_EXTTRIG(base)  ((base)+0x6C) /* FTM External Trigger */
+#define PWM_FTM_POL(base)      ((base)+0x70) /* Channels Polarity */
+#define PWM_FTM_FMS(base)      ((base)+0x74) /* Fault Mode Status */
+#define PWM_FTM_FILTER(base)   ((base)+0x78) /* Input Capture Filter Control */
+#define PWM_FTM_FLTCTRL(base)  ((base)+0x7C) /* Fault Control */
+#define PWM_FTM_QDCTRL(base)   ((base)+0x80) /* Quadrature Decoder Ctrl&Status */
+#define PWM_FTM_CONF(base)     ((base)+0x84) /* Configuration */
+#define PWM_FTM_FLTPOL(base)   ((base)+0x88) /* FTM Fault Input Polarity */
+#define PWM_FTM_SYNCONF(base)  ((base)+0x8C) /* Synchronization Configuration */
+#define PWM_FTM_INVCTRL(base)  ((base)+0x90) /* FTM Inverting Control */
+#define PWM_FTM_SWOCTRL(base)  ((base)+0x94) /* FTM Software Output Control */
+#define PWM_FTM_PWMLOAD(base)  ((base)+0x98) /* FTM PWM Load */
+
+/* PWM_FTM_SC Status And Control */
+
+#define PWM_FTM_SC_CLKS_MASK      0x18
+#define PWM_FTM_SC_CLKS_SHIFT     3
+
+#define PWM_FTM_SC_CLKS_DISABLE   0x0
+#define PWM_FTM_SC_CLKS_SYSTEM    0x1
+#define PWM_FTM_SC_CLKS_FIXED     0x2
+#define PWM_FTM_SC_CLKS_EXTERNAL  0x3
+
+#define PWM_FTM_SC_PS_D1   (0x0<<0)
+#define PWM_FTM_SC_PS_D2   (0x1<<0)
+#define PWM_FTM_SC_PS_D4   (0x2<<0)
+#define PWM_FTM_SC_PS_D8   (0x3<<0)
+#define PWM_FTM_SC_PS_D16  (0x4<<0)
+#define PWM_FTM_SC_PS_D32  (0x5<<0)
+#define PWM_FTM_SC_PS_D64  (0x6<<0)
+#define PWM_FTM_SC_PS_D128 (0x7<<0)
+
+#define PWM_FTM_SC_PS_MASK (0x7<<0)
+
+/* PWM_FTM_CNSC (FTMx_CnSC) Channel-n Status And Control */
+#define PWM_FTM_CNSC_DMA  (0x1<<0)
+#define PWM_FTM_CNSC_ELSA (0x1<<2)
+#define PWM_FTM_CNSC_ELSB (0x1<<3)
+#define PWM_FTM_CNSC_MSA  (0x1<<4)
+#define PWM_FTM_CNSC_MSB  (0x1<<5)
+#define PWM_FTM_CNSC_CHIE (0x1<<6)
+#define PWM_FTM_CNSC_CHF  (0x1<<7)
+
+/* PWM_FTM_MODE  Features Mode Selection */
+#define PWM_FTM_MODE_FTMEN        (0x1<<0)
+#define PWM_FTM_MODE_INIT         (0x1<<1)
+#define PWM_FTM_MODE_WPDIS        (0x1<<2)
+#define PWM_FTM_MODE_PWMSYNC      (0x1<<3)
+#define PWM_FTM_MODE_CAPTEST      (0x1<<4)
+
+#define PWM_FTM_MODE_FAULTM_DISABLE (0x0<<5)
+#define PWM_FTM_MODE_FAULTM_EVEN    (0x1<<5)
+#define PWM_FTM_MODE_FAULTM_MANUAL  (0x2<<5)
+#define PWM_FTM_MODE_FAULTM_AUTO    (0x3<<5)
+#define PWM_FTM_MODE_FAULTM_MASK    (0x3<<5)
+
+#define PWM_FTM_MODE_FAULTIE        (0x1<<7)
+
+/* PWM_FTM_SYNC PWM Synchronization */
+#define PWM_FTM_SYNC_CNTMIN         (0x1<<0)
+#define PWM_FTM_SYNC_CNTMAX         (0x1<<1)
+#define PWM_FTM_SYNC_REINIT         (0x1<<2)
+#define PWM_FTM_SYNC_SYNCHOM        (0x1<<3)
+#define PWM_FTM_SYNC_TRIG0          (0x1<<4)
+#define PWM_FTM_SYNC_TRIG1          (0x1<<5)
+#define PWM_FTM_SYNC_TRIG2          (0x1<<6)
+#define PWM_FTM_SYNC_SWSYNC         (0x1<<7)
+
+/* PWM_FTM_EXTTRIG FTM External Trigger */
+#define PWM_FTM_EXTTRIG_CH2TRIG     (0x1<<0)
+#define PWM_FTM_EXTTRIG_CH3TRIG     (0x1<<1)
+#define PWM_FTM_EXTTRIG_CH4TRIG     (0x1<<2)
+#define PWM_FTM_EXTTRIG_CH5TRIG     (0x1<<3)
+#define PWM_FTM_EXTTRIG_CH0TRIG     (0x1<<4)
+#define PWM_FTM_EXTTRIG_CH1TRIG     (0x1<<5)
+#define PWM_FTM_EXTTRIG_INTTRIGEN   (0x1<<6)
+#define PWM_FTM_EXTTRIG_TRIGF       (0x1<<7)
+
+/* PWM_FTM_QDCTRL Quadrature Decoder Ctrl&Status */
+#define PWM_FTM_QDCTRL_QUADEN       (0x1<<0)
+
+/* PWM_FTM_SYNCONF Syncronization Configuration */
+#define PWM_FTM_SYNCONF_HWTRIGMODE  (0x1<<0)
+#define PWM_FTM_SYNCONF_CNTINC      (0x1<<2)
+#define PWM_FTM_SYNCONF_INVC        (0x1<<4)
+#define PWM_FTM_SYNCONF_SWOC        (0x1<<5)
+#define PWM_FTM_SYNCONF_SYNCMODE    (0x1<<7)
+
+/**
+ * @brief Initialization function for FlexTimer Module FTM (PWM mode)
+ *
+ * @param dev Device struct
+ * @return DEV_OK if successful, failed otherwise
+ */
+extern int pwm_ftm_init(struct device *dev);
+
+/** Configuration data */
+struct pwm_ftm_config {
+
+	/* FTM register base address */
+	uint32_t ftm_num;
+
+	/* FTM register base address */
+	uint32_t reg_base;
+
+	/* FTM prescale (1,2,4,8,16,32,64,128) */
+	uint32_t prescale;
+
+	/* FTM clock source  */
+	uint32_t clock_source;
+
+	/* If phase is not 0, the odd-numbered channel is not available */
+	bool phase_enable0;  /* combine pwm0, pwm1 for phase capability */
+	bool phase_enable2;  /* combine pwm2, pwm3 for phase capability */
+	bool phase_enable4;  /* combine pwm4, pwm4 for phase capability */
+	bool phase_enable6;  /* combine pwm6, pwm5 for phase capability */
+
+	/* FTM period (clock ticks) */
+	uint32_t period;
+
+};
+
+/** Runtime driver data */
+struct pwm_ftm_drv_data {
+	uint32_t phase[4];
+};
+
+#endif /* __PWM_FTM_H__ */
diff --git a/drivers/pwm/pwm_pca9685.c b/drivers/pwm/pwm_pca9685.c
index 74b1138..73c36e8 100644
--- a/drivers/pwm/pwm_pca9685.c
+++ b/drivers/pwm/pwm_pca9685.c
@@ -154,6 +154,19 @@ static int pwm_pca9685_set_duty_cycle(struct device *dev, int access_op,
 	return pwm_pca9685_set_values(dev, access_op, pwm, on, off);
 }
 
+/**
+ * Phase describes number of clock ticks of delay before the start of the
+ * pulse.  This functionality is not a supported.
+ */
+static int pwm_pca9685_set_phase(struct device *dev, int access_op,
+				  uint32_t pwm, uint8_t phase)
+{
+	if (phase != 0)
+		return DEV_INVALID_OP;
+	else
+		return DEV_OK;
+}
+
 static int pwm_pca9685_suspend(struct device *dev)
 {
 	if (!_has_i2c_master(dev)) {
@@ -176,6 +189,7 @@ static struct pwm_driver_api pwm_pca9685_drv_api_funcs = {
 	.config = pwm_pca9685_configure,
 	.set_values = pwm_pca9685_set_values,
 	.set_duty_cycle = pwm_pca9685_set_duty_cycle,
+	.set_phase = pwm_pca9685_set_phase,
 	.suspend = pwm_pca9685_suspend,
 	.resume = pwm_pca9685_resume,
 };
diff --git a/include/pwm.h b/include/pwm.h
index 4ea3c0c..2d01a36 100644
--- a/include/pwm.h
+++ b/include/pwm.h
@@ -47,6 +47,8 @@ typedef int (*pwm_set_values_t)(struct device *dev, int access_op,
 				uint32_t pwm, uint32_t on, uint32_t off);
 typedef int (*pwm_set_duty_cycle_t)(struct device *dev, int access_op,
 				    uint32_t pwm, uint8_t duty);
+typedef int (*pwm_set_phase_t)(struct device *dev, int access_op,
+				    uint32_t pwm, uint8_t phase);
 typedef int (*pwm_suspend_dev_t)(struct device *dev);
 typedef int (*pwm_resume_dev_t)(struct device *dev);
 
@@ -54,6 +56,7 @@ struct pwm_driver_api {
 	pwm_config_t config;
 	pwm_set_values_t set_values;
 	pwm_set_duty_cycle_t set_duty_cycle;
+	pwm_set_phase_t set_phase;
 	pwm_suspend_dev_t suspend;
 	pwm_resume_dev_t resume;
 };
-- 
1.9.1


From a0525aee08aaeb56f5c32c7cdb6a8b34bbbd3de4 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 2 Feb 2016 16:49:07 -0500
Subject: [PATCH 76/82] gcc/vxworks: add C++ compiler

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/scripts/Makefile.toolchain.vxworks b/scripts/Makefile.toolchain.vxworks
index 3aca715..ff4597b 100644
--- a/scripts/Makefile.toolchain.vxworks
+++ b/scripts/Makefile.toolchain.vxworks
@@ -28,6 +28,7 @@ export CROSS_COMPILE TOOLCHAIN_LIBS LIB_INCLUDE_DIR
 AS      = $(CC)
 LD      = $(CROSS_COMPILE)ld$(CROSS_COMPILE_SUFFIX)
 CC      = $(CROSS_COMPILE)cc$(CROSS_COMPILE_SUFFIX)
+CXX     = $(CROSS_COMPILE)c++$(CROSS_COMPILE_SUFFIX)
 CPP     = $(CROSS_COMPILE)cpp$(CROSS_COMPILE_SUFFIX)
 AR      = $(CROSS_COMPILE)ar$(CROSS_COMPILE_SUFFIX)
 NM      = $(CROSS_COMPILE)nm$(CROSS_COMPILE_SUFFIX)
-- 
1.9.1


From 7fb4100f854252e67bd6317edc27c5dbea87cb0c Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 2 Feb 2016 16:56:08 -0500
Subject: [PATCH 77/82] MERGE WITH 21210575


diff --git a/arch/arm/soc/fsl_frdm_k64f/soc_config.c b/arch/arm/soc/fsl_frdm_k64f/soc_config.c
index 51e95f4..9688b33 100644
--- a/arch/arm/soc/fsl_frdm_k64f/soc_config.c
+++ b/arch/arm/soc/fsl_frdm_k64f/soc_config.c
@@ -208,14 +208,13 @@ int fsl_frdm_k64f_pin_init(struct device *arg)
 	/* configure the pins from the default mapping above */
 
 	for (i = 0; i < NUM_DFLT_PINS_SET; i++) {
-		pinmux_set_pin(pmux, mux_config[i].pin_num, mux_config[i].mode);
+		pinmux_pin_set(pmux, mux_config[i].pin_num, mux_config[i].mode);
 	}
 
 	return DEV_OK;
 }
 
 /* This needs to be initialized after GPIO. */
-DEVICE_INIT(frdm_k64f_pmux, "", fsl_frdm_k64f_pin_init, NULL, NULL, PRIMARY,
-				KERNEL_INIT_PRIORITY_DEVICE);
-
+DEVICE_INIT(frdm_k64f_pmux, "", fsl_frdm_k64f_pin_init, NULL, NULL,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);
 #endif /* CONFIG_PINMUX */
-- 
1.9.1


From 3809602e470ee5c1581d635cf0fa1184182863ba Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 2 Feb 2016 16:57:32 -0500
Subject: [PATCH 78/82] MERGE WITH ee842648

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/drivers/gpio/gpio_k64.c b/drivers/gpio/gpio_k64.c
index f2364b8..e784ff2 100644
--- a/drivers/gpio/gpio_k64.c
+++ b/drivers/gpio/gpio_k64.c
@@ -89,6 +89,8 @@ static int gpio_k64_config(struct device *dev, int access_op,
 		setting = (PINMUX_PULL_ENABLE | PINMUX_PULL_DN);
 	} else if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
 		setting = PINMUX_PULL_DISABLE;
+	} else {
+		return DEV_INVALID_OP;
 	}
 
 	/*
-- 
1.9.1


From 2c767d3f04c33aea7613ca9c0bc107a57bb7a3d5 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 2 Feb 2016 16:58:50 -0500
Subject: [PATCH 79/82] MERGE WITH pwm_ftm.c implementation

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/drivers/pwm/pwm_ftm.c b/drivers/pwm/pwm_ftm.c
index ed54b32..94198c2 100644
--- a/drivers/pwm/pwm_ftm.c
+++ b/drivers/pwm/pwm_ftm.c
@@ -760,11 +760,9 @@ static struct pwm_ftm_config pwm_ftm_0_cfg = {
 
 static struct pwm_ftm_drv_data pwm_ftm_0_drvdata;
 
-DECLARE_DEVICE_INIT_CONFIG(pwm_ftm_0,
-			   CONFIG_PWM_FTM_0_DEV_NAME,
-			   pwm_ftm_init, &pwm_ftm_0_cfg);
-
-nano_early_init(pwm_ftm_0, &pwm_ftm_0_drvdata);
+DEVICE_INIT(pwm_ftm_0, CONFIG_PWM_FTM_0_DEV_NAME, pwm_ftm_init,
+			&pwm_ftm_0_drvdata, &pwm_ftm_0_cfg,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
 #endif /* CONFIG_PWM_FTM_0 */
 
@@ -807,11 +805,9 @@ static struct pwm_ftm_config pwm_ftm_1_cfg = {
 
 static struct pwm_ftm_drv_data pwm_ftm_1_drvdata;
 
-DECLARE_DEVICE_INIT_CONFIG(pwm_ftm_1,
-			   CONFIG_PWM_FTM_1_DEV_NAME,
-			   pwm_ftm_init, &pwm_ftm_1_cfg);
-
-nano_early_init(pwm_ftm_1, &pwm_ftm_1_drvdata);
+DEVICE_INIT(pwm_ftm_1, CONFIG_PWM_FTM_1_DEV_NAME, pwm_ftm_init,
+			&pwm_ftm_1_drvdata, &pwm_ftm_1_cfg,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
 #endif /* CONFIG_PWM_FTM_1 */
 
@@ -855,11 +851,9 @@ static struct pwm_ftm_config pwm_ftm_2_cfg = {
 
 static struct pwm_ftm_drv_data pwm_ftm_2_drvdata;
 
-DECLARE_DEVICE_INIT_CONFIG(pwm_ftm_2,
-			   CONFIG_PWM_FTM_2_DEV_NAME,
-			   pwm_ftm_init, &pwm_ftm_2_cfg);
-
-nano_early_init(pwm_ftm_2, &pwm_ftm_2_drvdata);
+DEVICE_INIT(pwm_ftm_2, CONFIG_PWM_FTM_2_DEV_NAME, pwm_ftm_init,
+			&pwm_ftm_2_drvdata, &pwm_ftm_2_cfg,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
 #endif /* CONFIG_PWM_FTM_2 */
 
@@ -903,10 +897,8 @@ static struct pwm_ftm_config pwm_ftm_3_cfg = {
 
 static struct pwm_ftm_drv_data pwm_ftm_3_drvdata;
 
-DECLARE_DEVICE_INIT_CONFIG(pwm_ftm_3,
-			   CONFIG_PWM_FTM_3_DEV_NAME,
-			   pwm_ftm_init, &pwm_ftm_3_cfg);
-
-nano_early_init(pwm_ftm_3, &pwm_ftm_3_drvdata);
+DEVICE_INIT(pwm_ftm_3, CONFIG_PWM_FTM_3_DEV_NAME, pwm_ftm_init,
+			&pwm_ftm_3_drvdata, &pwm_ftm_3_cfg,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
 
 #endif /* CONFIG_PWM_FTM_3 */
-- 
1.9.1


From 00c51772a73e1e485b42389115cdf3498e7ca9ac Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 2 Feb 2016 17:01:29 -0500
Subject: [PATCH 80/82] pinmux: use new DEVICE_INIT() (should be refactored to
 fit with 2121057 and 86aeab9

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/drivers/pinmux/pinmux_k64.c b/drivers/pinmux/pinmux_k64.c
index 1367c0e..3f802cb 100644
--- a/drivers/pinmux/pinmux_k64.c
+++ b/drivers/pinmux/pinmux_k64.c
@@ -344,11 +344,6 @@ struct pinmux_config fsl_k64_pmux = {
 	.base_address = 0x00000000,
 };
 
-DECLARE_DEVICE_INIT_CONFIG(pmux,
-			  PINMUX_NAME,
-			  &pinmux_fsl_k64_initialize,
-			  &fsl_k64_pmux);
-
 struct fsl_k64_data fsl_k64_pinmux_driver = {
 	.gpio_a = NULL,
 	.gpio_b = NULL,
@@ -357,12 +352,7 @@ struct fsl_k64_data fsl_k64_pinmux_driver = {
 	.gpio_e = NULL
 };
 
-/*
- * This needs to be a level 2 or later init process due to the following
- * dependency chain:
- * 0 - I2C
- * 1 - GPIO
- * 2 - pinmux
- */
-nano_late_init(pmux, &fsl_k64_pinmux_driver);
-
+/* must be initialized after GPIO */
+DEVICE_INIT(pmux, PINMUX_NAME, &pinmux_fsl_k64_initialize,
+			&fsl_k64_pinmux_driver, &fsl_k64_pmux,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);
-- 
1.9.1


From 1544c6db273b4b9b09b842c92e1a9c9a4d6fcbf6 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Wed, 3 Feb 2016 16:54:28 -0500
Subject: [PATCH 81/82] gdb: change license to Apache

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>

diff --git a/arch/x86/core/debug/debug_frames.c b/arch/x86/core/debug/debug_frames.c
index 1c6b822..443f26a 100644
--- a/arch/x86/core/debug/debug_frames.c
+++ b/arch/x86/core/debug/debug_frames.c
@@ -1,31 +1,17 @@
 /*
- * Copyright (c) 2015, Wind River Systems, Inc.
+ * Copyright (c) 2015 Wind River Systems, Inc.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- * 1) Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- * 2) Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3) Neither the name of Wind River Systems nor the names of its contributors
- * may be used to endorse or promote products derived from this software without
- * specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 /**
diff --git a/arch/x86/debug/gdb_arch.c b/arch/x86/debug/gdb_arch.c
index 42d3671..a07b19e 100644
--- a/arch/x86/debug/gdb_arch.c
+++ b/arch/x86/debug/gdb_arch.c
@@ -1,33 +1,17 @@
-/* gdb_arch.c - architecture dependent routine for the GDB server */
-
 /*
  * Copyright (c) 2015 Wind River Systems, Inc.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1) Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2) Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3) Neither the name of Wind River Systems nor the names of its contributors
- * may be used to endorse or promote products derived from this software without
- * specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 /* includes */
diff --git a/arch/x86/include/debug/gdb_arch.h b/arch/x86/include/debug/gdb_arch.h
index 5ef8814..fe56140 100644
--- a/arch/x86/include/debug/gdb_arch.h
+++ b/arch/x86/include/debug/gdb_arch.h
@@ -1,33 +1,17 @@
-/* gdb_arch.h - architecture dependent GDB Server header file */
-
 /*
  * Copyright (c) 2015 Wind River Systems, Inc.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1) Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2) Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- * 3) Neither the name of Wind River Systems nor the names of its contributors
- * may be used to endorse or promote products derived from this software without
- * specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef __INCgdb_archh
diff --git a/include/misc/debug/debug_info.h b/include/misc/debug/debug_info.h
index 49852ad..7329327 100644
--- a/include/misc/debug/debug_info.h
+++ b/include/misc/debug/debug_info.h
@@ -1,31 +1,17 @@
 /*
- * Copyright (c) 2015, Wind River Systems, Inc.
+ * Copyright (c) 2015 Wind River Systems, Inc.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- * 1) Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- * 2) Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3) Neither the name of Wind River Systems nor the names of its contributors
- * may be used to endorse or promote products derived from this software without
- * specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 /**
diff --git a/include/misc/debug/gdb_server.h b/include/misc/debug/gdb_server.h
index 37c3791..9b721e9 100644
--- a/include/misc/debug/gdb_server.h
+++ b/include/misc/debug/gdb_server.h
@@ -1,33 +1,17 @@
-/* gdb_server.h - GDB Server header file */
-
 /*
  * Copyright (c) 2015 Wind River Systems, Inc.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1) Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2) Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- * 3) Neither the name of Wind River Systems nor the names of its contributors
- * may be used to endorse or promote products derived from this software without
- * specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef __INCgdb_serverh
diff --git a/misc/debug/gdb_server.c b/misc/debug/gdb_server.c
index 25bf7aa..16a1e8d 100644
--- a/misc/debug/gdb_server.c
+++ b/misc/debug/gdb_server.c
@@ -1,33 +1,17 @@
-/* gdb_server.c - GDB server */
-
 /*
  * Copyright (c) 2015 Wind River Systems, Inc.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1) Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2) Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- * 3) Neither the name of Wind River Systems nor the names of its contributors
- * may be used to endorse or promote products derived from this software without
- * specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 /*
diff --git a/samples/microkernel/apps/gdb_server/src/gdb_start.c b/samples/microkernel/apps/gdb_server/src/gdb_start.c
index 342a0ab..cdb4f4e 100644
--- a/samples/microkernel/apps/gdb_server/src/gdb_start.c
+++ b/samples/microkernel/apps/gdb_server/src/gdb_start.c
@@ -1,33 +1,17 @@
-/* gdb_start.c - GDB Server demo */
-
 /*
  * Copyright (c) 2015 Wind River Systems, Inc.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1) Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2) Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- * 3) Neither the name of Wind River Systems nor the names of its contributors
- * may be used to endorse or promote products derived from this software without
- * specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include <stdint.h>
-- 
1.9.1


From 583c3165d2af386b02fea8a0c7892ec88db244c3 Mon Sep 17 00:00:00 2001
From: Dmitriy Korovkin <dmitriy.korovkin@windriver.com>
Date: Tue, 9 Feb 2016 15:39:00 -0500
Subject: [PATCH 82/82] frdm-64k platform:Fix typo in macro

Signed-off-by: Dmitriy Korovkin <dmitriy.korovkin@windriver.com>

diff --git a/arch/arm/soc/fsl_frdm_k64f/soc_config.c b/arch/arm/soc/fsl_frdm_k64f/soc_config.c
index 9688b33..5888386 100644
--- a/arch/arm/soc/fsl_frdm_k64f/soc_config.c
+++ b/arch/arm/soc/fsl_frdm_k64f/soc_config.c
@@ -44,7 +44,7 @@
  * UART configuration
  */
 
-#ifdef CONFIG_K20_UART
+#ifdef CONFIG_UART_K20
 
 #if defined(CONFIG_UART_CONSOLE)
 #if defined(CONFIG_PRINTK) || defined(CONFIG_STDOUT_CONSOLE)
-- 
1.9.1

